// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_types_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_types_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_types_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_types_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_types_2eproto;
namespace maarpc {
class BoolResponse;
struct BoolResponseDefaultTypeInternal;
extern BoolResponseDefaultTypeInternal _BoolResponse_default_instance_;
class BufferRequest;
struct BufferRequestDefaultTypeInternal;
extern BufferRequestDefaultTypeInternal _BufferRequest_default_instance_;
class BufferResponse;
struct BufferResponseDefaultTypeInternal;
extern BufferResponseDefaultTypeInternal _BufferResponse_default_instance_;
class Callback;
struct CallbackDefaultTypeInternal;
extern CallbackDefaultTypeInternal _Callback_default_instance_;
class ClickParam;
struct ClickParamDefaultTypeInternal;
extern ClickParamDefaultTypeInternal _ClickParam_default_instance_;
class EmptyRequest;
struct EmptyRequestDefaultTypeInternal;
extern EmptyRequestDefaultTypeInternal _EmptyRequest_default_instance_;
class EmptyResponse;
struct EmptyResponseDefaultTypeInternal;
extern EmptyResponseDefaultTypeInternal _EmptyResponse_default_instance_;
class HandleBufferRequest;
struct HandleBufferRequestDefaultTypeInternal;
extern HandleBufferRequestDefaultTypeInternal _HandleBufferRequest_default_instance_;
class HandleHandleRequest;
struct HandleHandleRequestDefaultTypeInternal;
extern HandleHandleRequestDefaultTypeInternal _HandleHandleRequest_default_instance_;
class HandleIIdRequest;
struct HandleIIdRequestDefaultTypeInternal;
extern HandleIIdRequestDefaultTypeInternal _HandleIIdRequest_default_instance_;
class HandleIdRequest;
struct HandleIdRequestDefaultTypeInternal;
extern HandleIdRequestDefaultTypeInternal _HandleIdRequest_default_instance_;
class HandleRequest;
struct HandleRequestDefaultTypeInternal;
extern HandleRequestDefaultTypeInternal _HandleRequest_default_instance_;
class HandleResponse;
struct HandleResponseDefaultTypeInternal;
extern HandleResponseDefaultTypeInternal _HandleResponse_default_instance_;
class HandleStringRequest;
struct HandleStringRequestDefaultTypeInternal;
extern HandleStringRequestDefaultTypeInternal _HandleStringRequest_default_instance_;
class IIdResponse;
struct IIdResponseDefaultTypeInternal;
extern IIdResponseDefaultTypeInternal _IIdResponse_default_instance_;
class IdRequest;
struct IdRequestDefaultTypeInternal;
extern IdRequestDefaultTypeInternal _IdRequest_default_instance_;
class IdResponse;
struct IdResponseDefaultTypeInternal;
extern IdResponseDefaultTypeInternal _IdResponse_default_instance_;
class KeyParam;
struct KeyParamDefaultTypeInternal;
extern KeyParamDefaultTypeInternal _KeyParam_default_instance_;
class KeyValueRequest;
struct KeyValueRequestDefaultTypeInternal;
extern KeyValueRequestDefaultTypeInternal _KeyValueRequest_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Rect;
struct RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class Size;
struct SizeDefaultTypeInternal;
extern SizeDefaultTypeInternal _Size_default_instance_;
class SizeResponse;
struct SizeResponseDefaultTypeInternal;
extern SizeResponseDefaultTypeInternal _SizeResponse_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class StringRequest;
struct StringRequestDefaultTypeInternal;
extern StringRequestDefaultTypeInternal _StringRequest_default_instance_;
class StringResponse;
struct StringResponseDefaultTypeInternal;
extern StringResponseDefaultTypeInternal _StringResponse_default_instance_;
class SwipeParam;
struct SwipeParamDefaultTypeInternal;
extern SwipeParamDefaultTypeInternal _SwipeParam_default_instance_;
class TouchParam;
struct TouchParamDefaultTypeInternal;
extern TouchParamDefaultTypeInternal _TouchParam_default_instance_;
}  // namespace maarpc
PROTOBUF_NAMESPACE_OPEN
template<> ::maarpc::BoolResponse* Arena::CreateMaybeMessage<::maarpc::BoolResponse>(Arena*);
template<> ::maarpc::BufferRequest* Arena::CreateMaybeMessage<::maarpc::BufferRequest>(Arena*);
template<> ::maarpc::BufferResponse* Arena::CreateMaybeMessage<::maarpc::BufferResponse>(Arena*);
template<> ::maarpc::Callback* Arena::CreateMaybeMessage<::maarpc::Callback>(Arena*);
template<> ::maarpc::ClickParam* Arena::CreateMaybeMessage<::maarpc::ClickParam>(Arena*);
template<> ::maarpc::EmptyRequest* Arena::CreateMaybeMessage<::maarpc::EmptyRequest>(Arena*);
template<> ::maarpc::EmptyResponse* Arena::CreateMaybeMessage<::maarpc::EmptyResponse>(Arena*);
template<> ::maarpc::HandleBufferRequest* Arena::CreateMaybeMessage<::maarpc::HandleBufferRequest>(Arena*);
template<> ::maarpc::HandleHandleRequest* Arena::CreateMaybeMessage<::maarpc::HandleHandleRequest>(Arena*);
template<> ::maarpc::HandleIIdRequest* Arena::CreateMaybeMessage<::maarpc::HandleIIdRequest>(Arena*);
template<> ::maarpc::HandleIdRequest* Arena::CreateMaybeMessage<::maarpc::HandleIdRequest>(Arena*);
template<> ::maarpc::HandleRequest* Arena::CreateMaybeMessage<::maarpc::HandleRequest>(Arena*);
template<> ::maarpc::HandleResponse* Arena::CreateMaybeMessage<::maarpc::HandleResponse>(Arena*);
template<> ::maarpc::HandleStringRequest* Arena::CreateMaybeMessage<::maarpc::HandleStringRequest>(Arena*);
template<> ::maarpc::IIdResponse* Arena::CreateMaybeMessage<::maarpc::IIdResponse>(Arena*);
template<> ::maarpc::IdRequest* Arena::CreateMaybeMessage<::maarpc::IdRequest>(Arena*);
template<> ::maarpc::IdResponse* Arena::CreateMaybeMessage<::maarpc::IdResponse>(Arena*);
template<> ::maarpc::KeyParam* Arena::CreateMaybeMessage<::maarpc::KeyParam>(Arena*);
template<> ::maarpc::KeyValueRequest* Arena::CreateMaybeMessage<::maarpc::KeyValueRequest>(Arena*);
template<> ::maarpc::Point* Arena::CreateMaybeMessage<::maarpc::Point>(Arena*);
template<> ::maarpc::Rect* Arena::CreateMaybeMessage<::maarpc::Rect>(Arena*);
template<> ::maarpc::Size* Arena::CreateMaybeMessage<::maarpc::Size>(Arena*);
template<> ::maarpc::SizeResponse* Arena::CreateMaybeMessage<::maarpc::SizeResponse>(Arena*);
template<> ::maarpc::StatusResponse* Arena::CreateMaybeMessage<::maarpc::StatusResponse>(Arena*);
template<> ::maarpc::StringRequest* Arena::CreateMaybeMessage<::maarpc::StringRequest>(Arena*);
template<> ::maarpc::StringResponse* Arena::CreateMaybeMessage<::maarpc::StringResponse>(Arena*);
template<> ::maarpc::SwipeParam* Arena::CreateMaybeMessage<::maarpc::SwipeParam>(Arena*);
template<> ::maarpc::TouchParam* Arena::CreateMaybeMessage<::maarpc::TouchParam>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace maarpc {

// ===================================================================

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Size final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.Size) */ {
 public:
  inline Size() : Size(nullptr) {}
  ~Size() override;
  explicit PROTOBUF_CONSTEXPR Size(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Size(const Size& from);
  Size(Size&& from) noexcept
    : Size() {
    *this = ::std::move(from);
  }

  inline Size& operator=(const Size& from) {
    CopyFrom(from);
    return *this;
  }
  inline Size& operator=(Size&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Size& default_instance() {
    return *internal_default_instance();
  }
  static inline const Size* internal_default_instance() {
    return reinterpret_cast<const Size*>(
               &_Size_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Size& a, Size& b) {
    a.Swap(&b);
  }
  inline void Swap(Size* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Size* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Size* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Size>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Size& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Size& from) {
    Size::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Size* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.Size";
  }
  protected:
  explicit Size(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.Size)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t width_;
    int32_t height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Rect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.Rect) */ {
 public:
  inline Rect() : Rect(nullptr) {}
  ~Rect() override;
  explicit PROTOBUF_CONSTEXPR Rect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rect(const Rect& from);
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rect& operator=(Rect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }
  inline void Swap(Rect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rect& from) {
    Rect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.Rect";
  }
  protected:
  explicit Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXyFieldNumber = 1,
    kWhFieldNumber = 2,
  };
  // optional .maarpc.Point xy = 1;
  bool has_xy() const;
  private:
  bool _internal_has_xy() const;
  public:
  void clear_xy();
  const ::maarpc::Point& xy() const;
  PROTOBUF_NODISCARD ::maarpc::Point* release_xy();
  ::maarpc::Point* mutable_xy();
  void set_allocated_xy(::maarpc::Point* xy);
  private:
  const ::maarpc::Point& _internal_xy() const;
  ::maarpc::Point* _internal_mutable_xy();
  public:
  void unsafe_arena_set_allocated_xy(
      ::maarpc::Point* xy);
  ::maarpc::Point* unsafe_arena_release_xy();

  // optional .maarpc.Size wh = 2;
  bool has_wh() const;
  private:
  bool _internal_has_wh() const;
  public:
  void clear_wh();
  const ::maarpc::Size& wh() const;
  PROTOBUF_NODISCARD ::maarpc::Size* release_wh();
  ::maarpc::Size* mutable_wh();
  void set_allocated_wh(::maarpc::Size* wh);
  private:
  const ::maarpc::Size& _internal_wh() const;
  ::maarpc::Size* _internal_mutable_wh();
  public:
  void unsafe_arena_set_allocated_wh(
      ::maarpc::Size* wh);
  ::maarpc::Size* unsafe_arena_release_wh();

  // @@protoc_insertion_point(class_scope:maarpc.Rect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maarpc::Point* xy_;
    ::maarpc::Size* wh_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class Callback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.Callback) */ {
 public:
  inline Callback() : Callback(nullptr) {}
  ~Callback() override;
  explicit PROTOBUF_CONSTEXPR Callback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Callback(const Callback& from);
  Callback(Callback&& from) noexcept
    : Callback() {
    *this = ::std::move(from);
  }

  inline Callback& operator=(const Callback& from) {
    CopyFrom(from);
    return *this;
  }
  inline Callback& operator=(Callback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Callback& default_instance() {
    return *internal_default_instance();
  }
  static inline const Callback* internal_default_instance() {
    return reinterpret_cast<const Callback*>(
               &_Callback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Callback& a, Callback& b) {
    a.Swap(&b);
  }
  inline void Swap(Callback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Callback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Callback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Callback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Callback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Callback& from) {
    Callback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Callback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.Callback";
  }
  protected:
  explicit Callback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kDetailFieldNumber = 2,
  };
  // optional string msg = 1;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // optional string detail = 2;
  bool has_detail() const;
  private:
  bool _internal_has_detail() const;
  public:
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.Callback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class ClickParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.ClickParam) */ {
 public:
  inline ClickParam() : ClickParam(nullptr) {}
  ~ClickParam() override;
  explicit PROTOBUF_CONSTEXPR ClickParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClickParam(const ClickParam& from);
  ClickParam(ClickParam&& from) noexcept
    : ClickParam() {
    *this = ::std::move(from);
  }

  inline ClickParam& operator=(const ClickParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClickParam& operator=(ClickParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClickParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClickParam* internal_default_instance() {
    return reinterpret_cast<const ClickParam*>(
               &_ClickParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClickParam& a, ClickParam& b) {
    a.Swap(&b);
  }
  inline void Swap(ClickParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClickParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClickParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClickParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClickParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClickParam& from) {
    ClickParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClickParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.ClickParam";
  }
  protected:
  explicit ClickParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
  };
  // optional .maarpc.Point point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::maarpc::Point& point() const;
  PROTOBUF_NODISCARD ::maarpc::Point* release_point();
  ::maarpc::Point* mutable_point();
  void set_allocated_point(::maarpc::Point* point);
  private:
  const ::maarpc::Point& _internal_point() const;
  ::maarpc::Point* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::maarpc::Point* point);
  ::maarpc::Point* unsafe_arena_release_point();

  // @@protoc_insertion_point(class_scope:maarpc.ClickParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maarpc::Point* point_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class SwipeParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SwipeParam) */ {
 public:
  inline SwipeParam() : SwipeParam(nullptr) {}
  ~SwipeParam() override;
  explicit PROTOBUF_CONSTEXPR SwipeParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwipeParam(const SwipeParam& from);
  SwipeParam(SwipeParam&& from) noexcept
    : SwipeParam() {
    *this = ::std::move(from);
  }

  inline SwipeParam& operator=(const SwipeParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwipeParam& operator=(SwipeParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwipeParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwipeParam* internal_default_instance() {
    return reinterpret_cast<const SwipeParam*>(
               &_SwipeParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SwipeParam& a, SwipeParam& b) {
    a.Swap(&b);
  }
  inline void Swap(SwipeParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwipeParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwipeParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwipeParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwipeParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwipeParam& from) {
    SwipeParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwipeParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SwipeParam";
  }
  protected:
  explicit SwipeParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kDurationFieldNumber = 3,
  };
  // optional .maarpc.Point from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::maarpc::Point& from() const;
  PROTOBUF_NODISCARD ::maarpc::Point* release_from();
  ::maarpc::Point* mutable_from();
  void set_allocated_from(::maarpc::Point* from);
  private:
  const ::maarpc::Point& _internal_from() const;
  ::maarpc::Point* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::maarpc::Point* from);
  ::maarpc::Point* unsafe_arena_release_from();

  // optional .maarpc.Point to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const ::maarpc::Point& to() const;
  PROTOBUF_NODISCARD ::maarpc::Point* release_to();
  ::maarpc::Point* mutable_to();
  void set_allocated_to(::maarpc::Point* to);
  private:
  const ::maarpc::Point& _internal_to() const;
  ::maarpc::Point* _internal_mutable_to();
  public:
  void unsafe_arena_set_allocated_to(
      ::maarpc::Point* to);
  ::maarpc::Point* unsafe_arena_release_to();

  // optional int32 duration = 3;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  int32_t duration() const;
  void set_duration(int32_t value);
  private:
  int32_t _internal_duration() const;
  void _internal_set_duration(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.SwipeParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maarpc::Point* from_;
    ::maarpc::Point* to_;
    int32_t duration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class KeyParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.KeyParam) */ {
 public:
  inline KeyParam() : KeyParam(nullptr) {}
  ~KeyParam() override;
  explicit PROTOBUF_CONSTEXPR KeyParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyParam(const KeyParam& from);
  KeyParam(KeyParam&& from) noexcept
    : KeyParam() {
    *this = ::std::move(from);
  }

  inline KeyParam& operator=(const KeyParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyParam& operator=(KeyParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyParam* internal_default_instance() {
    return reinterpret_cast<const KeyParam*>(
               &_KeyParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(KeyParam& a, KeyParam& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyParam& from) {
    KeyParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.KeyParam";
  }
  protected:
  explicit KeyParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // optional int32 key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.KeyParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class TouchParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.TouchParam) */ {
 public:
  inline TouchParam() : TouchParam(nullptr) {}
  ~TouchParam() override;
  explicit PROTOBUF_CONSTEXPR TouchParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TouchParam(const TouchParam& from);
  TouchParam(TouchParam&& from) noexcept
    : TouchParam() {
    *this = ::std::move(from);
  }

  inline TouchParam& operator=(const TouchParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline TouchParam& operator=(TouchParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TouchParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const TouchParam* internal_default_instance() {
    return reinterpret_cast<const TouchParam*>(
               &_TouchParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TouchParam& a, TouchParam& b) {
    a.Swap(&b);
  }
  inline void Swap(TouchParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TouchParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TouchParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TouchParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TouchParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TouchParam& from) {
    TouchParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TouchParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.TouchParam";
  }
  protected:
  explicit TouchParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 2,
    kContactFieldNumber = 1,
    kPressureFieldNumber = 3,
  };
  // optional .maarpc.Point pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::maarpc::Point& pos() const;
  PROTOBUF_NODISCARD ::maarpc::Point* release_pos();
  ::maarpc::Point* mutable_pos();
  void set_allocated_pos(::maarpc::Point* pos);
  private:
  const ::maarpc::Point& _internal_pos() const;
  ::maarpc::Point* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::maarpc::Point* pos);
  ::maarpc::Point* unsafe_arena_release_pos();

  // optional int32 contact = 1;
  bool has_contact() const;
  private:
  bool _internal_has_contact() const;
  public:
  void clear_contact();
  int32_t contact() const;
  void set_contact(int32_t value);
  private:
  int32_t _internal_contact() const;
  void _internal_set_contact(int32_t value);
  public:

  // optional int32 pressure = 3;
  bool has_pressure() const;
  private:
  bool _internal_has_pressure() const;
  public:
  void clear_pressure();
  int32_t pressure() const;
  void set_pressure(int32_t value);
  private:
  int32_t _internal_pressure() const;
  void _internal_set_pressure(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.TouchParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maarpc::Point* pos_;
    int32_t contact_;
    int32_t pressure_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class EmptyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.EmptyRequest) */ {
 public:
  inline EmptyRequest() : EmptyRequest(nullptr) {}
  ~EmptyRequest() override;
  explicit PROTOBUF_CONSTEXPR EmptyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyRequest(const EmptyRequest& from);
  EmptyRequest(EmptyRequest&& from) noexcept
    : EmptyRequest() {
    *this = ::std::move(from);
  }

  inline EmptyRequest& operator=(const EmptyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyRequest& operator=(EmptyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyRequest*>(
               &_EmptyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EmptyRequest& a, EmptyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmptyRequest& from) {
    EmptyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.EmptyRequest";
  }
  protected:
  explicit EmptyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnusedFieldNumber = 1,
  };
  // optional bool unused = 1;
  bool has_unused() const;
  private:
  bool _internal_has_unused() const;
  public:
  void clear_unused();
  bool unused() const;
  void set_unused(bool value);
  private:
  bool _internal_unused() const;
  void _internal_set_unused(bool value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.EmptyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool unused_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class IdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.IdRequest) */ {
 public:
  inline IdRequest() : IdRequest(nullptr) {}
  ~IdRequest() override;
  explicit PROTOBUF_CONSTEXPR IdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IdRequest(const IdRequest& from);
  IdRequest(IdRequest&& from) noexcept
    : IdRequest() {
    *this = ::std::move(from);
  }

  inline IdRequest& operator=(const IdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdRequest& operator=(IdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdRequest* internal_default_instance() {
    return reinterpret_cast<const IdRequest*>(
               &_IdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IdRequest& a, IdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IdRequest& from) {
    IdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.IdRequest";
  }
  protected:
  explicit IdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.IdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class HandleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.HandleRequest) */ {
 public:
  inline HandleRequest() : HandleRequest(nullptr) {}
  ~HandleRequest() override;
  explicit PROTOBUF_CONSTEXPR HandleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleRequest(const HandleRequest& from);
  HandleRequest(HandleRequest&& from) noexcept
    : HandleRequest() {
    *this = ::std::move(from);
  }

  inline HandleRequest& operator=(const HandleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleRequest& operator=(HandleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleRequest* internal_default_instance() {
    return reinterpret_cast<const HandleRequest*>(
               &_HandleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(HandleRequest& a, HandleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleRequest& from) {
    HandleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.HandleRequest";
  }
  protected:
  explicit HandleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.HandleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class BufferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.BufferRequest) */ {
 public:
  inline BufferRequest() : BufferRequest(nullptr) {}
  ~BufferRequest() override;
  explicit PROTOBUF_CONSTEXPR BufferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BufferRequest(const BufferRequest& from);
  BufferRequest(BufferRequest&& from) noexcept
    : BufferRequest() {
    *this = ::std::move(from);
  }

  inline BufferRequest& operator=(const BufferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BufferRequest& operator=(BufferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BufferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BufferRequest* internal_default_instance() {
    return reinterpret_cast<const BufferRequest*>(
               &_BufferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BufferRequest& a, BufferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BufferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BufferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BufferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BufferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BufferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BufferRequest& from) {
    BufferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.BufferRequest";
  }
  protected:
  explicit BufferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // optional bytes buffer = 1;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_NODISCARD std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.BufferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class StringRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.StringRequest) */ {
 public:
  inline StringRequest() : StringRequest(nullptr) {}
  ~StringRequest() override;
  explicit PROTOBUF_CONSTEXPR StringRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringRequest(const StringRequest& from);
  StringRequest(StringRequest&& from) noexcept
    : StringRequest() {
    *this = ::std::move(from);
  }

  inline StringRequest& operator=(const StringRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringRequest& operator=(StringRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringRequest* internal_default_instance() {
    return reinterpret_cast<const StringRequest*>(
               &_StringRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StringRequest& a, StringRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StringRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringRequest& from) {
    StringRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.StringRequest";
  }
  protected:
  explicit StringRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrFieldNumber = 1,
  };
  // optional string str = 1;
  bool has_str() const;
  private:
  bool _internal_has_str() const;
  public:
  void clear_str();
  const std::string& str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str();
  PROTOBUF_NODISCARD std::string* release_str();
  void set_allocated_str(std::string* str);
  private:
  const std::string& _internal_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str(const std::string& value);
  std::string* _internal_mutable_str();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.StringRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class HandleBufferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.HandleBufferRequest) */ {
 public:
  inline HandleBufferRequest() : HandleBufferRequest(nullptr) {}
  ~HandleBufferRequest() override;
  explicit PROTOBUF_CONSTEXPR HandleBufferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleBufferRequest(const HandleBufferRequest& from);
  HandleBufferRequest(HandleBufferRequest&& from) noexcept
    : HandleBufferRequest() {
    *this = ::std::move(from);
  }

  inline HandleBufferRequest& operator=(const HandleBufferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleBufferRequest& operator=(HandleBufferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleBufferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleBufferRequest* internal_default_instance() {
    return reinterpret_cast<const HandleBufferRequest*>(
               &_HandleBufferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HandleBufferRequest& a, HandleBufferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleBufferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleBufferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleBufferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleBufferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleBufferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleBufferRequest& from) {
    HandleBufferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleBufferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.HandleBufferRequest";
  }
  protected:
  explicit HandleBufferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kBufferFieldNumber = 2,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional bytes buffer = 2;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_NODISCARD std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.HandleBufferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class HandleHandleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.HandleHandleRequest) */ {
 public:
  inline HandleHandleRequest() : HandleHandleRequest(nullptr) {}
  ~HandleHandleRequest() override;
  explicit PROTOBUF_CONSTEXPR HandleHandleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleHandleRequest(const HandleHandleRequest& from);
  HandleHandleRequest(HandleHandleRequest&& from) noexcept
    : HandleHandleRequest() {
    *this = ::std::move(from);
  }

  inline HandleHandleRequest& operator=(const HandleHandleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleHandleRequest& operator=(HandleHandleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleHandleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleHandleRequest* internal_default_instance() {
    return reinterpret_cast<const HandleHandleRequest*>(
               &_HandleHandleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HandleHandleRequest& a, HandleHandleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleHandleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleHandleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleHandleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleHandleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleHandleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleHandleRequest& from) {
    HandleHandleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleHandleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.HandleHandleRequest";
  }
  protected:
  explicit HandleHandleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kAnotherHandleFieldNumber = 2,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional string another_handle = 2;
  bool has_another_handle() const;
  private:
  bool _internal_has_another_handle() const;
  public:
  void clear_another_handle();
  const std::string& another_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_another_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_another_handle();
  PROTOBUF_NODISCARD std::string* release_another_handle();
  void set_allocated_another_handle(std::string* another_handle);
  private:
  const std::string& _internal_another_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_another_handle(const std::string& value);
  std::string* _internal_mutable_another_handle();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.HandleHandleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr another_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class HandleStringRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.HandleStringRequest) */ {
 public:
  inline HandleStringRequest() : HandleStringRequest(nullptr) {}
  ~HandleStringRequest() override;
  explicit PROTOBUF_CONSTEXPR HandleStringRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleStringRequest(const HandleStringRequest& from);
  HandleStringRequest(HandleStringRequest&& from) noexcept
    : HandleStringRequest() {
    *this = ::std::move(from);
  }

  inline HandleStringRequest& operator=(const HandleStringRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleStringRequest& operator=(HandleStringRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleStringRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleStringRequest* internal_default_instance() {
    return reinterpret_cast<const HandleStringRequest*>(
               &_HandleStringRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HandleStringRequest& a, HandleStringRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleStringRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleStringRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleStringRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleStringRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleStringRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleStringRequest& from) {
    HandleStringRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleStringRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.HandleStringRequest";
  }
  protected:
  explicit HandleStringRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kStrFieldNumber = 2,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional string str = 2;
  bool has_str() const;
  private:
  bool _internal_has_str() const;
  public:
  void clear_str();
  const std::string& str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str();
  PROTOBUF_NODISCARD std::string* release_str();
  void set_allocated_str(std::string* str);
  private:
  const std::string& _internal_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str(const std::string& value);
  std::string* _internal_mutable_str();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.HandleStringRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class HandleIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.HandleIdRequest) */ {
 public:
  inline HandleIdRequest() : HandleIdRequest(nullptr) {}
  ~HandleIdRequest() override;
  explicit PROTOBUF_CONSTEXPR HandleIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleIdRequest(const HandleIdRequest& from);
  HandleIdRequest(HandleIdRequest&& from) noexcept
    : HandleIdRequest() {
    *this = ::std::move(from);
  }

  inline HandleIdRequest& operator=(const HandleIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleIdRequest& operator=(HandleIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleIdRequest* internal_default_instance() {
    return reinterpret_cast<const HandleIdRequest*>(
               &_HandleIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HandleIdRequest& a, HandleIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleIdRequest& from) {
    HandleIdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.HandleIdRequest";
  }
  protected:
  explicit HandleIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional string id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.HandleIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class HandleIIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.HandleIIdRequest) */ {
 public:
  inline HandleIIdRequest() : HandleIIdRequest(nullptr) {}
  ~HandleIIdRequest() override;
  explicit PROTOBUF_CONSTEXPR HandleIIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleIIdRequest(const HandleIIdRequest& from);
  HandleIIdRequest(HandleIIdRequest&& from) noexcept
    : HandleIIdRequest() {
    *this = ::std::move(from);
  }

  inline HandleIIdRequest& operator=(const HandleIIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleIIdRequest& operator=(HandleIIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleIIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleIIdRequest* internal_default_instance() {
    return reinterpret_cast<const HandleIIdRequest*>(
               &_HandleIIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(HandleIIdRequest& a, HandleIIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleIIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleIIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleIIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleIIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleIIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleIIdRequest& from) {
    HandleIIdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleIIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.HandleIIdRequest";
  }
  protected:
  explicit HandleIIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional uint64 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.HandleIIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    uint64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class KeyValueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.KeyValueRequest) */ {
 public:
  inline KeyValueRequest() : KeyValueRequest(nullptr) {}
  ~KeyValueRequest() override;
  explicit PROTOBUF_CONSTEXPR KeyValueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyValueRequest(const KeyValueRequest& from);
  KeyValueRequest(KeyValueRequest&& from) noexcept
    : KeyValueRequest() {
    *this = ::std::move(from);
  }

  inline KeyValueRequest& operator=(const KeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyValueRequest& operator=(KeyValueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyValueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const KeyValueRequest*>(
               &_KeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(KeyValueRequest& a, KeyValueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyValueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyValueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyValueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyValueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyValueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyValueRequest& from) {
    KeyValueRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.KeyValueRequest";
  }
  protected:
  explicit KeyValueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.KeyValueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class EmptyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.EmptyResponse) */ {
 public:
  inline EmptyResponse() : EmptyResponse(nullptr) {}
  ~EmptyResponse() override;
  explicit PROTOBUF_CONSTEXPR EmptyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyResponse(const EmptyResponse& from);
  EmptyResponse(EmptyResponse&& from) noexcept
    : EmptyResponse() {
    *this = ::std::move(from);
  }

  inline EmptyResponse& operator=(const EmptyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyResponse& operator=(EmptyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyResponse* internal_default_instance() {
    return reinterpret_cast<const EmptyResponse*>(
               &_EmptyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(EmptyResponse& a, EmptyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmptyResponse& from) {
    EmptyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.EmptyResponse";
  }
  protected:
  explicit EmptyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVoidFieldNumber = 1,
  };
  // optional bool void = 1;
  bool has_void_() const;
  private:
  bool _internal_has_void_() const;
  public:
  void clear_void_();
  bool void_() const;
  void set_void_(bool value);
  private:
  bool _internal_void_() const;
  void _internal_set_void_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.EmptyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool void__;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class IdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.IdResponse) */ {
 public:
  inline IdResponse() : IdResponse(nullptr) {}
  ~IdResponse() override;
  explicit PROTOBUF_CONSTEXPR IdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IdResponse(const IdResponse& from);
  IdResponse(IdResponse&& from) noexcept
    : IdResponse() {
    *this = ::std::move(from);
  }

  inline IdResponse& operator=(const IdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdResponse& operator=(IdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdResponse* internal_default_instance() {
    return reinterpret_cast<const IdResponse*>(
               &_IdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(IdResponse& a, IdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IdResponse& from) {
    IdResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.IdResponse";
  }
  protected:
  explicit IdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.IdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class IIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.IIdResponse) */ {
 public:
  inline IIdResponse() : IIdResponse(nullptr) {}
  ~IIdResponse() override;
  explicit PROTOBUF_CONSTEXPR IIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IIdResponse(const IIdResponse& from);
  IIdResponse(IIdResponse&& from) noexcept
    : IIdResponse() {
    *this = ::std::move(from);
  }

  inline IIdResponse& operator=(const IIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IIdResponse& operator=(IIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IIdResponse* internal_default_instance() {
    return reinterpret_cast<const IIdResponse*>(
               &_IIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(IIdResponse& a, IIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IIdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IIdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IIdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IIdResponse& from) {
    IIdResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IIdResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.IIdResponse";
  }
  protected:
  explicit IIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.IIdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class SizeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SizeResponse) */ {
 public:
  inline SizeResponse() : SizeResponse(nullptr) {}
  ~SizeResponse() override;
  explicit PROTOBUF_CONSTEXPR SizeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SizeResponse(const SizeResponse& from);
  SizeResponse(SizeResponse&& from) noexcept
    : SizeResponse() {
    *this = ::std::move(from);
  }

  inline SizeResponse& operator=(const SizeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SizeResponse& operator=(SizeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SizeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SizeResponse* internal_default_instance() {
    return reinterpret_cast<const SizeResponse*>(
               &_SizeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SizeResponse& a, SizeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SizeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SizeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SizeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SizeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SizeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SizeResponse& from) {
    SizeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SizeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SizeResponse";
  }
  protected:
  explicit SizeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
  };
  // optional uint64 size = 1;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.SizeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class BoolResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.BoolResponse) */ {
 public:
  inline BoolResponse() : BoolResponse(nullptr) {}
  ~BoolResponse() override;
  explicit PROTOBUF_CONSTEXPR BoolResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolResponse(const BoolResponse& from);
  BoolResponse(BoolResponse&& from) noexcept
    : BoolResponse() {
    *this = ::std::move(from);
  }

  inline BoolResponse& operator=(const BoolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolResponse& operator=(BoolResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolResponse* internal_default_instance() {
    return reinterpret_cast<const BoolResponse*>(
               &_BoolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(BoolResponse& a, BoolResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoolResponse& from) {
    BoolResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.BoolResponse";
  }
  protected:
  explicit BoolResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBoolFieldNumber = 1,
  };
  // optional bool bool = 1;
  bool has_bool_() const;
  private:
  bool _internal_has_bool_() const;
  public:
  void clear_bool_();
  bool bool_() const;
  void set_bool_(bool value);
  private:
  bool _internal_bool_() const;
  void _internal_set_bool_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.BoolResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool bool__;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class StringResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.StringResponse) */ {
 public:
  inline StringResponse() : StringResponse(nullptr) {}
  ~StringResponse() override;
  explicit PROTOBUF_CONSTEXPR StringResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringResponse(const StringResponse& from);
  StringResponse(StringResponse&& from) noexcept
    : StringResponse() {
    *this = ::std::move(from);
  }

  inline StringResponse& operator=(const StringResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringResponse& operator=(StringResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringResponse* internal_default_instance() {
    return reinterpret_cast<const StringResponse*>(
               &_StringResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StringResponse& a, StringResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StringResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringResponse& from) {
    StringResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.StringResponse";
  }
  protected:
  explicit StringResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrFieldNumber = 1,
  };
  // optional string str = 1;
  bool has_str() const;
  private:
  bool _internal_has_str() const;
  public:
  void clear_str();
  const std::string& str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str();
  PROTOBUF_NODISCARD std::string* release_str();
  void set_allocated_str(std::string* str);
  private:
  const std::string& _internal_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str(const std::string& value);
  std::string* _internal_mutable_str();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.StringResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class HandleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.HandleResponse) */ {
 public:
  inline HandleResponse() : HandleResponse(nullptr) {}
  ~HandleResponse() override;
  explicit PROTOBUF_CONSTEXPR HandleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleResponse(const HandleResponse& from);
  HandleResponse(HandleResponse&& from) noexcept
    : HandleResponse() {
    *this = ::std::move(from);
  }

  inline HandleResponse& operator=(const HandleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleResponse& operator=(HandleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleResponse* internal_default_instance() {
    return reinterpret_cast<const HandleResponse*>(
               &_HandleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(HandleResponse& a, HandleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleResponse& from) {
    HandleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.HandleResponse";
  }
  protected:
  explicit HandleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.HandleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class BufferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.BufferResponse) */ {
 public:
  inline BufferResponse() : BufferResponse(nullptr) {}
  ~BufferResponse() override;
  explicit PROTOBUF_CONSTEXPR BufferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BufferResponse(const BufferResponse& from);
  BufferResponse(BufferResponse&& from) noexcept
    : BufferResponse() {
    *this = ::std::move(from);
  }

  inline BufferResponse& operator=(const BufferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BufferResponse& operator=(BufferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BufferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BufferResponse* internal_default_instance() {
    return reinterpret_cast<const BufferResponse*>(
               &_BufferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(BufferResponse& a, BufferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BufferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BufferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BufferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BufferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BufferResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BufferResponse& from) {
    BufferResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.BufferResponse";
  }
  protected:
  explicit BufferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufFieldNumber = 1,
  };
  // optional bytes buf = 1;
  bool has_buf() const;
  private:
  bool _internal_has_buf() const;
  public:
  void clear_buf();
  const std::string& buf() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buf(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buf();
  PROTOBUF_NODISCARD std::string* release_buf();
  void set_allocated_buf(std::string* buf);
  private:
  const std::string& _internal_buf() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buf(const std::string& value);
  std::string* _internal_mutable_buf();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.BufferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buf_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  explicit PROTOBUF_CONSTEXPR StatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.StatusResponse";
  }
  protected:
  explicit StatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // optional int32 status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.StatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_types_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// optional int32 x = 1;
inline bool Point::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Point::has_x() const {
  return _internal_has_x();
}
inline void Point::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Point::_internal_x() const {
  return _impl_.x_;
}
inline int32_t Point::x() const {
  // @@protoc_insertion_point(field_get:maarpc.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Point::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:maarpc.Point.x)
}

// optional int32 y = 2;
inline bool Point::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Point::has_y() const {
  return _internal_has_y();
}
inline void Point::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Point::_internal_y() const {
  return _impl_.y_;
}
inline int32_t Point::y() const {
  // @@protoc_insertion_point(field_get:maarpc.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Point::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:maarpc.Point.y)
}

// -------------------------------------------------------------------

// Size

// optional int32 width = 1;
inline bool Size::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Size::has_width() const {
  return _internal_has_width();
}
inline void Size::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Size::_internal_width() const {
  return _impl_.width_;
}
inline int32_t Size::width() const {
  // @@protoc_insertion_point(field_get:maarpc.Size.width)
  return _internal_width();
}
inline void Size::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}
inline void Size::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:maarpc.Size.width)
}

// optional int32 height = 2;
inline bool Size::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Size::has_height() const {
  return _internal_has_height();
}
inline void Size::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Size::_internal_height() const {
  return _impl_.height_;
}
inline int32_t Size::height() const {
  // @@protoc_insertion_point(field_get:maarpc.Size.height)
  return _internal_height();
}
inline void Size::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}
inline void Size::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:maarpc.Size.height)
}

// -------------------------------------------------------------------

// Rect

// optional .maarpc.Point xy = 1;
inline bool Rect::_internal_has_xy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.xy_ != nullptr);
  return value;
}
inline bool Rect::has_xy() const {
  return _internal_has_xy();
}
inline void Rect::clear_xy() {
  if (_impl_.xy_ != nullptr) _impl_.xy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maarpc::Point& Rect::_internal_xy() const {
  const ::maarpc::Point* p = _impl_.xy_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::Point&>(
      ::maarpc::_Point_default_instance_);
}
inline const ::maarpc::Point& Rect::xy() const {
  // @@protoc_insertion_point(field_get:maarpc.Rect.xy)
  return _internal_xy();
}
inline void Rect::unsafe_arena_set_allocated_xy(
    ::maarpc::Point* xy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.xy_);
  }
  _impl_.xy_ = xy;
  if (xy) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.Rect.xy)
}
inline ::maarpc::Point* Rect::release_xy() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maarpc::Point* temp = _impl_.xy_;
  _impl_.xy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::Point* Rect::unsafe_arena_release_xy() {
  // @@protoc_insertion_point(field_release:maarpc.Rect.xy)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maarpc::Point* temp = _impl_.xy_;
  _impl_.xy_ = nullptr;
  return temp;
}
inline ::maarpc::Point* Rect::_internal_mutable_xy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.xy_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::Point>(GetArenaForAllocation());
    _impl_.xy_ = p;
  }
  return _impl_.xy_;
}
inline ::maarpc::Point* Rect::mutable_xy() {
  ::maarpc::Point* _msg = _internal_mutable_xy();
  // @@protoc_insertion_point(field_mutable:maarpc.Rect.xy)
  return _msg;
}
inline void Rect::set_allocated_xy(::maarpc::Point* xy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.xy_;
  }
  if (xy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(xy);
    if (message_arena != submessage_arena) {
      xy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xy, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.xy_ = xy;
  // @@protoc_insertion_point(field_set_allocated:maarpc.Rect.xy)
}

// optional .maarpc.Size wh = 2;
inline bool Rect::_internal_has_wh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wh_ != nullptr);
  return value;
}
inline bool Rect::has_wh() const {
  return _internal_has_wh();
}
inline void Rect::clear_wh() {
  if (_impl_.wh_ != nullptr) _impl_.wh_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maarpc::Size& Rect::_internal_wh() const {
  const ::maarpc::Size* p = _impl_.wh_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::Size&>(
      ::maarpc::_Size_default_instance_);
}
inline const ::maarpc::Size& Rect::wh() const {
  // @@protoc_insertion_point(field_get:maarpc.Rect.wh)
  return _internal_wh();
}
inline void Rect::unsafe_arena_set_allocated_wh(
    ::maarpc::Size* wh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wh_);
  }
  _impl_.wh_ = wh;
  if (wh) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.Rect.wh)
}
inline ::maarpc::Size* Rect::release_wh() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::Size* temp = _impl_.wh_;
  _impl_.wh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::Size* Rect::unsafe_arena_release_wh() {
  // @@protoc_insertion_point(field_release:maarpc.Rect.wh)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::Size* temp = _impl_.wh_;
  _impl_.wh_ = nullptr;
  return temp;
}
inline ::maarpc::Size* Rect::_internal_mutable_wh() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.wh_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::Size>(GetArenaForAllocation());
    _impl_.wh_ = p;
  }
  return _impl_.wh_;
}
inline ::maarpc::Size* Rect::mutable_wh() {
  ::maarpc::Size* _msg = _internal_mutable_wh();
  // @@protoc_insertion_point(field_mutable:maarpc.Rect.wh)
  return _msg;
}
inline void Rect::set_allocated_wh(::maarpc::Size* wh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wh_;
  }
  if (wh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wh);
    if (message_arena != submessage_arena) {
      wh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wh, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.wh_ = wh;
  // @@protoc_insertion_point(field_set_allocated:maarpc.Rect.wh)
}

// -------------------------------------------------------------------

// Callback

// optional string msg = 1;
inline bool Callback::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Callback::has_msg() const {
  return _internal_has_msg();
}
inline void Callback::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Callback::msg() const {
  // @@protoc_insertion_point(field_get:maarpc.Callback.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Callback::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.Callback.msg)
}
inline std::string* Callback::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:maarpc.Callback.msg)
  return _s;
}
inline const std::string& Callback::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void Callback::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Callback::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Callback::release_msg() {
  // @@protoc_insertion_point(field_release:maarpc.Callback.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Callback::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.Callback.msg)
}

// optional string detail = 2;
inline bool Callback::_internal_has_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Callback::has_detail() const {
  return _internal_has_detail();
}
inline void Callback::clear_detail() {
  _impl_.detail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Callback::detail() const {
  // @@protoc_insertion_point(field_get:maarpc.Callback.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Callback::set_detail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.Callback.detail)
}
inline std::string* Callback::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:maarpc.Callback.detail)
  return _s;
}
inline const std::string& Callback::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void Callback::_internal_set_detail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* Callback::_internal_mutable_detail() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* Callback::release_detail() {
  // @@protoc_insertion_point(field_release:maarpc.Callback.detail)
  if (!_internal_has_detail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.detail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Callback::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.Callback.detail)
}

// -------------------------------------------------------------------

// ClickParam

// optional .maarpc.Point point = 1;
inline bool ClickParam::_internal_has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline bool ClickParam::has_point() const {
  return _internal_has_point();
}
inline void ClickParam::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maarpc::Point& ClickParam::_internal_point() const {
  const ::maarpc::Point* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::Point&>(
      ::maarpc::_Point_default_instance_);
}
inline const ::maarpc::Point& ClickParam::point() const {
  // @@protoc_insertion_point(field_get:maarpc.ClickParam.point)
  return _internal_point();
}
inline void ClickParam::unsafe_arena_set_allocated_point(
    ::maarpc::Point* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.ClickParam.point)
}
inline ::maarpc::Point* ClickParam::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maarpc::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::Point* ClickParam::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:maarpc.ClickParam.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maarpc::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::maarpc::Point* ClickParam::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::Point>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::maarpc::Point* ClickParam::mutable_point() {
  ::maarpc::Point* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:maarpc.ClickParam.point)
  return _msg;
}
inline void ClickParam::set_allocated_point(::maarpc::Point* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:maarpc.ClickParam.point)
}

// -------------------------------------------------------------------

// SwipeParam

// optional .maarpc.Point from = 1;
inline bool SwipeParam::_internal_has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_ != nullptr);
  return value;
}
inline bool SwipeParam::has_from() const {
  return _internal_has_from();
}
inline void SwipeParam::clear_from() {
  if (_impl_.from_ != nullptr) _impl_.from_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maarpc::Point& SwipeParam::_internal_from() const {
  const ::maarpc::Point* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::Point&>(
      ::maarpc::_Point_default_instance_);
}
inline const ::maarpc::Point& SwipeParam::from() const {
  // @@protoc_insertion_point(field_get:maarpc.SwipeParam.from)
  return _internal_from();
}
inline void SwipeParam::unsafe_arena_set_allocated_from(
    ::maarpc::Point* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = from;
  if (from) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.SwipeParam.from)
}
inline ::maarpc::Point* SwipeParam::release_from() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maarpc::Point* temp = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::Point* SwipeParam::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:maarpc.SwipeParam.from)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maarpc::Point* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::maarpc::Point* SwipeParam::_internal_mutable_from() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::Point>(GetArenaForAllocation());
    _impl_.from_ = p;
  }
  return _impl_.from_;
}
inline ::maarpc::Point* SwipeParam::mutable_from() {
  ::maarpc::Point* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:maarpc.SwipeParam.from)
  return _msg;
}
inline void SwipeParam::set_allocated_from(::maarpc::Point* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(from);
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.from_ = from;
  // @@protoc_insertion_point(field_set_allocated:maarpc.SwipeParam.from)
}

// optional .maarpc.Point to = 2;
inline bool SwipeParam::_internal_has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.to_ != nullptr);
  return value;
}
inline bool SwipeParam::has_to() const {
  return _internal_has_to();
}
inline void SwipeParam::clear_to() {
  if (_impl_.to_ != nullptr) _impl_.to_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maarpc::Point& SwipeParam::_internal_to() const {
  const ::maarpc::Point* p = _impl_.to_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::Point&>(
      ::maarpc::_Point_default_instance_);
}
inline const ::maarpc::Point& SwipeParam::to() const {
  // @@protoc_insertion_point(field_get:maarpc.SwipeParam.to)
  return _internal_to();
}
inline void SwipeParam::unsafe_arena_set_allocated_to(
    ::maarpc::Point* to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_);
  }
  _impl_.to_ = to;
  if (to) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.SwipeParam.to)
}
inline ::maarpc::Point* SwipeParam::release_to() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::Point* temp = _impl_.to_;
  _impl_.to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::Point* SwipeParam::unsafe_arena_release_to() {
  // @@protoc_insertion_point(field_release:maarpc.SwipeParam.to)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::Point* temp = _impl_.to_;
  _impl_.to_ = nullptr;
  return temp;
}
inline ::maarpc::Point* SwipeParam::_internal_mutable_to() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.to_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::Point>(GetArenaForAllocation());
    _impl_.to_ = p;
  }
  return _impl_.to_;
}
inline ::maarpc::Point* SwipeParam::mutable_to() {
  ::maarpc::Point* _msg = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:maarpc.SwipeParam.to)
  return _msg;
}
inline void SwipeParam::set_allocated_to(::maarpc::Point* to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.to_;
  }
  if (to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(to);
    if (message_arena != submessage_arena) {
      to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.to_ = to;
  // @@protoc_insertion_point(field_set_allocated:maarpc.SwipeParam.to)
}

// optional int32 duration = 3;
inline bool SwipeParam::_internal_has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SwipeParam::has_duration() const {
  return _internal_has_duration();
}
inline void SwipeParam::clear_duration() {
  _impl_.duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SwipeParam::_internal_duration() const {
  return _impl_.duration_;
}
inline int32_t SwipeParam::duration() const {
  // @@protoc_insertion_point(field_get:maarpc.SwipeParam.duration)
  return _internal_duration();
}
inline void SwipeParam::_internal_set_duration(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.duration_ = value;
}
inline void SwipeParam::set_duration(int32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:maarpc.SwipeParam.duration)
}

// -------------------------------------------------------------------

// KeyParam

// optional int32 key = 1;
inline bool KeyParam::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyParam::has_key() const {
  return _internal_has_key();
}
inline void KeyParam::clear_key() {
  _impl_.key_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t KeyParam::_internal_key() const {
  return _impl_.key_;
}
inline int32_t KeyParam::key() const {
  // @@protoc_insertion_point(field_get:maarpc.KeyParam.key)
  return _internal_key();
}
inline void KeyParam::_internal_set_key(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_ = value;
}
inline void KeyParam::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:maarpc.KeyParam.key)
}

// -------------------------------------------------------------------

// TouchParam

// optional int32 contact = 1;
inline bool TouchParam::_internal_has_contact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TouchParam::has_contact() const {
  return _internal_has_contact();
}
inline void TouchParam::clear_contact() {
  _impl_.contact_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TouchParam::_internal_contact() const {
  return _impl_.contact_;
}
inline int32_t TouchParam::contact() const {
  // @@protoc_insertion_point(field_get:maarpc.TouchParam.contact)
  return _internal_contact();
}
inline void TouchParam::_internal_set_contact(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.contact_ = value;
}
inline void TouchParam::set_contact(int32_t value) {
  _internal_set_contact(value);
  // @@protoc_insertion_point(field_set:maarpc.TouchParam.contact)
}

// optional .maarpc.Point pos = 2;
inline bool TouchParam::_internal_has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline bool TouchParam::has_pos() const {
  return _internal_has_pos();
}
inline void TouchParam::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maarpc::Point& TouchParam::_internal_pos() const {
  const ::maarpc::Point* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::Point&>(
      ::maarpc::_Point_default_instance_);
}
inline const ::maarpc::Point& TouchParam::pos() const {
  // @@protoc_insertion_point(field_get:maarpc.TouchParam.pos)
  return _internal_pos();
}
inline void TouchParam::unsafe_arena_set_allocated_pos(
    ::maarpc::Point* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.TouchParam.pos)
}
inline ::maarpc::Point* TouchParam::release_pos() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maarpc::Point* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::Point* TouchParam::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:maarpc.TouchParam.pos)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maarpc::Point* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::maarpc::Point* TouchParam::_internal_mutable_pos() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::Point>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::maarpc::Point* TouchParam::mutable_pos() {
  ::maarpc::Point* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:maarpc.TouchParam.pos)
  return _msg;
}
inline void TouchParam::set_allocated_pos(::maarpc::Point* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:maarpc.TouchParam.pos)
}

// optional int32 pressure = 3;
inline bool TouchParam::_internal_has_pressure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TouchParam::has_pressure() const {
  return _internal_has_pressure();
}
inline void TouchParam::clear_pressure() {
  _impl_.pressure_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TouchParam::_internal_pressure() const {
  return _impl_.pressure_;
}
inline int32_t TouchParam::pressure() const {
  // @@protoc_insertion_point(field_get:maarpc.TouchParam.pressure)
  return _internal_pressure();
}
inline void TouchParam::_internal_set_pressure(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pressure_ = value;
}
inline void TouchParam::set_pressure(int32_t value) {
  _internal_set_pressure(value);
  // @@protoc_insertion_point(field_set:maarpc.TouchParam.pressure)
}

// -------------------------------------------------------------------

// EmptyRequest

// optional bool unused = 1;
inline bool EmptyRequest::_internal_has_unused() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EmptyRequest::has_unused() const {
  return _internal_has_unused();
}
inline void EmptyRequest::clear_unused() {
  _impl_.unused_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool EmptyRequest::_internal_unused() const {
  return _impl_.unused_;
}
inline bool EmptyRequest::unused() const {
  // @@protoc_insertion_point(field_get:maarpc.EmptyRequest.unused)
  return _internal_unused();
}
inline void EmptyRequest::_internal_set_unused(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.unused_ = value;
}
inline void EmptyRequest::set_unused(bool value) {
  _internal_set_unused(value);
  // @@protoc_insertion_point(field_set:maarpc.EmptyRequest.unused)
}

// -------------------------------------------------------------------

// IdRequest

// optional string id = 1;
inline bool IdRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IdRequest::has_id() const {
  return _internal_has_id();
}
inline void IdRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IdRequest::id() const {
  // @@protoc_insertion_point(field_get:maarpc.IdRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IdRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.IdRequest.id)
}
inline std::string* IdRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:maarpc.IdRequest.id)
  return _s;
}
inline const std::string& IdRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void IdRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* IdRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* IdRequest::release_id() {
  // @@protoc_insertion_point(field_release:maarpc.IdRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IdRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.IdRequest.id)
}

// -------------------------------------------------------------------

// HandleRequest

// optional string handle = 1;
inline bool HandleRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandleRequest::has_handle() const {
  return _internal_has_handle();
}
inline void HandleRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandleRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleRequest.handle)
}
inline std::string* HandleRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleRequest.handle)
  return _s;
}
inline const std::string& HandleRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void HandleRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.HandleRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleRequest.handle)
}

// -------------------------------------------------------------------

// BufferRequest

// optional bytes buffer = 1;
inline bool BufferRequest::_internal_has_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BufferRequest::has_buffer() const {
  return _internal_has_buffer();
}
inline void BufferRequest::clear_buffer() {
  _impl_.buffer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BufferRequest::buffer() const {
  // @@protoc_insertion_point(field_get:maarpc.BufferRequest.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BufferRequest::set_buffer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.buffer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.BufferRequest.buffer)
}
inline std::string* BufferRequest::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:maarpc.BufferRequest.buffer)
  return _s;
}
inline const std::string& BufferRequest::_internal_buffer() const {
  return _impl_.buffer_.Get();
}
inline void BufferRequest::_internal_set_buffer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buffer_.Set(value, GetArenaForAllocation());
}
inline std::string* BufferRequest::_internal_mutable_buffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.buffer_.Mutable(GetArenaForAllocation());
}
inline std::string* BufferRequest::release_buffer() {
  // @@protoc_insertion_point(field_release:maarpc.BufferRequest.buffer)
  if (!_internal_has_buffer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.buffer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buffer_.IsDefault()) {
    _impl_.buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BufferRequest::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buffer_.SetAllocated(buffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buffer_.IsDefault()) {
    _impl_.buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.BufferRequest.buffer)
}

// -------------------------------------------------------------------

// StringRequest

// optional string str = 1;
inline bool StringRequest::_internal_has_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StringRequest::has_str() const {
  return _internal_has_str();
}
inline void StringRequest::clear_str() {
  _impl_.str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringRequest::str() const {
  // @@protoc_insertion_point(field_get:maarpc.StringRequest.str)
  return _internal_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringRequest::set_str(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.str_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.StringRequest.str)
}
inline std::string* StringRequest::mutable_str() {
  std::string* _s = _internal_mutable_str();
  // @@protoc_insertion_point(field_mutable:maarpc.StringRequest.str)
  return _s;
}
inline const std::string& StringRequest::_internal_str() const {
  return _impl_.str_.Get();
}
inline void StringRequest::_internal_set_str(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.str_.Set(value, GetArenaForAllocation());
}
inline std::string* StringRequest::_internal_mutable_str() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.str_.Mutable(GetArenaForAllocation());
}
inline std::string* StringRequest::release_str() {
  // @@protoc_insertion_point(field_release:maarpc.StringRequest.str)
  if (!_internal_has_str()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.str_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StringRequest::set_allocated_str(std::string* str) {
  if (str != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.str_.SetAllocated(str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.StringRequest.str)
}

// -------------------------------------------------------------------

// HandleBufferRequest

// optional string handle = 1;
inline bool HandleBufferRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandleBufferRequest::has_handle() const {
  return _internal_has_handle();
}
inline void HandleBufferRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandleBufferRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleBufferRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleBufferRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleBufferRequest.handle)
}
inline std::string* HandleBufferRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleBufferRequest.handle)
  return _s;
}
inline const std::string& HandleBufferRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void HandleBufferRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleBufferRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleBufferRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.HandleBufferRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleBufferRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleBufferRequest.handle)
}

// optional bytes buffer = 2;
inline bool HandleBufferRequest::_internal_has_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HandleBufferRequest::has_buffer() const {
  return _internal_has_buffer();
}
inline void HandleBufferRequest::clear_buffer() {
  _impl_.buffer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HandleBufferRequest::buffer() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleBufferRequest.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleBufferRequest::set_buffer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.buffer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleBufferRequest.buffer)
}
inline std::string* HandleBufferRequest::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleBufferRequest.buffer)
  return _s;
}
inline const std::string& HandleBufferRequest::_internal_buffer() const {
  return _impl_.buffer_.Get();
}
inline void HandleBufferRequest::_internal_set_buffer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.buffer_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleBufferRequest::_internal_mutable_buffer() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.buffer_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleBufferRequest::release_buffer() {
  // @@protoc_insertion_point(field_release:maarpc.HandleBufferRequest.buffer)
  if (!_internal_has_buffer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.buffer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buffer_.IsDefault()) {
    _impl_.buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleBufferRequest::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.buffer_.SetAllocated(buffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buffer_.IsDefault()) {
    _impl_.buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleBufferRequest.buffer)
}

// -------------------------------------------------------------------

// HandleHandleRequest

// optional string handle = 1;
inline bool HandleHandleRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandleHandleRequest::has_handle() const {
  return _internal_has_handle();
}
inline void HandleHandleRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandleHandleRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleHandleRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleHandleRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleHandleRequest.handle)
}
inline std::string* HandleHandleRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleHandleRequest.handle)
  return _s;
}
inline const std::string& HandleHandleRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void HandleHandleRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleHandleRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleHandleRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.HandleHandleRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleHandleRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleHandleRequest.handle)
}

// optional string another_handle = 2;
inline bool HandleHandleRequest::_internal_has_another_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HandleHandleRequest::has_another_handle() const {
  return _internal_has_another_handle();
}
inline void HandleHandleRequest::clear_another_handle() {
  _impl_.another_handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HandleHandleRequest::another_handle() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleHandleRequest.another_handle)
  return _internal_another_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleHandleRequest::set_another_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.another_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleHandleRequest.another_handle)
}
inline std::string* HandleHandleRequest::mutable_another_handle() {
  std::string* _s = _internal_mutable_another_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleHandleRequest.another_handle)
  return _s;
}
inline const std::string& HandleHandleRequest::_internal_another_handle() const {
  return _impl_.another_handle_.Get();
}
inline void HandleHandleRequest::_internal_set_another_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.another_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleHandleRequest::_internal_mutable_another_handle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.another_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleHandleRequest::release_another_handle() {
  // @@protoc_insertion_point(field_release:maarpc.HandleHandleRequest.another_handle)
  if (!_internal_has_another_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.another_handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.another_handle_.IsDefault()) {
    _impl_.another_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleHandleRequest::set_allocated_another_handle(std::string* another_handle) {
  if (another_handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.another_handle_.SetAllocated(another_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.another_handle_.IsDefault()) {
    _impl_.another_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleHandleRequest.another_handle)
}

// -------------------------------------------------------------------

// HandleStringRequest

// optional string handle = 1;
inline bool HandleStringRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandleStringRequest::has_handle() const {
  return _internal_has_handle();
}
inline void HandleStringRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandleStringRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleStringRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleStringRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleStringRequest.handle)
}
inline std::string* HandleStringRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleStringRequest.handle)
  return _s;
}
inline const std::string& HandleStringRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void HandleStringRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleStringRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleStringRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.HandleStringRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleStringRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleStringRequest.handle)
}

// optional string str = 2;
inline bool HandleStringRequest::_internal_has_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HandleStringRequest::has_str() const {
  return _internal_has_str();
}
inline void HandleStringRequest::clear_str() {
  _impl_.str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HandleStringRequest::str() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleStringRequest.str)
  return _internal_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleStringRequest::set_str(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.str_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleStringRequest.str)
}
inline std::string* HandleStringRequest::mutable_str() {
  std::string* _s = _internal_mutable_str();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleStringRequest.str)
  return _s;
}
inline const std::string& HandleStringRequest::_internal_str() const {
  return _impl_.str_.Get();
}
inline void HandleStringRequest::_internal_set_str(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.str_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleStringRequest::_internal_mutable_str() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.str_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleStringRequest::release_str() {
  // @@protoc_insertion_point(field_release:maarpc.HandleStringRequest.str)
  if (!_internal_has_str()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.str_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleStringRequest::set_allocated_str(std::string* str) {
  if (str != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.str_.SetAllocated(str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleStringRequest.str)
}

// -------------------------------------------------------------------

// HandleIdRequest

// optional string handle = 1;
inline bool HandleIdRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandleIdRequest::has_handle() const {
  return _internal_has_handle();
}
inline void HandleIdRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandleIdRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleIdRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleIdRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleIdRequest.handle)
}
inline std::string* HandleIdRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleIdRequest.handle)
  return _s;
}
inline const std::string& HandleIdRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void HandleIdRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleIdRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleIdRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.HandleIdRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleIdRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleIdRequest.handle)
}

// optional string id = 2;
inline bool HandleIdRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HandleIdRequest::has_id() const {
  return _internal_has_id();
}
inline void HandleIdRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HandleIdRequest::id() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleIdRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleIdRequest::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleIdRequest.id)
}
inline std::string* HandleIdRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleIdRequest.id)
  return _s;
}
inline const std::string& HandleIdRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void HandleIdRequest::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleIdRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleIdRequest::release_id() {
  // @@protoc_insertion_point(field_release:maarpc.HandleIdRequest.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleIdRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleIdRequest.id)
}

// -------------------------------------------------------------------

// HandleIIdRequest

// optional string handle = 1;
inline bool HandleIIdRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandleIIdRequest::has_handle() const {
  return _internal_has_handle();
}
inline void HandleIIdRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandleIIdRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleIIdRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleIIdRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleIIdRequest.handle)
}
inline std::string* HandleIIdRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleIIdRequest.handle)
  return _s;
}
inline const std::string& HandleIIdRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void HandleIIdRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleIIdRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleIIdRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.HandleIIdRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleIIdRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleIIdRequest.handle)
}

// optional uint64 id = 2;
inline bool HandleIIdRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HandleIIdRequest::has_id() const {
  return _internal_has_id();
}
inline void HandleIIdRequest::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t HandleIIdRequest::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t HandleIIdRequest::id() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleIIdRequest.id)
  return _internal_id();
}
inline void HandleIIdRequest::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.id_ = value;
}
inline void HandleIIdRequest::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:maarpc.HandleIIdRequest.id)
}

// -------------------------------------------------------------------

// KeyValueRequest

// optional string key = 1;
inline bool KeyValueRequest::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyValueRequest::has_key() const {
  return _internal_has_key();
}
inline void KeyValueRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyValueRequest::key() const {
  // @@protoc_insertion_point(field_get:maarpc.KeyValueRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValueRequest::set_key(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.KeyValueRequest.key)
}
inline std::string* KeyValueRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:maarpc.KeyValueRequest.key)
  return _s;
}
inline const std::string& KeyValueRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void KeyValueRequest::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValueRequest::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValueRequest::release_key() {
  // @@protoc_insertion_point(field_release:maarpc.KeyValueRequest.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KeyValueRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.KeyValueRequest.key)
}

// optional string value = 2;
inline bool KeyValueRequest::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeyValueRequest::has_value() const {
  return _internal_has_value();
}
inline void KeyValueRequest::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& KeyValueRequest::value() const {
  // @@protoc_insertion_point(field_get:maarpc.KeyValueRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyValueRequest::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.KeyValueRequest.value)
}
inline std::string* KeyValueRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:maarpc.KeyValueRequest.value)
  return _s;
}
inline const std::string& KeyValueRequest::_internal_value() const {
  return _impl_.value_.Get();
}
inline void KeyValueRequest::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyValueRequest::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyValueRequest::release_value() {
  // @@protoc_insertion_point(field_release:maarpc.KeyValueRequest.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void KeyValueRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.KeyValueRequest.value)
}

// -------------------------------------------------------------------

// EmptyResponse

// optional bool void = 1;
inline bool EmptyResponse::_internal_has_void_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EmptyResponse::has_void_() const {
  return _internal_has_void_();
}
inline void EmptyResponse::clear_void_() {
  _impl_.void__ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool EmptyResponse::_internal_void_() const {
  return _impl_.void__;
}
inline bool EmptyResponse::void_() const {
  // @@protoc_insertion_point(field_get:maarpc.EmptyResponse.void)
  return _internal_void_();
}
inline void EmptyResponse::_internal_set_void_(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.void__ = value;
}
inline void EmptyResponse::set_void_(bool value) {
  _internal_set_void_(value);
  // @@protoc_insertion_point(field_set:maarpc.EmptyResponse.void)
}

// -------------------------------------------------------------------

// IdResponse

// optional string id = 1;
inline bool IdResponse::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IdResponse::has_id() const {
  return _internal_has_id();
}
inline void IdResponse::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IdResponse::id() const {
  // @@protoc_insertion_point(field_get:maarpc.IdResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IdResponse::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.IdResponse.id)
}
inline std::string* IdResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:maarpc.IdResponse.id)
  return _s;
}
inline const std::string& IdResponse::_internal_id() const {
  return _impl_.id_.Get();
}
inline void IdResponse::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* IdResponse::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* IdResponse::release_id() {
  // @@protoc_insertion_point(field_release:maarpc.IdResponse.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void IdResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.IdResponse.id)
}

// -------------------------------------------------------------------

// IIdResponse

// optional uint64 id = 1;
inline bool IIdResponse::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IIdResponse::has_id() const {
  return _internal_has_id();
}
inline void IIdResponse::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t IIdResponse::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t IIdResponse::id() const {
  // @@protoc_insertion_point(field_get:maarpc.IIdResponse.id)
  return _internal_id();
}
inline void IIdResponse::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void IIdResponse::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:maarpc.IIdResponse.id)
}

// -------------------------------------------------------------------

// SizeResponse

// optional uint64 size = 1;
inline bool SizeResponse::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SizeResponse::has_size() const {
  return _internal_has_size();
}
inline void SizeResponse::clear_size() {
  _impl_.size_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SizeResponse::_internal_size() const {
  return _impl_.size_;
}
inline uint64_t SizeResponse::size() const {
  // @@protoc_insertion_point(field_get:maarpc.SizeResponse.size)
  return _internal_size();
}
inline void SizeResponse::_internal_set_size(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.size_ = value;
}
inline void SizeResponse::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:maarpc.SizeResponse.size)
}

// -------------------------------------------------------------------

// BoolResponse

// optional bool bool = 1;
inline bool BoolResponse::_internal_has_bool_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BoolResponse::has_bool_() const {
  return _internal_has_bool_();
}
inline void BoolResponse::clear_bool_() {
  _impl_.bool__ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BoolResponse::_internal_bool_() const {
  return _impl_.bool__;
}
inline bool BoolResponse::bool_() const {
  // @@protoc_insertion_point(field_get:maarpc.BoolResponse.bool)
  return _internal_bool_();
}
inline void BoolResponse::_internal_set_bool_(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bool__ = value;
}
inline void BoolResponse::set_bool_(bool value) {
  _internal_set_bool_(value);
  // @@protoc_insertion_point(field_set:maarpc.BoolResponse.bool)
}

// -------------------------------------------------------------------

// StringResponse

// optional string str = 1;
inline bool StringResponse::_internal_has_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StringResponse::has_str() const {
  return _internal_has_str();
}
inline void StringResponse::clear_str() {
  _impl_.str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringResponse::str() const {
  // @@protoc_insertion_point(field_get:maarpc.StringResponse.str)
  return _internal_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringResponse::set_str(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.str_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.StringResponse.str)
}
inline std::string* StringResponse::mutable_str() {
  std::string* _s = _internal_mutable_str();
  // @@protoc_insertion_point(field_mutable:maarpc.StringResponse.str)
  return _s;
}
inline const std::string& StringResponse::_internal_str() const {
  return _impl_.str_.Get();
}
inline void StringResponse::_internal_set_str(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.str_.Set(value, GetArenaForAllocation());
}
inline std::string* StringResponse::_internal_mutable_str() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.str_.Mutable(GetArenaForAllocation());
}
inline std::string* StringResponse::release_str() {
  // @@protoc_insertion_point(field_release:maarpc.StringResponse.str)
  if (!_internal_has_str()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.str_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StringResponse::set_allocated_str(std::string* str) {
  if (str != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.str_.SetAllocated(str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.StringResponse.str)
}

// -------------------------------------------------------------------

// HandleResponse

// optional string handle = 1;
inline bool HandleResponse::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandleResponse::has_handle() const {
  return _internal_has_handle();
}
inline void HandleResponse::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandleResponse::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.HandleResponse.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleResponse::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.HandleResponse.handle)
}
inline std::string* HandleResponse::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.HandleResponse.handle)
  return _s;
}
inline const std::string& HandleResponse::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void HandleResponse::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleResponse::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleResponse::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.HandleResponse.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleResponse::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.HandleResponse.handle)
}

// -------------------------------------------------------------------

// BufferResponse

// optional bytes buf = 1;
inline bool BufferResponse::_internal_has_buf() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BufferResponse::has_buf() const {
  return _internal_has_buf();
}
inline void BufferResponse::clear_buf() {
  _impl_.buf_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BufferResponse::buf() const {
  // @@protoc_insertion_point(field_get:maarpc.BufferResponse.buf)
  return _internal_buf();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BufferResponse::set_buf(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.buf_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.BufferResponse.buf)
}
inline std::string* BufferResponse::mutable_buf() {
  std::string* _s = _internal_mutable_buf();
  // @@protoc_insertion_point(field_mutable:maarpc.BufferResponse.buf)
  return _s;
}
inline const std::string& BufferResponse::_internal_buf() const {
  return _impl_.buf_.Get();
}
inline void BufferResponse::_internal_set_buf(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buf_.Set(value, GetArenaForAllocation());
}
inline std::string* BufferResponse::_internal_mutable_buf() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.buf_.Mutable(GetArenaForAllocation());
}
inline std::string* BufferResponse::release_buf() {
  // @@protoc_insertion_point(field_release:maarpc.BufferResponse.buf)
  if (!_internal_has_buf()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.buf_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buf_.IsDefault()) {
    _impl_.buf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BufferResponse::set_allocated_buf(std::string* buf) {
  if (buf != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buf_.SetAllocated(buf, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buf_.IsDefault()) {
    _impl_.buf_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.BufferResponse.buf)
}

// -------------------------------------------------------------------

// StatusResponse

// optional int32 status = 1;
inline bool StatusResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatusResponse::has_status() const {
  return _internal_has_status();
}
inline void StatusResponse::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t StatusResponse::_internal_status() const {
  return _impl_.status_;
}
inline int32_t StatusResponse::status() const {
  // @@protoc_insertion_point(field_get:maarpc.StatusResponse.status)
  return _internal_status();
}
inline void StatusResponse::_internal_set_status(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.status_ = value;
}
inline void StatusResponse::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:maarpc.StatusResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace maarpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_types_2eproto
