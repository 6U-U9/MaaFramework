// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Types_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Types_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Types_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Types_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Types_2eproto;
namespace maa {
class BoolResponse;
struct BoolResponseDefaultTypeInternal;
extern BoolResponseDefaultTypeInternal _BoolResponse_default_instance_;
class BufferRequest;
struct BufferRequestDefaultTypeInternal;
extern BufferRequestDefaultTypeInternal _BufferRequest_default_instance_;
class BufferResponse;
struct BufferResponseDefaultTypeInternal;
extern BufferResponseDefaultTypeInternal _BufferResponse_default_instance_;
class Callback;
struct CallbackDefaultTypeInternal;
extern CallbackDefaultTypeInternal _Callback_default_instance_;
class ClickParam;
struct ClickParamDefaultTypeInternal;
extern ClickParamDefaultTypeInternal _ClickParam_default_instance_;
class EmptyRequest;
struct EmptyRequestDefaultTypeInternal;
extern EmptyRequestDefaultTypeInternal _EmptyRequest_default_instance_;
class EmptyResponse;
struct EmptyResponseDefaultTypeInternal;
extern EmptyResponseDefaultTypeInternal _EmptyResponse_default_instance_;
class Handle;
struct HandleDefaultTypeInternal;
extern HandleDefaultTypeInternal _Handle_default_instance_;
class HandleBufferRequest;
struct HandleBufferRequestDefaultTypeInternal;
extern HandleBufferRequestDefaultTypeInternal _HandleBufferRequest_default_instance_;
class HandleIdRequest;
struct HandleIdRequestDefaultTypeInternal;
extern HandleIdRequestDefaultTypeInternal _HandleIdRequest_default_instance_;
class HandleRequest;
struct HandleRequestDefaultTypeInternal;
extern HandleRequestDefaultTypeInternal _HandleRequest_default_instance_;
class HandleResponse;
struct HandleResponseDefaultTypeInternal;
extern HandleResponseDefaultTypeInternal _HandleResponse_default_instance_;
class HandleStringRequest;
struct HandleStringRequestDefaultTypeInternal;
extern HandleStringRequestDefaultTypeInternal _HandleStringRequest_default_instance_;
class Id;
struct IdDefaultTypeInternal;
extern IdDefaultTypeInternal _Id_default_instance_;
class IdRequest;
struct IdRequestDefaultTypeInternal;
extern IdRequestDefaultTypeInternal _IdRequest_default_instance_;
class IdResponse;
struct IdResponseDefaultTypeInternal;
extern IdResponseDefaultTypeInternal _IdResponse_default_instance_;
class KeyParam;
struct KeyParamDefaultTypeInternal;
extern KeyParamDefaultTypeInternal _KeyParam_default_instance_;
class Point;
struct PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Rect;
struct RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class RpcStatus;
struct RpcStatusDefaultTypeInternal;
extern RpcStatusDefaultTypeInternal _RpcStatus_default_instance_;
class Size;
struct SizeDefaultTypeInternal;
extern SizeDefaultTypeInternal _Size_default_instance_;
class StatusResponse;
struct StatusResponseDefaultTypeInternal;
extern StatusResponseDefaultTypeInternal _StatusResponse_default_instance_;
class StringResponse;
struct StringResponseDefaultTypeInternal;
extern StringResponseDefaultTypeInternal _StringResponse_default_instance_;
class SwipeParam;
struct SwipeParamDefaultTypeInternal;
extern SwipeParamDefaultTypeInternal _SwipeParam_default_instance_;
class TouchParam;
struct TouchParamDefaultTypeInternal;
extern TouchParamDefaultTypeInternal _TouchParam_default_instance_;
}  // namespace maa
PROTOBUF_NAMESPACE_OPEN
template<> ::maa::BoolResponse* Arena::CreateMaybeMessage<::maa::BoolResponse>(Arena*);
template<> ::maa::BufferRequest* Arena::CreateMaybeMessage<::maa::BufferRequest>(Arena*);
template<> ::maa::BufferResponse* Arena::CreateMaybeMessage<::maa::BufferResponse>(Arena*);
template<> ::maa::Callback* Arena::CreateMaybeMessage<::maa::Callback>(Arena*);
template<> ::maa::ClickParam* Arena::CreateMaybeMessage<::maa::ClickParam>(Arena*);
template<> ::maa::EmptyRequest* Arena::CreateMaybeMessage<::maa::EmptyRequest>(Arena*);
template<> ::maa::EmptyResponse* Arena::CreateMaybeMessage<::maa::EmptyResponse>(Arena*);
template<> ::maa::Handle* Arena::CreateMaybeMessage<::maa::Handle>(Arena*);
template<> ::maa::HandleBufferRequest* Arena::CreateMaybeMessage<::maa::HandleBufferRequest>(Arena*);
template<> ::maa::HandleIdRequest* Arena::CreateMaybeMessage<::maa::HandleIdRequest>(Arena*);
template<> ::maa::HandleRequest* Arena::CreateMaybeMessage<::maa::HandleRequest>(Arena*);
template<> ::maa::HandleResponse* Arena::CreateMaybeMessage<::maa::HandleResponse>(Arena*);
template<> ::maa::HandleStringRequest* Arena::CreateMaybeMessage<::maa::HandleStringRequest>(Arena*);
template<> ::maa::Id* Arena::CreateMaybeMessage<::maa::Id>(Arena*);
template<> ::maa::IdRequest* Arena::CreateMaybeMessage<::maa::IdRequest>(Arena*);
template<> ::maa::IdResponse* Arena::CreateMaybeMessage<::maa::IdResponse>(Arena*);
template<> ::maa::KeyParam* Arena::CreateMaybeMessage<::maa::KeyParam>(Arena*);
template<> ::maa::Point* Arena::CreateMaybeMessage<::maa::Point>(Arena*);
template<> ::maa::Rect* Arena::CreateMaybeMessage<::maa::Rect>(Arena*);
template<> ::maa::RpcStatus* Arena::CreateMaybeMessage<::maa::RpcStatus>(Arena*);
template<> ::maa::Size* Arena::CreateMaybeMessage<::maa::Size>(Arena*);
template<> ::maa::StatusResponse* Arena::CreateMaybeMessage<::maa::StatusResponse>(Arena*);
template<> ::maa::StringResponse* Arena::CreateMaybeMessage<::maa::StringResponse>(Arena*);
template<> ::maa::SwipeParam* Arena::CreateMaybeMessage<::maa::SwipeParam>(Arena*);
template<> ::maa::TouchParam* Arena::CreateMaybeMessage<::maa::TouchParam>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace maa {

enum Status : int {
  invalid = 0,
  pending = 1000,
  running = 2000,
  success = 3000,
  failed = 4000,
  Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Status_IsValid(int value);
constexpr Status Status_MIN = invalid;
constexpr Status Status_MAX = failed;
constexpr int Status_ARRAYSIZE = Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Status_descriptor();
template<typename T>
inline const std::string& Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Status_descriptor(), enum_t_value);
}
inline bool Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
// ===================================================================

class RpcStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.RpcStatus) */ {
 public:
  inline RpcStatus() : RpcStatus(nullptr) {}
  ~RpcStatus() override;
  explicit PROTOBUF_CONSTEXPR RpcStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RpcStatus(const RpcStatus& from);
  RpcStatus(RpcStatus&& from) noexcept
    : RpcStatus() {
    *this = ::std::move(from);
  }

  inline RpcStatus& operator=(const RpcStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcStatus& operator=(RpcStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RpcStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const RpcStatus* internal_default_instance() {
    return reinterpret_cast<const RpcStatus*>(
               &_RpcStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RpcStatus& a, RpcStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RpcStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RpcStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RpcStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RpcStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RpcStatus& from) {
    RpcStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.RpcStatus";
  }
  protected:
  explicit RpcStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // optional bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:maa.RpcStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool success_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Id final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.Id) */ {
 public:
  inline Id() : Id(nullptr) {}
  ~Id() override;
  explicit PROTOBUF_CONSTEXPR Id(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Id(const Id& from);
  Id(Id&& from) noexcept
    : Id() {
    *this = ::std::move(from);
  }

  inline Id& operator=(const Id& from) {
    CopyFrom(from);
    return *this;
  }
  inline Id& operator=(Id&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Id& default_instance() {
    return *internal_default_instance();
  }
  static inline const Id* internal_default_instance() {
    return reinterpret_cast<const Id*>(
               &_Id_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Id& a, Id& b) {
    a.Swap(&b);
  }
  inline void Swap(Id* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Id* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Id* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Id>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Id& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Id& from) {
    Id::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Id* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.Id";
  }
  protected:
  explicit Id(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:maa.Id)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Handle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.Handle) */ {
 public:
  inline Handle() : Handle(nullptr) {}
  ~Handle() override;
  explicit PROTOBUF_CONSTEXPR Handle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Handle(const Handle& from);
  Handle(Handle&& from) noexcept
    : Handle() {
    *this = ::std::move(from);
  }

  inline Handle& operator=(const Handle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Handle& operator=(Handle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Handle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Handle* internal_default_instance() {
    return reinterpret_cast<const Handle*>(
               &_Handle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Handle& a, Handle& b) {
    a.Swap(&b);
  }
  inline void Swap(Handle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Handle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Handle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Handle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Handle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Handle& from) {
    Handle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Handle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.Handle";
  }
  protected:
  explicit Handle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // optional uint64 handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  uint64_t handle() const;
  void set_handle(uint64_t value);
  private:
  uint64_t _internal_handle() const;
  void _internal_set_handle(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:maa.Handle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Point final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.Point) */ {
 public:
  inline Point() : Point(nullptr) {}
  ~Point() override;
  explicit PROTOBUF_CONSTEXPR Point(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Point(const Point& from);
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  inline Point& operator=(Point&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Point& default_instance() {
    return *internal_default_instance();
  }
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }
  inline void Swap(Point* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Point* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Point* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Point& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Point& from) {
    Point::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.Point";
  }
  protected:
  explicit Point(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maa.Point)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t x_;
    int32_t y_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Size final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.Size) */ {
 public:
  inline Size() : Size(nullptr) {}
  ~Size() override;
  explicit PROTOBUF_CONSTEXPR Size(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Size(const Size& from);
  Size(Size&& from) noexcept
    : Size() {
    *this = ::std::move(from);
  }

  inline Size& operator=(const Size& from) {
    CopyFrom(from);
    return *this;
  }
  inline Size& operator=(Size&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Size& default_instance() {
    return *internal_default_instance();
  }
  static inline const Size* internal_default_instance() {
    return reinterpret_cast<const Size*>(
               &_Size_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Size& a, Size& b) {
    a.Swap(&b);
  }
  inline void Swap(Size* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Size* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Size* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Size>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Size& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Size& from) {
    Size::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Size* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.Size";
  }
  protected:
  explicit Size(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maa.Size)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t width_;
    int32_t height_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Rect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.Rect) */ {
 public:
  inline Rect() : Rect(nullptr) {}
  ~Rect() override;
  explicit PROTOBUF_CONSTEXPR Rect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rect(const Rect& from);
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rect& operator=(Rect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }
  inline void Swap(Rect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rect& from) {
    Rect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.Rect";
  }
  protected:
  explicit Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXyFieldNumber = 1,
    kWhFieldNumber = 2,
  };
  // optional .maa.Point xy = 1;
  bool has_xy() const;
  private:
  bool _internal_has_xy() const;
  public:
  void clear_xy();
  const ::maa::Point& xy() const;
  PROTOBUF_NODISCARD ::maa::Point* release_xy();
  ::maa::Point* mutable_xy();
  void set_allocated_xy(::maa::Point* xy);
  private:
  const ::maa::Point& _internal_xy() const;
  ::maa::Point* _internal_mutable_xy();
  public:
  void unsafe_arena_set_allocated_xy(
      ::maa::Point* xy);
  ::maa::Point* unsafe_arena_release_xy();

  // optional .maa.Size wh = 2;
  bool has_wh() const;
  private:
  bool _internal_has_wh() const;
  public:
  void clear_wh();
  const ::maa::Size& wh() const;
  PROTOBUF_NODISCARD ::maa::Size* release_wh();
  ::maa::Size* mutable_wh();
  void set_allocated_wh(::maa::Size* wh);
  private:
  const ::maa::Size& _internal_wh() const;
  ::maa::Size* _internal_mutable_wh();
  public:
  void unsafe_arena_set_allocated_wh(
      ::maa::Size* wh);
  ::maa::Size* unsafe_arena_release_wh();

  // @@protoc_insertion_point(class_scope:maa.Rect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::Point* xy_;
    ::maa::Size* wh_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Callback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.Callback) */ {
 public:
  inline Callback() : Callback(nullptr) {}
  ~Callback() override;
  explicit PROTOBUF_CONSTEXPR Callback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Callback(const Callback& from);
  Callback(Callback&& from) noexcept
    : Callback() {
    *this = ::std::move(from);
  }

  inline Callback& operator=(const Callback& from) {
    CopyFrom(from);
    return *this;
  }
  inline Callback& operator=(Callback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Callback& default_instance() {
    return *internal_default_instance();
  }
  static inline const Callback* internal_default_instance() {
    return reinterpret_cast<const Callback*>(
               &_Callback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Callback& a, Callback& b) {
    a.Swap(&b);
  }
  inline void Swap(Callback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Callback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Callback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Callback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Callback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Callback& from) {
    Callback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Callback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.Callback";
  }
  protected:
  explicit Callback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
    kDetailFieldNumber = 2,
  };
  // optional string msg = 1;
  bool has_msg() const;
  private:
  bool _internal_has_msg() const;
  public:
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // optional string detail = 2;
  bool has_detail() const;
  private:
  bool _internal_has_detail() const;
  public:
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // @@protoc_insertion_point(class_scope:maa.Callback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class ClickParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.ClickParam) */ {
 public:
  inline ClickParam() : ClickParam(nullptr) {}
  ~ClickParam() override;
  explicit PROTOBUF_CONSTEXPR ClickParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClickParam(const ClickParam& from);
  ClickParam(ClickParam&& from) noexcept
    : ClickParam() {
    *this = ::std::move(from);
  }

  inline ClickParam& operator=(const ClickParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClickParam& operator=(ClickParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClickParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClickParam* internal_default_instance() {
    return reinterpret_cast<const ClickParam*>(
               &_ClickParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClickParam& a, ClickParam& b) {
    a.Swap(&b);
  }
  inline void Swap(ClickParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClickParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClickParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClickParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClickParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClickParam& from) {
    ClickParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClickParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.ClickParam";
  }
  protected:
  explicit ClickParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 1,
  };
  // optional .maa.Point point = 1;
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::maa::Point& point() const;
  PROTOBUF_NODISCARD ::maa::Point* release_point();
  ::maa::Point* mutable_point();
  void set_allocated_point(::maa::Point* point);
  private:
  const ::maa::Point& _internal_point() const;
  ::maa::Point* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::maa::Point* point);
  ::maa::Point* unsafe_arena_release_point();

  // @@protoc_insertion_point(class_scope:maa.ClickParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::Point* point_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class SwipeParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.SwipeParam) */ {
 public:
  inline SwipeParam() : SwipeParam(nullptr) {}
  ~SwipeParam() override;
  explicit PROTOBUF_CONSTEXPR SwipeParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SwipeParam(const SwipeParam& from);
  SwipeParam(SwipeParam&& from) noexcept
    : SwipeParam() {
    *this = ::std::move(from);
  }

  inline SwipeParam& operator=(const SwipeParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwipeParam& operator=(SwipeParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SwipeParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const SwipeParam* internal_default_instance() {
    return reinterpret_cast<const SwipeParam*>(
               &_SwipeParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SwipeParam& a, SwipeParam& b) {
    a.Swap(&b);
  }
  inline void Swap(SwipeParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SwipeParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SwipeParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SwipeParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SwipeParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SwipeParam& from) {
    SwipeParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwipeParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.SwipeParam";
  }
  protected:
  explicit SwipeParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kDurationFieldNumber = 3,
  };
  // optional .maa.Point from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::maa::Point& from() const;
  PROTOBUF_NODISCARD ::maa::Point* release_from();
  ::maa::Point* mutable_from();
  void set_allocated_from(::maa::Point* from);
  private:
  const ::maa::Point& _internal_from() const;
  ::maa::Point* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::maa::Point* from);
  ::maa::Point* unsafe_arena_release_from();

  // optional .maa.Point to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const ::maa::Point& to() const;
  PROTOBUF_NODISCARD ::maa::Point* release_to();
  ::maa::Point* mutable_to();
  void set_allocated_to(::maa::Point* to);
  private:
  const ::maa::Point& _internal_to() const;
  ::maa::Point* _internal_mutable_to();
  public:
  void unsafe_arena_set_allocated_to(
      ::maa::Point* to);
  ::maa::Point* unsafe_arena_release_to();

  // optional int32 duration = 3;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  int32_t duration() const;
  void set_duration(int32_t value);
  private:
  int32_t _internal_duration() const;
  void _internal_set_duration(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maa.SwipeParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::Point* from_;
    ::maa::Point* to_;
    int32_t duration_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class KeyParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.KeyParam) */ {
 public:
  inline KeyParam() : KeyParam(nullptr) {}
  ~KeyParam() override;
  explicit PROTOBUF_CONSTEXPR KeyParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyParam(const KeyParam& from);
  KeyParam(KeyParam&& from) noexcept
    : KeyParam() {
    *this = ::std::move(from);
  }

  inline KeyParam& operator=(const KeyParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyParam& operator=(KeyParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyParam* internal_default_instance() {
    return reinterpret_cast<const KeyParam*>(
               &_KeyParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(KeyParam& a, KeyParam& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyParam& from) {
    KeyParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.KeyParam";
  }
  protected:
  explicit KeyParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // optional int32 key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maa.KeyParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class TouchParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.TouchParam) */ {
 public:
  inline TouchParam() : TouchParam(nullptr) {}
  ~TouchParam() override;
  explicit PROTOBUF_CONSTEXPR TouchParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TouchParam(const TouchParam& from);
  TouchParam(TouchParam&& from) noexcept
    : TouchParam() {
    *this = ::std::move(from);
  }

  inline TouchParam& operator=(const TouchParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline TouchParam& operator=(TouchParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TouchParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const TouchParam* internal_default_instance() {
    return reinterpret_cast<const TouchParam*>(
               &_TouchParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TouchParam& a, TouchParam& b) {
    a.Swap(&b);
  }
  inline void Swap(TouchParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TouchParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TouchParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TouchParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TouchParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TouchParam& from) {
    TouchParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TouchParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.TouchParam";
  }
  protected:
  explicit TouchParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 2,
    kContactFieldNumber = 1,
    kPressureFieldNumber = 3,
  };
  // optional .maa.Point pos = 2;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::maa::Point& pos() const;
  PROTOBUF_NODISCARD ::maa::Point* release_pos();
  ::maa::Point* mutable_pos();
  void set_allocated_pos(::maa::Point* pos);
  private:
  const ::maa::Point& _internal_pos() const;
  ::maa::Point* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::maa::Point* pos);
  ::maa::Point* unsafe_arena_release_pos();

  // optional int32 contact = 1;
  bool has_contact() const;
  private:
  bool _internal_has_contact() const;
  public:
  void clear_contact();
  int32_t contact() const;
  void set_contact(int32_t value);
  private:
  int32_t _internal_contact() const;
  void _internal_set_contact(int32_t value);
  public:

  // optional int32 pressure = 3;
  bool has_pressure() const;
  private:
  bool _internal_has_pressure() const;
  public:
  void clear_pressure();
  int32_t pressure() const;
  void set_pressure(int32_t value);
  private:
  int32_t _internal_pressure() const;
  void _internal_set_pressure(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maa.TouchParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::Point* pos_;
    int32_t contact_;
    int32_t pressure_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class EmptyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:maa.EmptyRequest) */ {
 public:
  inline EmptyRequest() : EmptyRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR EmptyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyRequest(const EmptyRequest& from);
  EmptyRequest(EmptyRequest&& from) noexcept
    : EmptyRequest() {
    *this = ::std::move(from);
  }

  inline EmptyRequest& operator=(const EmptyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyRequest& operator=(EmptyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyRequest*>(
               &_EmptyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EmptyRequest& a, EmptyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.EmptyRequest";
  }
  protected:
  explicit EmptyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:maa.EmptyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class IdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.IdRequest) */ {
 public:
  inline IdRequest() : IdRequest(nullptr) {}
  ~IdRequest() override;
  explicit PROTOBUF_CONSTEXPR IdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IdRequest(const IdRequest& from);
  IdRequest(IdRequest&& from) noexcept
    : IdRequest() {
    *this = ::std::move(from);
  }

  inline IdRequest& operator=(const IdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdRequest& operator=(IdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdRequest* internal_default_instance() {
    return reinterpret_cast<const IdRequest*>(
               &_IdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(IdRequest& a, IdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IdRequest& from) {
    IdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.IdRequest";
  }
  protected:
  explicit IdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional .maa.Id id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::maa::Id& id() const;
  PROTOBUF_NODISCARD ::maa::Id* release_id();
  ::maa::Id* mutable_id();
  void set_allocated_id(::maa::Id* id);
  private:
  const ::maa::Id& _internal_id() const;
  ::maa::Id* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::maa::Id* id);
  ::maa::Id* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:maa.IdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::Id* id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class HandleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.HandleRequest) */ {
 public:
  inline HandleRequest() : HandleRequest(nullptr) {}
  ~HandleRequest() override;
  explicit PROTOBUF_CONSTEXPR HandleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleRequest(const HandleRequest& from);
  HandleRequest(HandleRequest&& from) noexcept
    : HandleRequest() {
    *this = ::std::move(from);
  }

  inline HandleRequest& operator=(const HandleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleRequest& operator=(HandleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleRequest* internal_default_instance() {
    return reinterpret_cast<const HandleRequest*>(
               &_HandleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HandleRequest& a, HandleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleRequest& from) {
    HandleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.HandleRequest";
  }
  protected:
  explicit HandleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // optional .maa.Handle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::maa::Handle& handle() const;
  PROTOBUF_NODISCARD ::maa::Handle* release_handle();
  ::maa::Handle* mutable_handle();
  void set_allocated_handle(::maa::Handle* handle);
  private:
  const ::maa::Handle& _internal_handle() const;
  ::maa::Handle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::maa::Handle* handle);
  ::maa::Handle* unsafe_arena_release_handle();

  // @@protoc_insertion_point(class_scope:maa.HandleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::Handle* handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class BufferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.BufferRequest) */ {
 public:
  inline BufferRequest() : BufferRequest(nullptr) {}
  ~BufferRequest() override;
  explicit PROTOBUF_CONSTEXPR BufferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BufferRequest(const BufferRequest& from);
  BufferRequest(BufferRequest&& from) noexcept
    : BufferRequest() {
    *this = ::std::move(from);
  }

  inline BufferRequest& operator=(const BufferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BufferRequest& operator=(BufferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BufferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BufferRequest* internal_default_instance() {
    return reinterpret_cast<const BufferRequest*>(
               &_BufferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BufferRequest& a, BufferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BufferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BufferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BufferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BufferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BufferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BufferRequest& from) {
    BufferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.BufferRequest";
  }
  protected:
  explicit BufferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 1,
  };
  // optional bytes buffer = 1;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_NODISCARD std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // @@protoc_insertion_point(class_scope:maa.BufferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class HandleBufferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.HandleBufferRequest) */ {
 public:
  inline HandleBufferRequest() : HandleBufferRequest(nullptr) {}
  ~HandleBufferRequest() override;
  explicit PROTOBUF_CONSTEXPR HandleBufferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleBufferRequest(const HandleBufferRequest& from);
  HandleBufferRequest(HandleBufferRequest&& from) noexcept
    : HandleBufferRequest() {
    *this = ::std::move(from);
  }

  inline HandleBufferRequest& operator=(const HandleBufferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleBufferRequest& operator=(HandleBufferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleBufferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleBufferRequest* internal_default_instance() {
    return reinterpret_cast<const HandleBufferRequest*>(
               &_HandleBufferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HandleBufferRequest& a, HandleBufferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleBufferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleBufferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleBufferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleBufferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleBufferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleBufferRequest& from) {
    HandleBufferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleBufferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.HandleBufferRequest";
  }
  protected:
  explicit HandleBufferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferFieldNumber = 2,
    kHandleFieldNumber = 1,
  };
  // optional bytes buffer = 2;
  bool has_buffer() const;
  private:
  bool _internal_has_buffer() const;
  public:
  void clear_buffer();
  const std::string& buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_buffer();
  PROTOBUF_NODISCARD std::string* release_buffer();
  void set_allocated_buffer(std::string* buffer);
  private:
  const std::string& _internal_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buffer(const std::string& value);
  std::string* _internal_mutable_buffer();
  public:

  // optional .maa.Handle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::maa::Handle& handle() const;
  PROTOBUF_NODISCARD ::maa::Handle* release_handle();
  ::maa::Handle* mutable_handle();
  void set_allocated_handle(::maa::Handle* handle);
  private:
  const ::maa::Handle& _internal_handle() const;
  ::maa::Handle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::maa::Handle* handle);
  ::maa::Handle* unsafe_arena_release_handle();

  // @@protoc_insertion_point(class_scope:maa.HandleBufferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr buffer_;
    ::maa::Handle* handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class HandleStringRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.HandleStringRequest) */ {
 public:
  inline HandleStringRequest() : HandleStringRequest(nullptr) {}
  ~HandleStringRequest() override;
  explicit PROTOBUF_CONSTEXPR HandleStringRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleStringRequest(const HandleStringRequest& from);
  HandleStringRequest(HandleStringRequest&& from) noexcept
    : HandleStringRequest() {
    *this = ::std::move(from);
  }

  inline HandleStringRequest& operator=(const HandleStringRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleStringRequest& operator=(HandleStringRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleStringRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleStringRequest* internal_default_instance() {
    return reinterpret_cast<const HandleStringRequest*>(
               &_HandleStringRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HandleStringRequest& a, HandleStringRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleStringRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleStringRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleStringRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleStringRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleStringRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleStringRequest& from) {
    HandleStringRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleStringRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.HandleStringRequest";
  }
  protected:
  explicit HandleStringRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrFieldNumber = 2,
    kHandleFieldNumber = 1,
  };
  // optional string str = 2;
  bool has_str() const;
  private:
  bool _internal_has_str() const;
  public:
  void clear_str();
  const std::string& str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str();
  PROTOBUF_NODISCARD std::string* release_str();
  void set_allocated_str(std::string* str);
  private:
  const std::string& _internal_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str(const std::string& value);
  std::string* _internal_mutable_str();
  public:

  // optional .maa.Handle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::maa::Handle& handle() const;
  PROTOBUF_NODISCARD ::maa::Handle* release_handle();
  ::maa::Handle* mutable_handle();
  void set_allocated_handle(::maa::Handle* handle);
  private:
  const ::maa::Handle& _internal_handle() const;
  ::maa::Handle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::maa::Handle* handle);
  ::maa::Handle* unsafe_arena_release_handle();

  // @@protoc_insertion_point(class_scope:maa.HandleStringRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_;
    ::maa::Handle* handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class HandleIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.HandleIdRequest) */ {
 public:
  inline HandleIdRequest() : HandleIdRequest(nullptr) {}
  ~HandleIdRequest() override;
  explicit PROTOBUF_CONSTEXPR HandleIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleIdRequest(const HandleIdRequest& from);
  HandleIdRequest(HandleIdRequest&& from) noexcept
    : HandleIdRequest() {
    *this = ::std::move(from);
  }

  inline HandleIdRequest& operator=(const HandleIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleIdRequest& operator=(HandleIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleIdRequest* internal_default_instance() {
    return reinterpret_cast<const HandleIdRequest*>(
               &_HandleIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(HandleIdRequest& a, HandleIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleIdRequest& from) {
    HandleIdRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.HandleIdRequest";
  }
  protected:
  explicit HandleIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // optional .maa.Handle handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const ::maa::Handle& handle() const;
  PROTOBUF_NODISCARD ::maa::Handle* release_handle();
  ::maa::Handle* mutable_handle();
  void set_allocated_handle(::maa::Handle* handle);
  private:
  const ::maa::Handle& _internal_handle() const;
  ::maa::Handle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::maa::Handle* handle);
  ::maa::Handle* unsafe_arena_release_handle();

  // optional .maa.Id id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::maa::Id& id() const;
  PROTOBUF_NODISCARD ::maa::Id* release_id();
  ::maa::Id* mutable_id();
  void set_allocated_id(::maa::Id* id);
  private:
  const ::maa::Id& _internal_id() const;
  ::maa::Id* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::maa::Id* id);
  ::maa::Id* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:maa.HandleIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::Handle* handle_;
    ::maa::Id* id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class EmptyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.EmptyResponse) */ {
 public:
  inline EmptyResponse() : EmptyResponse(nullptr) {}
  ~EmptyResponse() override;
  explicit PROTOBUF_CONSTEXPR EmptyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyResponse(const EmptyResponse& from);
  EmptyResponse(EmptyResponse&& from) noexcept
    : EmptyResponse() {
    *this = ::std::move(from);
  }

  inline EmptyResponse& operator=(const EmptyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyResponse& operator=(EmptyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyResponse* internal_default_instance() {
    return reinterpret_cast<const EmptyResponse*>(
               &_EmptyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EmptyResponse& a, EmptyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmptyResponse& from) {
    EmptyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.EmptyResponse";
  }
  protected:
  explicit EmptyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 101,
  };
  // optional .maa.RpcStatus status = 101;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::maa::RpcStatus& status() const;
  PROTOBUF_NODISCARD ::maa::RpcStatus* release_status();
  ::maa::RpcStatus* mutable_status();
  void set_allocated_status(::maa::RpcStatus* status);
  private:
  const ::maa::RpcStatus& _internal_status() const;
  ::maa::RpcStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::maa::RpcStatus* status);
  ::maa::RpcStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:maa.EmptyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::RpcStatus* status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class IdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.IdResponse) */ {
 public:
  inline IdResponse() : IdResponse(nullptr) {}
  ~IdResponse() override;
  explicit PROTOBUF_CONSTEXPR IdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IdResponse(const IdResponse& from);
  IdResponse(IdResponse&& from) noexcept
    : IdResponse() {
    *this = ::std::move(from);
  }

  inline IdResponse& operator=(const IdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdResponse& operator=(IdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdResponse* internal_default_instance() {
    return reinterpret_cast<const IdResponse*>(
               &_IdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(IdResponse& a, IdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IdResponse& from) {
    IdResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.IdResponse";
  }
  protected:
  explicit IdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStatusFieldNumber = 101,
  };
  // optional .maa.Id id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::maa::Id& id() const;
  PROTOBUF_NODISCARD ::maa::Id* release_id();
  ::maa::Id* mutable_id();
  void set_allocated_id(::maa::Id* id);
  private:
  const ::maa::Id& _internal_id() const;
  ::maa::Id* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::maa::Id* id);
  ::maa::Id* unsafe_arena_release_id();

  // optional .maa.RpcStatus status = 101;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::maa::RpcStatus& status() const;
  PROTOBUF_NODISCARD ::maa::RpcStatus* release_status();
  ::maa::RpcStatus* mutable_status();
  void set_allocated_status(::maa::RpcStatus* status);
  private:
  const ::maa::RpcStatus& _internal_status() const;
  ::maa::RpcStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::maa::RpcStatus* status);
  ::maa::RpcStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:maa.IdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::Id* id_;
    ::maa::RpcStatus* status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class BoolResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.BoolResponse) */ {
 public:
  inline BoolResponse() : BoolResponse(nullptr) {}
  ~BoolResponse() override;
  explicit PROTOBUF_CONSTEXPR BoolResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolResponse(const BoolResponse& from);
  BoolResponse(BoolResponse&& from) noexcept
    : BoolResponse() {
    *this = ::std::move(from);
  }

  inline BoolResponse& operator=(const BoolResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolResponse& operator=(BoolResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolResponse* internal_default_instance() {
    return reinterpret_cast<const BoolResponse*>(
               &_BoolResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BoolResponse& a, BoolResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoolResponse& from) {
    BoolResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.BoolResponse";
  }
  protected:
  explicit BoolResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 101,
    kValueFieldNumber = 1,
  };
  // optional .maa.RpcStatus status = 101;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::maa::RpcStatus& status() const;
  PROTOBUF_NODISCARD ::maa::RpcStatus* release_status();
  ::maa::RpcStatus* mutable_status();
  void set_allocated_status(::maa::RpcStatus* status);
  private:
  const ::maa::RpcStatus& _internal_status() const;
  ::maa::RpcStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::maa::RpcStatus* status);
  ::maa::RpcStatus* unsafe_arena_release_status();

  // optional bool value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:maa.BoolResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::RpcStatus* status_;
    bool value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class StringResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.StringResponse) */ {
 public:
  inline StringResponse() : StringResponse(nullptr) {}
  ~StringResponse() override;
  explicit PROTOBUF_CONSTEXPR StringResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringResponse(const StringResponse& from);
  StringResponse(StringResponse&& from) noexcept
    : StringResponse() {
    *this = ::std::move(from);
  }

  inline StringResponse& operator=(const StringResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringResponse& operator=(StringResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringResponse* internal_default_instance() {
    return reinterpret_cast<const StringResponse*>(
               &_StringResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(StringResponse& a, StringResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StringResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringResponse& from) {
    StringResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.StringResponse";
  }
  protected:
  explicit StringResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kStatusFieldNumber = 101,
  };
  // optional string value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional .maa.RpcStatus status = 101;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::maa::RpcStatus& status() const;
  PROTOBUF_NODISCARD ::maa::RpcStatus* release_status();
  ::maa::RpcStatus* mutable_status();
  void set_allocated_status(::maa::RpcStatus* status);
  private:
  const ::maa::RpcStatus& _internal_status() const;
  ::maa::RpcStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::maa::RpcStatus* status);
  ::maa::RpcStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:maa.StringResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::maa::RpcStatus* status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class HandleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.HandleResponse) */ {
 public:
  inline HandleResponse() : HandleResponse(nullptr) {}
  ~HandleResponse() override;
  explicit PROTOBUF_CONSTEXPR HandleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandleResponse(const HandleResponse& from);
  HandleResponse(HandleResponse&& from) noexcept
    : HandleResponse() {
    *this = ::std::move(from);
  }

  inline HandleResponse& operator=(const HandleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandleResponse& operator=(HandleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandleResponse* internal_default_instance() {
    return reinterpret_cast<const HandleResponse*>(
               &_HandleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(HandleResponse& a, HandleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HandleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HandleResponse& from) {
    HandleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.HandleResponse";
  }
  protected:
  explicit HandleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kStatusFieldNumber = 101,
  };
  // optional .maa.Handle value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::maa::Handle& value() const;
  PROTOBUF_NODISCARD ::maa::Handle* release_value();
  ::maa::Handle* mutable_value();
  void set_allocated_value(::maa::Handle* value);
  private:
  const ::maa::Handle& _internal_value() const;
  ::maa::Handle* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::maa::Handle* value);
  ::maa::Handle* unsafe_arena_release_value();

  // optional .maa.RpcStatus status = 101;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::maa::RpcStatus& status() const;
  PROTOBUF_NODISCARD ::maa::RpcStatus* release_status();
  ::maa::RpcStatus* mutable_status();
  void set_allocated_status(::maa::RpcStatus* status);
  private:
  const ::maa::RpcStatus& _internal_status() const;
  ::maa::RpcStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::maa::RpcStatus* status);
  ::maa::RpcStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:maa.HandleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::Handle* value_;
    ::maa::RpcStatus* status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class BufferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.BufferResponse) */ {
 public:
  inline BufferResponse() : BufferResponse(nullptr) {}
  ~BufferResponse() override;
  explicit PROTOBUF_CONSTEXPR BufferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BufferResponse(const BufferResponse& from);
  BufferResponse(BufferResponse&& from) noexcept
    : BufferResponse() {
    *this = ::std::move(from);
  }

  inline BufferResponse& operator=(const BufferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BufferResponse& operator=(BufferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BufferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BufferResponse* internal_default_instance() {
    return reinterpret_cast<const BufferResponse*>(
               &_BufferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(BufferResponse& a, BufferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BufferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BufferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BufferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BufferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BufferResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BufferResponse& from) {
    BufferResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.BufferResponse";
  }
  protected:
  explicit BufferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kStatusFieldNumber = 101,
  };
  // optional bytes value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional .maa.RpcStatus status = 101;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::maa::RpcStatus& status() const;
  PROTOBUF_NODISCARD ::maa::RpcStatus* release_status();
  ::maa::RpcStatus* mutable_status();
  void set_allocated_status(::maa::RpcStatus* status);
  private:
  const ::maa::RpcStatus& _internal_status() const;
  ::maa::RpcStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::maa::RpcStatus* status);
  ::maa::RpcStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:maa.BufferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::maa::RpcStatus* status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class StatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maa.StatusResponse) */ {
 public:
  inline StatusResponse() : StatusResponse(nullptr) {}
  ~StatusResponse() override;
  explicit PROTOBUF_CONSTEXPR StatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatusResponse(const StatusResponse& from);
  StatusResponse(StatusResponse&& from) noexcept
    : StatusResponse() {
    *this = ::std::move(from);
  }

  inline StatusResponse& operator=(const StatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusResponse& operator=(StatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatusResponse* internal_default_instance() {
    return reinterpret_cast<const StatusResponse*>(
               &_StatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StatusResponse& a, StatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatusResponse& from) {
    StatusResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maa.StatusResponse";
  }
  protected:
  explicit StatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 101,
    kValueFieldNumber = 1,
  };
  // optional .maa.RpcStatus status = 101;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::maa::RpcStatus& status() const;
  PROTOBUF_NODISCARD ::maa::RpcStatus* release_status();
  ::maa::RpcStatus* mutable_status();
  void set_allocated_status(::maa::RpcStatus* status);
  private:
  const ::maa::RpcStatus& _internal_status() const;
  ::maa::RpcStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::maa::RpcStatus* status);
  ::maa::RpcStatus* unsafe_arena_release_status();

  // optional .maa.Status value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  ::maa::Status value() const;
  void set_value(::maa::Status value);
  private:
  ::maa::Status _internal_value() const;
  void _internal_set_value(::maa::Status value);
  public:

  // @@protoc_insertion_point(class_scope:maa.StatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::maa::RpcStatus* status_;
    int value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Types_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RpcStatus

// optional bool success = 1;
inline bool RpcStatus::_internal_has_success() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RpcStatus::has_success() const {
  return _internal_has_success();
}
inline void RpcStatus::clear_success() {
  _impl_.success_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool RpcStatus::_internal_success() const {
  return _impl_.success_;
}
inline bool RpcStatus::success() const {
  // @@protoc_insertion_point(field_get:maa.RpcStatus.success)
  return _internal_success();
}
inline void RpcStatus::_internal_set_success(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.success_ = value;
}
inline void RpcStatus::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:maa.RpcStatus.success)
}

// -------------------------------------------------------------------

// Id

// optional uint64 id = 1;
inline bool Id::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Id::has_id() const {
  return _internal_has_id();
}
inline void Id::clear_id() {
  _impl_.id_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Id::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Id::id() const {
  // @@protoc_insertion_point(field_get:maa.Id.id)
  return _internal_id();
}
inline void Id::_internal_set_id(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void Id::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:maa.Id.id)
}

// -------------------------------------------------------------------

// Handle

// optional uint64 handle = 1;
inline bool Handle::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Handle::has_handle() const {
  return _internal_has_handle();
}
inline void Handle::clear_handle() {
  _impl_.handle_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Handle::_internal_handle() const {
  return _impl_.handle_;
}
inline uint64_t Handle::handle() const {
  // @@protoc_insertion_point(field_get:maa.Handle.handle)
  return _internal_handle();
}
inline void Handle::_internal_set_handle(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_ = value;
}
inline void Handle::set_handle(uint64_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:maa.Handle.handle)
}

// -------------------------------------------------------------------

// Point

// optional int32 x = 1;
inline bool Point::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Point::has_x() const {
  return _internal_has_x();
}
inline void Point::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Point::_internal_x() const {
  return _impl_.x_;
}
inline int32_t Point::x() const {
  // @@protoc_insertion_point(field_get:maa.Point.x)
  return _internal_x();
}
inline void Point::_internal_set_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void Point::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:maa.Point.x)
}

// optional int32 y = 2;
inline bool Point::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Point::has_y() const {
  return _internal_has_y();
}
inline void Point::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Point::_internal_y() const {
  return _impl_.y_;
}
inline int32_t Point::y() const {
  // @@protoc_insertion_point(field_get:maa.Point.y)
  return _internal_y();
}
inline void Point::_internal_set_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void Point::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:maa.Point.y)
}

// -------------------------------------------------------------------

// Size

// optional int32 width = 1;
inline bool Size::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Size::has_width() const {
  return _internal_has_width();
}
inline void Size::clear_width() {
  _impl_.width_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Size::_internal_width() const {
  return _impl_.width_;
}
inline int32_t Size::width() const {
  // @@protoc_insertion_point(field_get:maa.Size.width)
  return _internal_width();
}
inline void Size::_internal_set_width(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.width_ = value;
}
inline void Size::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:maa.Size.width)
}

// optional int32 height = 2;
inline bool Size::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Size::has_height() const {
  return _internal_has_height();
}
inline void Size::clear_height() {
  _impl_.height_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Size::_internal_height() const {
  return _impl_.height_;
}
inline int32_t Size::height() const {
  // @@protoc_insertion_point(field_get:maa.Size.height)
  return _internal_height();
}
inline void Size::_internal_set_height(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.height_ = value;
}
inline void Size::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:maa.Size.height)
}

// -------------------------------------------------------------------

// Rect

// optional .maa.Point xy = 1;
inline bool Rect::_internal_has_xy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.xy_ != nullptr);
  return value;
}
inline bool Rect::has_xy() const {
  return _internal_has_xy();
}
inline void Rect::clear_xy() {
  if (_impl_.xy_ != nullptr) _impl_.xy_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::Point& Rect::_internal_xy() const {
  const ::maa::Point* p = _impl_.xy_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Point&>(
      ::maa::_Point_default_instance_);
}
inline const ::maa::Point& Rect::xy() const {
  // @@protoc_insertion_point(field_get:maa.Rect.xy)
  return _internal_xy();
}
inline void Rect::unsafe_arena_set_allocated_xy(
    ::maa::Point* xy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.xy_);
  }
  _impl_.xy_ = xy;
  if (xy) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.Rect.xy)
}
inline ::maa::Point* Rect::release_xy() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Point* temp = _impl_.xy_;
  _impl_.xy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Point* Rect::unsafe_arena_release_xy() {
  // @@protoc_insertion_point(field_release:maa.Rect.xy)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Point* temp = _impl_.xy_;
  _impl_.xy_ = nullptr;
  return temp;
}
inline ::maa::Point* Rect::_internal_mutable_xy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.xy_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Point>(GetArenaForAllocation());
    _impl_.xy_ = p;
  }
  return _impl_.xy_;
}
inline ::maa::Point* Rect::mutable_xy() {
  ::maa::Point* _msg = _internal_mutable_xy();
  // @@protoc_insertion_point(field_mutable:maa.Rect.xy)
  return _msg;
}
inline void Rect::set_allocated_xy(::maa::Point* xy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.xy_;
  }
  if (xy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(xy);
    if (message_arena != submessage_arena) {
      xy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xy, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.xy_ = xy;
  // @@protoc_insertion_point(field_set_allocated:maa.Rect.xy)
}

// optional .maa.Size wh = 2;
inline bool Rect::_internal_has_wh() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.wh_ != nullptr);
  return value;
}
inline bool Rect::has_wh() const {
  return _internal_has_wh();
}
inline void Rect::clear_wh() {
  if (_impl_.wh_ != nullptr) _impl_.wh_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maa::Size& Rect::_internal_wh() const {
  const ::maa::Size* p = _impl_.wh_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Size&>(
      ::maa::_Size_default_instance_);
}
inline const ::maa::Size& Rect::wh() const {
  // @@protoc_insertion_point(field_get:maa.Rect.wh)
  return _internal_wh();
}
inline void Rect::unsafe_arena_set_allocated_wh(
    ::maa::Size* wh) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.wh_);
  }
  _impl_.wh_ = wh;
  if (wh) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.Rect.wh)
}
inline ::maa::Size* Rect::release_wh() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::Size* temp = _impl_.wh_;
  _impl_.wh_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Size* Rect::unsafe_arena_release_wh() {
  // @@protoc_insertion_point(field_release:maa.Rect.wh)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::Size* temp = _impl_.wh_;
  _impl_.wh_ = nullptr;
  return temp;
}
inline ::maa::Size* Rect::_internal_mutable_wh() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.wh_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Size>(GetArenaForAllocation());
    _impl_.wh_ = p;
  }
  return _impl_.wh_;
}
inline ::maa::Size* Rect::mutable_wh() {
  ::maa::Size* _msg = _internal_mutable_wh();
  // @@protoc_insertion_point(field_mutable:maa.Rect.wh)
  return _msg;
}
inline void Rect::set_allocated_wh(::maa::Size* wh) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.wh_;
  }
  if (wh) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(wh);
    if (message_arena != submessage_arena) {
      wh = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wh, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.wh_ = wh;
  // @@protoc_insertion_point(field_set_allocated:maa.Rect.wh)
}

// -------------------------------------------------------------------

// Callback

// optional string msg = 1;
inline bool Callback::_internal_has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Callback::has_msg() const {
  return _internal_has_msg();
}
inline void Callback::clear_msg() {
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Callback::msg() const {
  // @@protoc_insertion_point(field_get:maa.Callback.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Callback::set_msg(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maa.Callback.msg)
}
inline std::string* Callback::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:maa.Callback.msg)
  return _s;
}
inline const std::string& Callback::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void Callback::_internal_set_msg(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Callback::_internal_mutable_msg() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Callback::release_msg() {
  // @@protoc_insertion_point(field_release:maa.Callback.msg)
  if (!_internal_has_msg()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.msg_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Callback::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maa.Callback.msg)
}

// optional string detail = 2;
inline bool Callback::_internal_has_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Callback::has_detail() const {
  return _internal_has_detail();
}
inline void Callback::clear_detail() {
  _impl_.detail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Callback::detail() const {
  // @@protoc_insertion_point(field_get:maa.Callback.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Callback::set_detail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maa.Callback.detail)
}
inline std::string* Callback::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:maa.Callback.detail)
  return _s;
}
inline const std::string& Callback::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void Callback::_internal_set_detail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* Callback::_internal_mutable_detail() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* Callback::release_detail() {
  // @@protoc_insertion_point(field_release:maa.Callback.detail)
  if (!_internal_has_detail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.detail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Callback::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maa.Callback.detail)
}

// -------------------------------------------------------------------

// ClickParam

// optional .maa.Point point = 1;
inline bool ClickParam::_internal_has_point() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.point_ != nullptr);
  return value;
}
inline bool ClickParam::has_point() const {
  return _internal_has_point();
}
inline void ClickParam::clear_point() {
  if (_impl_.point_ != nullptr) _impl_.point_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::Point& ClickParam::_internal_point() const {
  const ::maa::Point* p = _impl_.point_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Point&>(
      ::maa::_Point_default_instance_);
}
inline const ::maa::Point& ClickParam::point() const {
  // @@protoc_insertion_point(field_get:maa.ClickParam.point)
  return _internal_point();
}
inline void ClickParam::unsafe_arena_set_allocated_point(
    ::maa::Point* point) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.point_);
  }
  _impl_.point_ = point;
  if (point) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.ClickParam.point)
}
inline ::maa::Point* ClickParam::release_point() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Point* ClickParam::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_release:maa.ClickParam.point)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Point* temp = _impl_.point_;
  _impl_.point_ = nullptr;
  return temp;
}
inline ::maa::Point* ClickParam::_internal_mutable_point() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.point_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Point>(GetArenaForAllocation());
    _impl_.point_ = p;
  }
  return _impl_.point_;
}
inline ::maa::Point* ClickParam::mutable_point() {
  ::maa::Point* _msg = _internal_mutable_point();
  // @@protoc_insertion_point(field_mutable:maa.ClickParam.point)
  return _msg;
}
inline void ClickParam::set_allocated_point(::maa::Point* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.point_;
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point);
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.point_ = point;
  // @@protoc_insertion_point(field_set_allocated:maa.ClickParam.point)
}

// -------------------------------------------------------------------

// SwipeParam

// optional .maa.Point from = 1;
inline bool SwipeParam::_internal_has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.from_ != nullptr);
  return value;
}
inline bool SwipeParam::has_from() const {
  return _internal_has_from();
}
inline void SwipeParam::clear_from() {
  if (_impl_.from_ != nullptr) _impl_.from_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::Point& SwipeParam::_internal_from() const {
  const ::maa::Point* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Point&>(
      ::maa::_Point_default_instance_);
}
inline const ::maa::Point& SwipeParam::from() const {
  // @@protoc_insertion_point(field_get:maa.SwipeParam.from)
  return _internal_from();
}
inline void SwipeParam::unsafe_arena_set_allocated_from(
    ::maa::Point* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = from;
  if (from) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.SwipeParam.from)
}
inline ::maa::Point* SwipeParam::release_from() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Point* temp = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Point* SwipeParam::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:maa.SwipeParam.from)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Point* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::maa::Point* SwipeParam::_internal_mutable_from() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Point>(GetArenaForAllocation());
    _impl_.from_ = p;
  }
  return _impl_.from_;
}
inline ::maa::Point* SwipeParam::mutable_from() {
  ::maa::Point* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:maa.SwipeParam.from)
  return _msg;
}
inline void SwipeParam::set_allocated_from(::maa::Point* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(from);
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.from_ = from;
  // @@protoc_insertion_point(field_set_allocated:maa.SwipeParam.from)
}

// optional .maa.Point to = 2;
inline bool SwipeParam::_internal_has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.to_ != nullptr);
  return value;
}
inline bool SwipeParam::has_to() const {
  return _internal_has_to();
}
inline void SwipeParam::clear_to() {
  if (_impl_.to_ != nullptr) _impl_.to_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maa::Point& SwipeParam::_internal_to() const {
  const ::maa::Point* p = _impl_.to_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Point&>(
      ::maa::_Point_default_instance_);
}
inline const ::maa::Point& SwipeParam::to() const {
  // @@protoc_insertion_point(field_get:maa.SwipeParam.to)
  return _internal_to();
}
inline void SwipeParam::unsafe_arena_set_allocated_to(
    ::maa::Point* to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_);
  }
  _impl_.to_ = to;
  if (to) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.SwipeParam.to)
}
inline ::maa::Point* SwipeParam::release_to() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::Point* temp = _impl_.to_;
  _impl_.to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Point* SwipeParam::unsafe_arena_release_to() {
  // @@protoc_insertion_point(field_release:maa.SwipeParam.to)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::Point* temp = _impl_.to_;
  _impl_.to_ = nullptr;
  return temp;
}
inline ::maa::Point* SwipeParam::_internal_mutable_to() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.to_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Point>(GetArenaForAllocation());
    _impl_.to_ = p;
  }
  return _impl_.to_;
}
inline ::maa::Point* SwipeParam::mutable_to() {
  ::maa::Point* _msg = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:maa.SwipeParam.to)
  return _msg;
}
inline void SwipeParam::set_allocated_to(::maa::Point* to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.to_;
  }
  if (to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(to);
    if (message_arena != submessage_arena) {
      to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.to_ = to;
  // @@protoc_insertion_point(field_set_allocated:maa.SwipeParam.to)
}

// optional int32 duration = 3;
inline bool SwipeParam::_internal_has_duration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SwipeParam::has_duration() const {
  return _internal_has_duration();
}
inline void SwipeParam::clear_duration() {
  _impl_.duration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t SwipeParam::_internal_duration() const {
  return _impl_.duration_;
}
inline int32_t SwipeParam::duration() const {
  // @@protoc_insertion_point(field_get:maa.SwipeParam.duration)
  return _internal_duration();
}
inline void SwipeParam::_internal_set_duration(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.duration_ = value;
}
inline void SwipeParam::set_duration(int32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:maa.SwipeParam.duration)
}

// -------------------------------------------------------------------

// KeyParam

// optional int32 key = 1;
inline bool KeyParam::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeyParam::has_key() const {
  return _internal_has_key();
}
inline void KeyParam::clear_key() {
  _impl_.key_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t KeyParam::_internal_key() const {
  return _impl_.key_;
}
inline int32_t KeyParam::key() const {
  // @@protoc_insertion_point(field_get:maa.KeyParam.key)
  return _internal_key();
}
inline void KeyParam::_internal_set_key(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_ = value;
}
inline void KeyParam::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:maa.KeyParam.key)
}

// -------------------------------------------------------------------

// TouchParam

// optional int32 contact = 1;
inline bool TouchParam::_internal_has_contact() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TouchParam::has_contact() const {
  return _internal_has_contact();
}
inline void TouchParam::clear_contact() {
  _impl_.contact_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TouchParam::_internal_contact() const {
  return _impl_.contact_;
}
inline int32_t TouchParam::contact() const {
  // @@protoc_insertion_point(field_get:maa.TouchParam.contact)
  return _internal_contact();
}
inline void TouchParam::_internal_set_contact(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.contact_ = value;
}
inline void TouchParam::set_contact(int32_t value) {
  _internal_set_contact(value);
  // @@protoc_insertion_point(field_set:maa.TouchParam.contact)
}

// optional .maa.Point pos = 2;
inline bool TouchParam::_internal_has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline bool TouchParam::has_pos() const {
  return _internal_has_pos();
}
inline void TouchParam::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::Point& TouchParam::_internal_pos() const {
  const ::maa::Point* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Point&>(
      ::maa::_Point_default_instance_);
}
inline const ::maa::Point& TouchParam::pos() const {
  // @@protoc_insertion_point(field_get:maa.TouchParam.pos)
  return _internal_pos();
}
inline void TouchParam::unsafe_arena_set_allocated_pos(
    ::maa::Point* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.TouchParam.pos)
}
inline ::maa::Point* TouchParam::release_pos() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Point* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Point* TouchParam::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:maa.TouchParam.pos)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Point* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::maa::Point* TouchParam::_internal_mutable_pos() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Point>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::maa::Point* TouchParam::mutable_pos() {
  ::maa::Point* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:maa.TouchParam.pos)
  return _msg;
}
inline void TouchParam::set_allocated_pos(::maa::Point* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:maa.TouchParam.pos)
}

// optional int32 pressure = 3;
inline bool TouchParam::_internal_has_pressure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TouchParam::has_pressure() const {
  return _internal_has_pressure();
}
inline void TouchParam::clear_pressure() {
  _impl_.pressure_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TouchParam::_internal_pressure() const {
  return _impl_.pressure_;
}
inline int32_t TouchParam::pressure() const {
  // @@protoc_insertion_point(field_get:maa.TouchParam.pressure)
  return _internal_pressure();
}
inline void TouchParam::_internal_set_pressure(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.pressure_ = value;
}
inline void TouchParam::set_pressure(int32_t value) {
  _internal_set_pressure(value);
  // @@protoc_insertion_point(field_set:maa.TouchParam.pressure)
}

// -------------------------------------------------------------------

// EmptyRequest

// -------------------------------------------------------------------

// IdRequest

// optional .maa.Id id = 1;
inline bool IdRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline bool IdRequest::has_id() const {
  return _internal_has_id();
}
inline void IdRequest::clear_id() {
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::Id& IdRequest::_internal_id() const {
  const ::maa::Id* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Id&>(
      ::maa::_Id_default_instance_);
}
inline const ::maa::Id& IdRequest::id() const {
  // @@protoc_insertion_point(field_get:maa.IdRequest.id)
  return _internal_id();
}
inline void IdRequest::unsafe_arena_set_allocated_id(
    ::maa::Id* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.IdRequest.id)
}
inline ::maa::Id* IdRequest::release_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Id* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Id* IdRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:maa.IdRequest.id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Id* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::maa::Id* IdRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Id>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::maa::Id* IdRequest::mutable_id() {
  ::maa::Id* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:maa.IdRequest.id)
  return _msg;
}
inline void IdRequest::set_allocated_id(::maa::Id* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:maa.IdRequest.id)
}

// -------------------------------------------------------------------

// HandleRequest

// optional .maa.Handle handle = 1;
inline bool HandleRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool HandleRequest::has_handle() const {
  return _internal_has_handle();
}
inline void HandleRequest::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::Handle& HandleRequest::_internal_handle() const {
  const ::maa::Handle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Handle&>(
      ::maa::_Handle_default_instance_);
}
inline const ::maa::Handle& HandleRequest::handle() const {
  // @@protoc_insertion_point(field_get:maa.HandleRequest.handle)
  return _internal_handle();
}
inline void HandleRequest::unsafe_arena_set_allocated_handle(
    ::maa::Handle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.HandleRequest.handle)
}
inline ::maa::Handle* HandleRequest::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Handle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Handle* HandleRequest::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:maa.HandleRequest.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Handle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::maa::Handle* HandleRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Handle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::maa::Handle* HandleRequest::mutable_handle() {
  ::maa::Handle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maa.HandleRequest.handle)
  return _msg;
}
inline void HandleRequest::set_allocated_handle(::maa::Handle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.handle_;
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(handle);
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:maa.HandleRequest.handle)
}

// -------------------------------------------------------------------

// BufferRequest

// optional bytes buffer = 1;
inline bool BufferRequest::_internal_has_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BufferRequest::has_buffer() const {
  return _internal_has_buffer();
}
inline void BufferRequest::clear_buffer() {
  _impl_.buffer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BufferRequest::buffer() const {
  // @@protoc_insertion_point(field_get:maa.BufferRequest.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BufferRequest::set_buffer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.buffer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maa.BufferRequest.buffer)
}
inline std::string* BufferRequest::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:maa.BufferRequest.buffer)
  return _s;
}
inline const std::string& BufferRequest::_internal_buffer() const {
  return _impl_.buffer_.Get();
}
inline void BufferRequest::_internal_set_buffer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buffer_.Set(value, GetArenaForAllocation());
}
inline std::string* BufferRequest::_internal_mutable_buffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.buffer_.Mutable(GetArenaForAllocation());
}
inline std::string* BufferRequest::release_buffer() {
  // @@protoc_insertion_point(field_release:maa.BufferRequest.buffer)
  if (!_internal_has_buffer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.buffer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buffer_.IsDefault()) {
    _impl_.buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BufferRequest::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buffer_.SetAllocated(buffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buffer_.IsDefault()) {
    _impl_.buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maa.BufferRequest.buffer)
}

// -------------------------------------------------------------------

// HandleBufferRequest

// optional .maa.Handle handle = 1;
inline bool HandleBufferRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool HandleBufferRequest::has_handle() const {
  return _internal_has_handle();
}
inline void HandleBufferRequest::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maa::Handle& HandleBufferRequest::_internal_handle() const {
  const ::maa::Handle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Handle&>(
      ::maa::_Handle_default_instance_);
}
inline const ::maa::Handle& HandleBufferRequest::handle() const {
  // @@protoc_insertion_point(field_get:maa.HandleBufferRequest.handle)
  return _internal_handle();
}
inline void HandleBufferRequest::unsafe_arena_set_allocated_handle(
    ::maa::Handle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.HandleBufferRequest.handle)
}
inline ::maa::Handle* HandleBufferRequest::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::Handle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Handle* HandleBufferRequest::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:maa.HandleBufferRequest.handle)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::Handle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::maa::Handle* HandleBufferRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Handle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::maa::Handle* HandleBufferRequest::mutable_handle() {
  ::maa::Handle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maa.HandleBufferRequest.handle)
  return _msg;
}
inline void HandleBufferRequest::set_allocated_handle(::maa::Handle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.handle_;
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(handle);
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:maa.HandleBufferRequest.handle)
}

// optional bytes buffer = 2;
inline bool HandleBufferRequest::_internal_has_buffer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandleBufferRequest::has_buffer() const {
  return _internal_has_buffer();
}
inline void HandleBufferRequest::clear_buffer() {
  _impl_.buffer_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandleBufferRequest::buffer() const {
  // @@protoc_insertion_point(field_get:maa.HandleBufferRequest.buffer)
  return _internal_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleBufferRequest::set_buffer(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.buffer_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maa.HandleBufferRequest.buffer)
}
inline std::string* HandleBufferRequest::mutable_buffer() {
  std::string* _s = _internal_mutable_buffer();
  // @@protoc_insertion_point(field_mutable:maa.HandleBufferRequest.buffer)
  return _s;
}
inline const std::string& HandleBufferRequest::_internal_buffer() const {
  return _impl_.buffer_.Get();
}
inline void HandleBufferRequest::_internal_set_buffer(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buffer_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleBufferRequest::_internal_mutable_buffer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.buffer_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleBufferRequest::release_buffer() {
  // @@protoc_insertion_point(field_release:maa.HandleBufferRequest.buffer)
  if (!_internal_has_buffer()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.buffer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buffer_.IsDefault()) {
    _impl_.buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleBufferRequest::set_allocated_buffer(std::string* buffer) {
  if (buffer != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buffer_.SetAllocated(buffer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.buffer_.IsDefault()) {
    _impl_.buffer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maa.HandleBufferRequest.buffer)
}

// -------------------------------------------------------------------

// HandleStringRequest

// optional .maa.Handle handle = 1;
inline bool HandleStringRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool HandleStringRequest::has_handle() const {
  return _internal_has_handle();
}
inline void HandleStringRequest::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maa::Handle& HandleStringRequest::_internal_handle() const {
  const ::maa::Handle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Handle&>(
      ::maa::_Handle_default_instance_);
}
inline const ::maa::Handle& HandleStringRequest::handle() const {
  // @@protoc_insertion_point(field_get:maa.HandleStringRequest.handle)
  return _internal_handle();
}
inline void HandleStringRequest::unsafe_arena_set_allocated_handle(
    ::maa::Handle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.HandleStringRequest.handle)
}
inline ::maa::Handle* HandleStringRequest::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::Handle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Handle* HandleStringRequest::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:maa.HandleStringRequest.handle)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::Handle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::maa::Handle* HandleStringRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Handle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::maa::Handle* HandleStringRequest::mutable_handle() {
  ::maa::Handle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maa.HandleStringRequest.handle)
  return _msg;
}
inline void HandleStringRequest::set_allocated_handle(::maa::Handle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.handle_;
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(handle);
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:maa.HandleStringRequest.handle)
}

// optional string str = 2;
inline bool HandleStringRequest::_internal_has_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HandleStringRequest::has_str() const {
  return _internal_has_str();
}
inline void HandleStringRequest::clear_str() {
  _impl_.str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HandleStringRequest::str() const {
  // @@protoc_insertion_point(field_get:maa.HandleStringRequest.str)
  return _internal_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandleStringRequest::set_str(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.str_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maa.HandleStringRequest.str)
}
inline std::string* HandleStringRequest::mutable_str() {
  std::string* _s = _internal_mutable_str();
  // @@protoc_insertion_point(field_mutable:maa.HandleStringRequest.str)
  return _s;
}
inline const std::string& HandleStringRequest::_internal_str() const {
  return _impl_.str_.Get();
}
inline void HandleStringRequest::_internal_set_str(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.str_.Set(value, GetArenaForAllocation());
}
inline std::string* HandleStringRequest::_internal_mutable_str() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.str_.Mutable(GetArenaForAllocation());
}
inline std::string* HandleStringRequest::release_str() {
  // @@protoc_insertion_point(field_release:maa.HandleStringRequest.str)
  if (!_internal_has_str()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.str_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HandleStringRequest::set_allocated_str(std::string* str) {
  if (str != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.str_.SetAllocated(str, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_.IsDefault()) {
    _impl_.str_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maa.HandleStringRequest.str)
}

// -------------------------------------------------------------------

// HandleIdRequest

// optional .maa.Handle handle = 1;
inline bool HandleIdRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline bool HandleIdRequest::has_handle() const {
  return _internal_has_handle();
}
inline void HandleIdRequest::clear_handle() {
  if (_impl_.handle_ != nullptr) _impl_.handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::Handle& HandleIdRequest::_internal_handle() const {
  const ::maa::Handle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Handle&>(
      ::maa::_Handle_default_instance_);
}
inline const ::maa::Handle& HandleIdRequest::handle() const {
  // @@protoc_insertion_point(field_get:maa.HandleIdRequest.handle)
  return _internal_handle();
}
inline void HandleIdRequest::unsafe_arena_set_allocated_handle(
    ::maa::Handle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.HandleIdRequest.handle)
}
inline ::maa::Handle* HandleIdRequest::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Handle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Handle* HandleIdRequest::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:maa.HandleIdRequest.handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Handle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::maa::Handle* HandleIdRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Handle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::maa::Handle* HandleIdRequest::mutable_handle() {
  ::maa::Handle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maa.HandleIdRequest.handle)
  return _msg;
}
inline void HandleIdRequest::set_allocated_handle(::maa::Handle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.handle_;
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(handle);
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:maa.HandleIdRequest.handle)
}

// optional .maa.Id id = 2;
inline bool HandleIdRequest::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline bool HandleIdRequest::has_id() const {
  return _internal_has_id();
}
inline void HandleIdRequest::clear_id() {
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maa::Id& HandleIdRequest::_internal_id() const {
  const ::maa::Id* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Id&>(
      ::maa::_Id_default_instance_);
}
inline const ::maa::Id& HandleIdRequest::id() const {
  // @@protoc_insertion_point(field_get:maa.HandleIdRequest.id)
  return _internal_id();
}
inline void HandleIdRequest::unsafe_arena_set_allocated_id(
    ::maa::Id* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.HandleIdRequest.id)
}
inline ::maa::Id* HandleIdRequest::release_id() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::Id* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Id* HandleIdRequest::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:maa.HandleIdRequest.id)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::Id* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::maa::Id* HandleIdRequest::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Id>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::maa::Id* HandleIdRequest::mutable_id() {
  ::maa::Id* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:maa.HandleIdRequest.id)
  return _msg;
}
inline void HandleIdRequest::set_allocated_id(::maa::Id* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:maa.HandleIdRequest.id)
}

// -------------------------------------------------------------------

// EmptyResponse

// optional .maa.RpcStatus status = 101;
inline bool EmptyResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline bool EmptyResponse::has_status() const {
  return _internal_has_status();
}
inline void EmptyResponse::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::RpcStatus& EmptyResponse::_internal_status() const {
  const ::maa::RpcStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::RpcStatus&>(
      ::maa::_RpcStatus_default_instance_);
}
inline const ::maa::RpcStatus& EmptyResponse::status() const {
  // @@protoc_insertion_point(field_get:maa.EmptyResponse.status)
  return _internal_status();
}
inline void EmptyResponse::unsafe_arena_set_allocated_status(
    ::maa::RpcStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.EmptyResponse.status)
}
inline ::maa::RpcStatus* EmptyResponse::release_status() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::RpcStatus* EmptyResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:maa.EmptyResponse.status)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::maa::RpcStatus* EmptyResponse::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::RpcStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::maa::RpcStatus* EmptyResponse::mutable_status() {
  ::maa::RpcStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:maa.EmptyResponse.status)
  return _msg;
}
inline void EmptyResponse::set_allocated_status(::maa::RpcStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:maa.EmptyResponse.status)
}

// -------------------------------------------------------------------

// IdResponse

// optional .maa.Id id = 1;
inline bool IdResponse::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline bool IdResponse::has_id() const {
  return _internal_has_id();
}
inline void IdResponse::clear_id() {
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::Id& IdResponse::_internal_id() const {
  const ::maa::Id* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Id&>(
      ::maa::_Id_default_instance_);
}
inline const ::maa::Id& IdResponse::id() const {
  // @@protoc_insertion_point(field_get:maa.IdResponse.id)
  return _internal_id();
}
inline void IdResponse::unsafe_arena_set_allocated_id(
    ::maa::Id* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.IdResponse.id)
}
inline ::maa::Id* IdResponse::release_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Id* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Id* IdResponse::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:maa.IdResponse.id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Id* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::maa::Id* IdResponse::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Id>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::maa::Id* IdResponse::mutable_id() {
  ::maa::Id* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:maa.IdResponse.id)
  return _msg;
}
inline void IdResponse::set_allocated_id(::maa::Id* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:maa.IdResponse.id)
}

// optional .maa.RpcStatus status = 101;
inline bool IdResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline bool IdResponse::has_status() const {
  return _internal_has_status();
}
inline void IdResponse::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maa::RpcStatus& IdResponse::_internal_status() const {
  const ::maa::RpcStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::RpcStatus&>(
      ::maa::_RpcStatus_default_instance_);
}
inline const ::maa::RpcStatus& IdResponse::status() const {
  // @@protoc_insertion_point(field_get:maa.IdResponse.status)
  return _internal_status();
}
inline void IdResponse::unsafe_arena_set_allocated_status(
    ::maa::RpcStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.IdResponse.status)
}
inline ::maa::RpcStatus* IdResponse::release_status() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::RpcStatus* IdResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:maa.IdResponse.status)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::maa::RpcStatus* IdResponse::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::RpcStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::maa::RpcStatus* IdResponse::mutable_status() {
  ::maa::RpcStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:maa.IdResponse.status)
  return _msg;
}
inline void IdResponse::set_allocated_status(::maa::RpcStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:maa.IdResponse.status)
}

// -------------------------------------------------------------------

// BoolResponse

// optional bool value = 1;
inline bool BoolResponse::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BoolResponse::has_value() const {
  return _internal_has_value();
}
inline void BoolResponse::clear_value() {
  _impl_.value_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool BoolResponse::_internal_value() const {
  return _impl_.value_;
}
inline bool BoolResponse::value() const {
  // @@protoc_insertion_point(field_get:maa.BoolResponse.value)
  return _internal_value();
}
inline void BoolResponse::_internal_set_value(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}
inline void BoolResponse::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:maa.BoolResponse.value)
}

// optional .maa.RpcStatus status = 101;
inline bool BoolResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline bool BoolResponse::has_status() const {
  return _internal_has_status();
}
inline void BoolResponse::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::RpcStatus& BoolResponse::_internal_status() const {
  const ::maa::RpcStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::RpcStatus&>(
      ::maa::_RpcStatus_default_instance_);
}
inline const ::maa::RpcStatus& BoolResponse::status() const {
  // @@protoc_insertion_point(field_get:maa.BoolResponse.status)
  return _internal_status();
}
inline void BoolResponse::unsafe_arena_set_allocated_status(
    ::maa::RpcStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.BoolResponse.status)
}
inline ::maa::RpcStatus* BoolResponse::release_status() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::RpcStatus* BoolResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:maa.BoolResponse.status)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::maa::RpcStatus* BoolResponse::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::RpcStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::maa::RpcStatus* BoolResponse::mutable_status() {
  ::maa::RpcStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:maa.BoolResponse.status)
  return _msg;
}
inline void BoolResponse::set_allocated_status(::maa::RpcStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:maa.BoolResponse.status)
}

// -------------------------------------------------------------------

// StringResponse

// optional string value = 1;
inline bool StringResponse::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StringResponse::has_value() const {
  return _internal_has_value();
}
inline void StringResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringResponse::value() const {
  // @@protoc_insertion_point(field_get:maa.StringResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringResponse::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maa.StringResponse.value)
}
inline std::string* StringResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:maa.StringResponse.value)
  return _s;
}
inline const std::string& StringResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void StringResponse::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* StringResponse::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* StringResponse::release_value() {
  // @@protoc_insertion_point(field_release:maa.StringResponse.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StringResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maa.StringResponse.value)
}

// optional .maa.RpcStatus status = 101;
inline bool StringResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline bool StringResponse::has_status() const {
  return _internal_has_status();
}
inline void StringResponse::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maa::RpcStatus& StringResponse::_internal_status() const {
  const ::maa::RpcStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::RpcStatus&>(
      ::maa::_RpcStatus_default_instance_);
}
inline const ::maa::RpcStatus& StringResponse::status() const {
  // @@protoc_insertion_point(field_get:maa.StringResponse.status)
  return _internal_status();
}
inline void StringResponse::unsafe_arena_set_allocated_status(
    ::maa::RpcStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.StringResponse.status)
}
inline ::maa::RpcStatus* StringResponse::release_status() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::RpcStatus* StringResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:maa.StringResponse.status)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::maa::RpcStatus* StringResponse::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::RpcStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::maa::RpcStatus* StringResponse::mutable_status() {
  ::maa::RpcStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:maa.StringResponse.status)
  return _msg;
}
inline void StringResponse::set_allocated_status(::maa::RpcStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:maa.StringResponse.status)
}

// -------------------------------------------------------------------

// HandleResponse

// optional .maa.Handle value = 1;
inline bool HandleResponse::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline bool HandleResponse::has_value() const {
  return _internal_has_value();
}
inline void HandleResponse::clear_value() {
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::Handle& HandleResponse::_internal_value() const {
  const ::maa::Handle* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::Handle&>(
      ::maa::_Handle_default_instance_);
}
inline const ::maa::Handle& HandleResponse::value() const {
  // @@protoc_insertion_point(field_get:maa.HandleResponse.value)
  return _internal_value();
}
inline void HandleResponse::unsafe_arena_set_allocated_value(
    ::maa::Handle* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.HandleResponse.value)
}
inline ::maa::Handle* HandleResponse::release_value() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Handle* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::Handle* HandleResponse::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:maa.HandleResponse.value)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::Handle* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::maa::Handle* HandleResponse::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::Handle>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::maa::Handle* HandleResponse::mutable_value() {
  ::maa::Handle* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:maa.HandleResponse.value)
  return _msg;
}
inline void HandleResponse::set_allocated_value(::maa::Handle* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:maa.HandleResponse.value)
}

// optional .maa.RpcStatus status = 101;
inline bool HandleResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline bool HandleResponse::has_status() const {
  return _internal_has_status();
}
inline void HandleResponse::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maa::RpcStatus& HandleResponse::_internal_status() const {
  const ::maa::RpcStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::RpcStatus&>(
      ::maa::_RpcStatus_default_instance_);
}
inline const ::maa::RpcStatus& HandleResponse::status() const {
  // @@protoc_insertion_point(field_get:maa.HandleResponse.status)
  return _internal_status();
}
inline void HandleResponse::unsafe_arena_set_allocated_status(
    ::maa::RpcStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.HandleResponse.status)
}
inline ::maa::RpcStatus* HandleResponse::release_status() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::RpcStatus* HandleResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:maa.HandleResponse.status)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::maa::RpcStatus* HandleResponse::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::RpcStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::maa::RpcStatus* HandleResponse::mutable_status() {
  ::maa::RpcStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:maa.HandleResponse.status)
  return _msg;
}
inline void HandleResponse::set_allocated_status(::maa::RpcStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:maa.HandleResponse.status)
}

// -------------------------------------------------------------------

// BufferResponse

// optional bytes value = 1;
inline bool BufferResponse::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BufferResponse::has_value() const {
  return _internal_has_value();
}
inline void BufferResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BufferResponse::value() const {
  // @@protoc_insertion_point(field_get:maa.BufferResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BufferResponse::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maa.BufferResponse.value)
}
inline std::string* BufferResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:maa.BufferResponse.value)
  return _s;
}
inline const std::string& BufferResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void BufferResponse::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* BufferResponse::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* BufferResponse::release_value() {
  // @@protoc_insertion_point(field_release:maa.BufferResponse.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BufferResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maa.BufferResponse.value)
}

// optional .maa.RpcStatus status = 101;
inline bool BufferResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline bool BufferResponse::has_status() const {
  return _internal_has_status();
}
inline void BufferResponse::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::maa::RpcStatus& BufferResponse::_internal_status() const {
  const ::maa::RpcStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::RpcStatus&>(
      ::maa::_RpcStatus_default_instance_);
}
inline const ::maa::RpcStatus& BufferResponse::status() const {
  // @@protoc_insertion_point(field_get:maa.BufferResponse.status)
  return _internal_status();
}
inline void BufferResponse::unsafe_arena_set_allocated_status(
    ::maa::RpcStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.BufferResponse.status)
}
inline ::maa::RpcStatus* BufferResponse::release_status() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::RpcStatus* BufferResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:maa.BufferResponse.status)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::maa::RpcStatus* BufferResponse::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::RpcStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::maa::RpcStatus* BufferResponse::mutable_status() {
  ::maa::RpcStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:maa.BufferResponse.status)
  return _msg;
}
inline void BufferResponse::set_allocated_status(::maa::RpcStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:maa.BufferResponse.status)
}

// -------------------------------------------------------------------

// StatusResponse

// optional .maa.Status value = 1;
inline bool StatusResponse::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatusResponse::has_value() const {
  return _internal_has_value();
}
inline void StatusResponse::clear_value() {
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::maa::Status StatusResponse::_internal_value() const {
  return static_cast< ::maa::Status >(_impl_.value_);
}
inline ::maa::Status StatusResponse::value() const {
  // @@protoc_insertion_point(field_get:maa.StatusResponse.value)
  return _internal_value();
}
inline void StatusResponse::_internal_set_value(::maa::Status value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}
inline void StatusResponse::set_value(::maa::Status value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:maa.StatusResponse.value)
}

// optional .maa.RpcStatus status = 101;
inline bool StatusResponse::_internal_has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
  return value;
}
inline bool StatusResponse::has_status() const {
  return _internal_has_status();
}
inline void StatusResponse::clear_status() {
  if (_impl_.status_ != nullptr) _impl_.status_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::maa::RpcStatus& StatusResponse::_internal_status() const {
  const ::maa::RpcStatus* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::maa::RpcStatus&>(
      ::maa::_RpcStatus_default_instance_);
}
inline const ::maa::RpcStatus& StatusResponse::status() const {
  // @@protoc_insertion_point(field_get:maa.StatusResponse.status)
  return _internal_status();
}
inline void StatusResponse::unsafe_arena_set_allocated_status(
    ::maa::RpcStatus* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maa.StatusResponse.status)
}
inline ::maa::RpcStatus* StatusResponse::release_status() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maa::RpcStatus* StatusResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:maa.StatusResponse.status)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::maa::RpcStatus* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::maa::RpcStatus* StatusResponse::_internal_mutable_status() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::maa::RpcStatus>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::maa::RpcStatus* StatusResponse::mutable_status() {
  ::maa::RpcStatus* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:maa.StatusResponse.status)
  return _msg;
}
inline void StatusResponse::set_allocated_status(::maa::RpcStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:maa.StatusResponse.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace maa

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::maa::Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::maa::Status>() {
  return ::maa::Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Types_2eproto
