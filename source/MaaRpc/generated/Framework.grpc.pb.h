// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: Framework.proto
#ifndef GRPC_Framework_2eproto__INCLUDED
#define GRPC_Framework_2eproto__INCLUDED

#include "Framework.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace maa {

class MaaFramework final {
 public:
  static constexpr char const* service_full_name() {
    return "maa.MaaFramework";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status version(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::maa::StringResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>> Asyncversion(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>>(AsyncversionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>> PrepareAsyncversion(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>>(PrepareAsyncversionRaw(context, request, cq));
    }
    virtual ::grpc::Status set_global_option(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest& request, ::maa::BoolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> Asyncset_global_option(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(Asyncset_global_optionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> PrepareAsyncset_global_option(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(PrepareAsyncset_global_optionRaw(context, request, cq));
    }
    virtual ::grpc::Status acquire_callback_id(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::maa::IdResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>> Asyncacquire_callback_id(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>>(Asyncacquire_callback_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>> PrepareAsyncacquire_callback_id(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>>(PrepareAsyncacquire_callback_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::maa::Callback>> register_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::maa::Callback>>(register_callbackRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::maa::Callback>> Asyncregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::maa::Callback>>(Asyncregister_callbackRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::maa::Callback>> PrepareAsyncregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::maa::Callback>>(PrepareAsyncregister_callbackRaw(context, request, cq));
    }
    virtual ::grpc::Status unregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::maa::BoolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> Asyncunregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(Asyncunregister_callbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> PrepareAsyncunregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(PrepareAsyncunregister_callbackRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void version(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::StringResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void version(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::StringResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void set_global_option(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_global_option(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void acquire_callback_id(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::IdResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void acquire_callback_id(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::IdResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void register_callback(::grpc::ClientContext* context, const ::maa::IdRequest* request, ::grpc::ClientReadReactor< ::maa::Callback>* reactor) = 0;
      virtual void unregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void unregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>* AsyncversionRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>* PrepareAsyncversionRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* Asyncset_global_optionRaw(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* PrepareAsyncset_global_optionRaw(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>* Asyncacquire_callback_idRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>* PrepareAsyncacquire_callback_idRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::maa::Callback>* register_callbackRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::maa::Callback>* Asyncregister_callbackRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::maa::Callback>* PrepareAsyncregister_callbackRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* Asyncunregister_callbackRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* PrepareAsyncunregister_callbackRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status version(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::maa::StringResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>> Asyncversion(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>>(AsyncversionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>> PrepareAsyncversion(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>>(PrepareAsyncversionRaw(context, request, cq));
    }
    ::grpc::Status set_global_option(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest& request, ::maa::BoolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> Asyncset_global_option(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(Asyncset_global_optionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> PrepareAsyncset_global_option(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(PrepareAsyncset_global_optionRaw(context, request, cq));
    }
    ::grpc::Status acquire_callback_id(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::maa::IdResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>> Asyncacquire_callback_id(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>>(Asyncacquire_callback_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>> PrepareAsyncacquire_callback_id(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>>(PrepareAsyncacquire_callback_idRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::maa::Callback>> register_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::maa::Callback>>(register_callbackRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::maa::Callback>> Asyncregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::maa::Callback>>(Asyncregister_callbackRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::maa::Callback>> PrepareAsyncregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::maa::Callback>>(PrepareAsyncregister_callbackRaw(context, request, cq));
    }
    ::grpc::Status unregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::maa::BoolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> Asyncunregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(Asyncunregister_callbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> PrepareAsyncunregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(PrepareAsyncunregister_callbackRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void version(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::StringResponse* response, std::function<void(::grpc::Status)>) override;
      void version(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::StringResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_global_option(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) override;
      void set_global_option(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void acquire_callback_id(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::IdResponse* response, std::function<void(::grpc::Status)>) override;
      void acquire_callback_id(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::IdResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void register_callback(::grpc::ClientContext* context, const ::maa::IdRequest* request, ::grpc::ClientReadReactor< ::maa::Callback>* reactor) override;
      void unregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) override;
      void unregister_callback(::grpc::ClientContext* context, const ::maa::IdRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>* AsyncversionRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>* PrepareAsyncversionRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* Asyncset_global_optionRaw(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* PrepareAsyncset_global_optionRaw(::grpc::ClientContext* context, const ::maa::SetGlobalOptionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>* Asyncacquire_callback_idRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>* PrepareAsyncacquire_callback_idRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::maa::Callback>* register_callbackRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request) override;
    ::grpc::ClientAsyncReader< ::maa::Callback>* Asyncregister_callbackRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::maa::Callback>* PrepareAsyncregister_callbackRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* Asyncunregister_callbackRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* PrepareAsyncunregister_callbackRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_version_;
    const ::grpc::internal::RpcMethod rpcmethod_set_global_option_;
    const ::grpc::internal::RpcMethod rpcmethod_acquire_callback_id_;
    const ::grpc::internal::RpcMethod rpcmethod_register_callback_;
    const ::grpc::internal::RpcMethod rpcmethod_unregister_callback_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status version(::grpc::ServerContext* context, const ::maa::EmptyRequest* request, ::maa::StringResponse* response);
    virtual ::grpc::Status set_global_option(::grpc::ServerContext* context, const ::maa::SetGlobalOptionRequest* request, ::maa::BoolResponse* response);
    virtual ::grpc::Status acquire_callback_id(::grpc::ServerContext* context, const ::maa::EmptyRequest* request, ::maa::IdResponse* response);
    virtual ::grpc::Status register_callback(::grpc::ServerContext* context, const ::maa::IdRequest* request, ::grpc::ServerWriter< ::maa::Callback>* writer);
    virtual ::grpc::Status unregister_callback(::grpc::ServerContext* context, const ::maa::IdRequest* request, ::maa::BoolResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_version() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status version(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestversion(::grpc::ServerContext* context, ::maa::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::StringResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_global_option : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_global_option() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_set_global_option() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_global_option(::grpc::ServerContext* /*context*/, const ::maa::SetGlobalOptionRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_global_option(::grpc::ServerContext* context, ::maa::SetGlobalOptionRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::BoolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_acquire_callback_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_acquire_callback_id() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_acquire_callback_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status acquire_callback_id(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestacquire_callback_id(::grpc::ServerContext* context, ::maa::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::IdResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_register_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_register_callback() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_register_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status register_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::grpc::ServerWriter< ::maa::Callback>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestregister_callback(::grpc::ServerContext* context, ::maa::IdRequest* request, ::grpc::ServerAsyncWriter< ::maa::Callback>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_unregister_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_unregister_callback() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_unregister_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unregister_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestunregister_callback(::grpc::ServerContext* context, ::maa::IdRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::BoolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_version<WithAsyncMethod_set_global_option<WithAsyncMethod_acquire_callback_id<WithAsyncMethod_register_callback<WithAsyncMethod_unregister_callback<Service > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_version() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::EmptyRequest, ::maa::StringResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::EmptyRequest* request, ::maa::StringResponse* response) { return this->version(context, request, response); }));}
    void SetMessageAllocatorFor_version(
        ::grpc::MessageAllocator< ::maa::EmptyRequest, ::maa::StringResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::EmptyRequest, ::maa::StringResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status version(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* version(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::StringResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_global_option : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_global_option() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::SetGlobalOptionRequest, ::maa::BoolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::SetGlobalOptionRequest* request, ::maa::BoolResponse* response) { return this->set_global_option(context, request, response); }));}
    void SetMessageAllocatorFor_set_global_option(
        ::grpc::MessageAllocator< ::maa::SetGlobalOptionRequest, ::maa::BoolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::SetGlobalOptionRequest, ::maa::BoolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_global_option() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_global_option(::grpc::ServerContext* /*context*/, const ::maa::SetGlobalOptionRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_global_option(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::SetGlobalOptionRequest* /*request*/, ::maa::BoolResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_acquire_callback_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_acquire_callback_id() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::EmptyRequest, ::maa::IdResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::EmptyRequest* request, ::maa::IdResponse* response) { return this->acquire_callback_id(context, request, response); }));}
    void SetMessageAllocatorFor_acquire_callback_id(
        ::grpc::MessageAllocator< ::maa::EmptyRequest, ::maa::IdResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::EmptyRequest, ::maa::IdResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_acquire_callback_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status acquire_callback_id(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* acquire_callback_id(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::IdResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_register_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_register_callback() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::maa::IdRequest, ::maa::Callback>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::IdRequest* request) { return this->register_callback(context, request); }));
    }
    ~WithCallbackMethod_register_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status register_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::grpc::ServerWriter< ::maa::Callback>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::maa::Callback>* register_callback(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::IdRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_unregister_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_unregister_callback() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::IdRequest, ::maa::BoolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::IdRequest* request, ::maa::BoolResponse* response) { return this->unregister_callback(context, request, response); }));}
    void SetMessageAllocatorFor_unregister_callback(
        ::grpc::MessageAllocator< ::maa::IdRequest, ::maa::BoolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::IdRequest, ::maa::BoolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_unregister_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unregister_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* unregister_callback(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::BoolResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_version<WithCallbackMethod_set_global_option<WithCallbackMethod_acquire_callback_id<WithCallbackMethod_register_callback<WithCallbackMethod_unregister_callback<Service > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_version() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status version(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_global_option : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_global_option() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_set_global_option() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_global_option(::grpc::ServerContext* /*context*/, const ::maa::SetGlobalOptionRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_acquire_callback_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_acquire_callback_id() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_acquire_callback_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status acquire_callback_id(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_register_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_register_callback() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_register_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status register_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::grpc::ServerWriter< ::maa::Callback>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_unregister_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_unregister_callback() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_unregister_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unregister_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_version() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status version(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestversion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_global_option : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_global_option() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_set_global_option() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_global_option(::grpc::ServerContext* /*context*/, const ::maa::SetGlobalOptionRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_global_option(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_acquire_callback_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_acquire_callback_id() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_acquire_callback_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status acquire_callback_id(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestacquire_callback_id(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_register_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_register_callback() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_register_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status register_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::grpc::ServerWriter< ::maa::Callback>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestregister_callback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_unregister_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_unregister_callback() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_unregister_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unregister_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestunregister_callback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_version() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->version(context, request, response); }));
    }
    ~WithRawCallbackMethod_version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status version(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* version(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_global_option : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_global_option() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_global_option(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_global_option() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_global_option(::grpc::ServerContext* /*context*/, const ::maa::SetGlobalOptionRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_global_option(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_acquire_callback_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_acquire_callback_id() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->acquire_callback_id(context, request, response); }));
    }
    ~WithRawCallbackMethod_acquire_callback_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status acquire_callback_id(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* acquire_callback_id(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_register_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_register_callback() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->register_callback(context, request); }));
    }
    ~WithRawCallbackMethod_register_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status register_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::grpc::ServerWriter< ::maa::Callback>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* register_callback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_unregister_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_unregister_callback() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->unregister_callback(context, request, response); }));
    }
    ~WithRawCallbackMethod_unregister_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status unregister_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* unregister_callback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_version : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_version() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::EmptyRequest, ::maa::StringResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::EmptyRequest, ::maa::StringResponse>* streamer) {
                       return this->Streamedversion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_version() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status version(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedversion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::EmptyRequest,::maa::StringResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_global_option : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_global_option() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::SetGlobalOptionRequest, ::maa::BoolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::SetGlobalOptionRequest, ::maa::BoolResponse>* streamer) {
                       return this->Streamedset_global_option(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_global_option() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_global_option(::grpc::ServerContext* /*context*/, const ::maa::SetGlobalOptionRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_global_option(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::SetGlobalOptionRequest,::maa::BoolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_acquire_callback_id : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_acquire_callback_id() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::EmptyRequest, ::maa::IdResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::EmptyRequest, ::maa::IdResponse>* streamer) {
                       return this->Streamedacquire_callback_id(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_acquire_callback_id() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status acquire_callback_id(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedacquire_callback_id(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::EmptyRequest,::maa::IdResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_unregister_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_unregister_callback() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::IdRequest, ::maa::BoolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::IdRequest, ::maa::BoolResponse>* streamer) {
                       return this->Streamedunregister_callback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_unregister_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status unregister_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedunregister_callback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::IdRequest,::maa::BoolResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_version<WithStreamedUnaryMethod_set_global_option<WithStreamedUnaryMethod_acquire_callback_id<WithStreamedUnaryMethod_unregister_callback<Service > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_register_callback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_register_callback() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::maa::IdRequest, ::maa::Callback>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::maa::IdRequest, ::maa::Callback>* streamer) {
                       return this->Streamedregister_callback(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_register_callback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status register_callback(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::grpc::ServerWriter< ::maa::Callback>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedregister_callback(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::maa::IdRequest,::maa::Callback>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_register_callback<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_version<WithStreamedUnaryMethod_set_global_option<WithStreamedUnaryMethod_acquire_callback_id<WithSplitStreamingMethod_register_callback<WithStreamedUnaryMethod_unregister_callback<Service > > > > > StreamedService;
};

//
// service MaaFrameworkString {
// rpc create(EmptyRequest) returns (HandleResponse);
// rpc destroy(HandleRequest) returns (EmptyResponse);
// rpc is_empty(HandleRequest) returns (BoolResponse);
// rpc clear(HandleRequest) returns (BoolResponse);
// rpc get(HandleRequest) returns (BufferResponse);
// rpc set(BufferRequest) returns (BoolResponse);
// }
//
class MaaFrameworkImage final {
 public:
  static constexpr char const* service_full_name() {
    return "maa.MaaFrameworkImage";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status create(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::maa::HandleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>> Asynccreate(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>>(AsynccreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>> PrepareAsynccreate(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>>(PrepareAsynccreateRaw(context, request, cq));
    }
    virtual ::grpc::Status destroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>> Asyncdestroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>>(AsyncdestroyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>> PrepareAsyncdestroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>>(PrepareAsyncdestroyRaw(context, request, cq));
    }
    virtual ::grpc::Status is_empty(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::BoolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> Asyncis_empty(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(Asyncis_emptyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> PrepareAsyncis_empty(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(PrepareAsyncis_emptyRaw(context, request, cq));
    }
    virtual ::grpc::Status clear(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::BoolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> Asyncclear(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(AsyncclearRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> PrepareAsyncclear(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(PrepareAsyncclearRaw(context, request, cq));
    }
    virtual ::grpc::Status info(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::ImageInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::ImageInfoResponse>> Asyncinfo(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::ImageInfoResponse>>(AsyncinfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::ImageInfoResponse>> PrepareAsyncinfo(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::ImageInfoResponse>>(PrepareAsyncinfoRaw(context, request, cq));
    }
    virtual ::grpc::Status get_encoded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::BufferResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BufferResponse>> Asyncget_encoded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BufferResponse>>(Asyncget_encodedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BufferResponse>> PrepareAsyncget_encoded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BufferResponse>>(PrepareAsyncget_encodedRaw(context, request, cq));
    }
    virtual ::grpc::Status set_encoded(::grpc::ClientContext* context, const ::maa::HandleBufferRequest& request, ::maa::BoolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> Asyncset_encoded(::grpc::ClientContext* context, const ::maa::HandleBufferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(Asyncset_encodedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> PrepareAsyncset_encoded(::grpc::ClientContext* context, const ::maa::HandleBufferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(PrepareAsyncset_encodedRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void create(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::HandleResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::HandleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void destroy(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void destroy(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void is_empty(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void is_empty(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void clear(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clear(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void info(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::ImageInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void info(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::ImageInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void get_encoded(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BufferResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_encoded(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BufferResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void set_encoded(::grpc::ClientContext* context, const ::maa::HandleBufferRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void set_encoded(::grpc::ClientContext* context, const ::maa::HandleBufferRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>* AsynccreateRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>* PrepareAsynccreateRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>* AsyncdestroyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>* PrepareAsyncdestroyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* Asyncis_emptyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* PrepareAsyncis_emptyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* AsyncclearRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* PrepareAsyncclearRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::ImageInfoResponse>* AsyncinfoRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::ImageInfoResponse>* PrepareAsyncinfoRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BufferResponse>* Asyncget_encodedRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BufferResponse>* PrepareAsyncget_encodedRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* Asyncset_encodedRaw(::grpc::ClientContext* context, const ::maa::HandleBufferRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* PrepareAsyncset_encodedRaw(::grpc::ClientContext* context, const ::maa::HandleBufferRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status create(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::maa::HandleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>> Asynccreate(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>>(AsynccreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>> PrepareAsynccreate(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>>(PrepareAsynccreateRaw(context, request, cq));
    }
    ::grpc::Status destroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>> Asyncdestroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>>(AsyncdestroyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>> PrepareAsyncdestroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>>(PrepareAsyncdestroyRaw(context, request, cq));
    }
    ::grpc::Status is_empty(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::BoolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> Asyncis_empty(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(Asyncis_emptyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> PrepareAsyncis_empty(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(PrepareAsyncis_emptyRaw(context, request, cq));
    }
    ::grpc::Status clear(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::BoolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> Asyncclear(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(AsyncclearRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> PrepareAsyncclear(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(PrepareAsyncclearRaw(context, request, cq));
    }
    ::grpc::Status info(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::ImageInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::ImageInfoResponse>> Asyncinfo(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::ImageInfoResponse>>(AsyncinfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::ImageInfoResponse>> PrepareAsyncinfo(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::ImageInfoResponse>>(PrepareAsyncinfoRaw(context, request, cq));
    }
    ::grpc::Status get_encoded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::BufferResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BufferResponse>> Asyncget_encoded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BufferResponse>>(Asyncget_encodedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BufferResponse>> PrepareAsyncget_encoded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BufferResponse>>(PrepareAsyncget_encodedRaw(context, request, cq));
    }
    ::grpc::Status set_encoded(::grpc::ClientContext* context, const ::maa::HandleBufferRequest& request, ::maa::BoolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> Asyncset_encoded(::grpc::ClientContext* context, const ::maa::HandleBufferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(Asyncset_encodedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> PrepareAsyncset_encoded(::grpc::ClientContext* context, const ::maa::HandleBufferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(PrepareAsyncset_encodedRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void create(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::HandleResponse* response, std::function<void(::grpc::Status)>) override;
      void create(::grpc::ClientContext* context, const ::maa::EmptyRequest* request, ::maa::HandleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void destroy(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void destroy(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void is_empty(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) override;
      void is_empty(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clear(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) override;
      void clear(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void info(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::ImageInfoResponse* response, std::function<void(::grpc::Status)>) override;
      void info(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::ImageInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_encoded(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BufferResponse* response, std::function<void(::grpc::Status)>) override;
      void get_encoded(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BufferResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void set_encoded(::grpc::ClientContext* context, const ::maa::HandleBufferRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) override;
      void set_encoded(::grpc::ClientContext* context, const ::maa::HandleBufferRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>* AsynccreateRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>* PrepareAsynccreateRaw(::grpc::ClientContext* context, const ::maa::EmptyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>* AsyncdestroyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>* PrepareAsyncdestroyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* Asyncis_emptyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* PrepareAsyncis_emptyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* AsyncclearRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* PrepareAsyncclearRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::ImageInfoResponse>* AsyncinfoRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::ImageInfoResponse>* PrepareAsyncinfoRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BufferResponse>* Asyncget_encodedRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BufferResponse>* PrepareAsyncget_encodedRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* Asyncset_encodedRaw(::grpc::ClientContext* context, const ::maa::HandleBufferRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* PrepareAsyncset_encodedRaw(::grpc::ClientContext* context, const ::maa::HandleBufferRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_create_;
    const ::grpc::internal::RpcMethod rpcmethod_destroy_;
    const ::grpc::internal::RpcMethod rpcmethod_is_empty_;
    const ::grpc::internal::RpcMethod rpcmethod_clear_;
    const ::grpc::internal::RpcMethod rpcmethod_info_;
    const ::grpc::internal::RpcMethod rpcmethod_get_encoded_;
    const ::grpc::internal::RpcMethod rpcmethod_set_encoded_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status create(::grpc::ServerContext* context, const ::maa::EmptyRequest* request, ::maa::HandleResponse* response);
    virtual ::grpc::Status destroy(::grpc::ServerContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response);
    virtual ::grpc::Status is_empty(::grpc::ServerContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response);
    virtual ::grpc::Status clear(::grpc::ServerContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response);
    virtual ::grpc::Status info(::grpc::ServerContext* context, const ::maa::HandleRequest* request, ::maa::ImageInfoResponse* response);
    virtual ::grpc::Status get_encoded(::grpc::ServerContext* context, const ::maa::HandleRequest* request, ::maa::BufferResponse* response);
    virtual ::grpc::Status set_encoded(::grpc::ServerContext* context, const ::maa::HandleBufferRequest* request, ::maa::BoolResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_create() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate(::grpc::ServerContext* context, ::maa::EmptyRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::HandleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_destroy() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdestroy(::grpc::ServerContext* context, ::maa::HandleRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_is_empty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_is_empty() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_is_empty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status is_empty(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestis_empty(::grpc::ServerContext* context, ::maa::HandleRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::BoolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clear() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclear(::grpc::ServerContext* context, ::maa::HandleRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::BoolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_info() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::ImageInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinfo(::grpc::ServerContext* context, ::maa::HandleRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::ImageInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_encoded() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_get_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BufferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_encoded(::grpc::ServerContext* context, ::maa::HandleRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::BufferResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_set_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_set_encoded() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_set_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleBufferRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_encoded(::grpc::ServerContext* context, ::maa::HandleBufferRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::BoolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_create<WithAsyncMethod_destroy<WithAsyncMethod_is_empty<WithAsyncMethod_clear<WithAsyncMethod_info<WithAsyncMethod_get_encoded<WithAsyncMethod_set_encoded<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_create() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::EmptyRequest, ::maa::HandleResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::EmptyRequest* request, ::maa::HandleResponse* response) { return this->create(context, request, response); }));}
    void SetMessageAllocatorFor_create(
        ::grpc::MessageAllocator< ::maa::EmptyRequest, ::maa::HandleResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::EmptyRequest, ::maa::HandleResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::HandleResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_destroy() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response) { return this->destroy(context, request, response); }));}
    void SetMessageAllocatorFor_destroy(
        ::grpc::MessageAllocator< ::maa::HandleRequest, ::maa::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* destroy(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_is_empty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_is_empty() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::BoolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response) { return this->is_empty(context, request, response); }));}
    void SetMessageAllocatorFor_is_empty(
        ::grpc::MessageAllocator< ::maa::HandleRequest, ::maa::BoolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::BoolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_is_empty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status is_empty(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* is_empty(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clear() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::BoolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response) { return this->clear(context, request, response); }));}
    void SetMessageAllocatorFor_clear(
        ::grpc::MessageAllocator< ::maa::HandleRequest, ::maa::BoolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::BoolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clear(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_info() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::ImageInfoResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleRequest* request, ::maa::ImageInfoResponse* response) { return this->info(context, request, response); }));}
    void SetMessageAllocatorFor_info(
        ::grpc::MessageAllocator< ::maa::HandleRequest, ::maa::ImageInfoResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::ImageInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::ImageInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* info(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::ImageInfoResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_encoded() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::BufferResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleRequest* request, ::maa::BufferResponse* response) { return this->get_encoded(context, request, response); }));}
    void SetMessageAllocatorFor_get_encoded(
        ::grpc::MessageAllocator< ::maa::HandleRequest, ::maa::BufferResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::BufferResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BufferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_encoded(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BufferResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_set_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_set_encoded() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleBufferRequest, ::maa::BoolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleBufferRequest* request, ::maa::BoolResponse* response) { return this->set_encoded(context, request, response); }));}
    void SetMessageAllocatorFor_set_encoded(
        ::grpc::MessageAllocator< ::maa::HandleBufferRequest, ::maa::BoolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleBufferRequest, ::maa::BoolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_set_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleBufferRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_encoded(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleBufferRequest* /*request*/, ::maa::BoolResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_create<WithCallbackMethod_destroy<WithCallbackMethod_is_empty<WithCallbackMethod_clear<WithCallbackMethod_info<WithCallbackMethod_get_encoded<WithCallbackMethod_set_encoded<Service > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_create() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_destroy() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_is_empty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_is_empty() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_is_empty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status is_empty(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clear() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_info() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::ImageInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_encoded() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_get_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BufferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_set_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_set_encoded() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_set_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleBufferRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_create() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_destroy() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdestroy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_is_empty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_is_empty() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_is_empty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status is_empty(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestis_empty(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clear() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestclear(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_info() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::ImageInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_encoded() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_get_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BufferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_encoded(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_set_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_set_encoded() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_set_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleBufferRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestset_encoded(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_create() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->create(context, request, response); }));
    }
    ~WithRawCallbackMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_destroy() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->destroy(context, request, response); }));
    }
    ~WithRawCallbackMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* destroy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_is_empty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_is_empty() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->is_empty(context, request, response); }));
    }
    ~WithRawCallbackMethod_is_empty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status is_empty(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* is_empty(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clear() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clear(context, request, response); }));
    }
    ~WithRawCallbackMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clear(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_info() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->info(context, request, response); }));
    }
    ~WithRawCallbackMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::ImageInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_encoded() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_encoded(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BufferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_encoded(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_set_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_set_encoded() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->set_encoded(context, request, response); }));
    }
    ~WithRawCallbackMethod_set_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status set_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleBufferRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* set_encoded(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_create() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::EmptyRequest, ::maa::HandleResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::EmptyRequest, ::maa::HandleResponse>* streamer) {
                       return this->Streamedcreate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::EmptyRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcreate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::EmptyRequest,::maa::HandleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_destroy() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleRequest, ::maa::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleRequest, ::maa::EmptyResponse>* streamer) {
                       return this->Streameddestroy(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddestroy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleRequest,::maa::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_is_empty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_is_empty() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleRequest, ::maa::BoolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleRequest, ::maa::BoolResponse>* streamer) {
                       return this->Streamedis_empty(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_is_empty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status is_empty(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedis_empty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleRequest,::maa::BoolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clear : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clear() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleRequest, ::maa::BoolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleRequest, ::maa::BoolResponse>* streamer) {
                       return this->Streamedclear(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clear() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clear(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedclear(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleRequest,::maa::BoolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_info() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleRequest, ::maa::ImageInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleRequest, ::maa::ImageInfoResponse>* streamer) {
                       return this->Streamedinfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status info(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::ImageInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedinfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleRequest,::maa::ImageInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_encoded() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleRequest, ::maa::BufferResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleRequest, ::maa::BufferResponse>* streamer) {
                       return this->Streamedget_encoded(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BufferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_encoded(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleRequest,::maa::BufferResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_set_encoded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_set_encoded() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleBufferRequest, ::maa::BoolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleBufferRequest, ::maa::BoolResponse>* streamer) {
                       return this->Streamedset_encoded(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_set_encoded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status set_encoded(::grpc::ServerContext* /*context*/, const ::maa::HandleBufferRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedset_encoded(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleBufferRequest,::maa::BoolResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_create<WithStreamedUnaryMethod_destroy<WithStreamedUnaryMethod_is_empty<WithStreamedUnaryMethod_clear<WithStreamedUnaryMethod_info<WithStreamedUnaryMethod_get_encoded<WithStreamedUnaryMethod_set_encoded<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_create<WithStreamedUnaryMethod_destroy<WithStreamedUnaryMethod_is_empty<WithStreamedUnaryMethod_clear<WithStreamedUnaryMethod_info<WithStreamedUnaryMethod_get_encoded<WithStreamedUnaryMethod_set_encoded<Service > > > > > > > StreamedService;
};

class MaaFrameworkResource final {
 public:
  static constexpr char const* service_full_name() {
    return "maa.MaaFrameworkResource";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status create(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::maa::HandleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>> Asynccreate(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>>(AsynccreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>> PrepareAsynccreate(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>>(PrepareAsynccreateRaw(context, request, cq));
    }
    virtual ::grpc::Status destroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::EmptyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>> Asyncdestroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>>(AsyncdestroyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>> PrepareAsyncdestroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>>(PrepareAsyncdestroyRaw(context, request, cq));
    }
    virtual ::grpc::Status post_path(::grpc::ClientContext* context, const ::maa::HandleStringRequest& request, ::maa::IdResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>> Asyncpost_path(::grpc::ClientContext* context, const ::maa::HandleStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>>(Asyncpost_pathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>> PrepareAsyncpost_path(::grpc::ClientContext* context, const ::maa::HandleStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>>(PrepareAsyncpost_pathRaw(context, request, cq));
    }
    virtual ::grpc::Status status(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::maa::StatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>> Asyncstatus(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>>(AsyncstatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>> PrepareAsyncstatus(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>>(PrepareAsyncstatusRaw(context, request, cq));
    }
    virtual ::grpc::Status wait(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::maa::StatusResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>> Asyncwait(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>>(AsyncwaitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>> PrepareAsyncwait(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>>(PrepareAsyncwaitRaw(context, request, cq));
    }
    virtual ::grpc::Status loaded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::BoolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> Asyncloaded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(AsyncloadedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>> PrepareAsyncloaded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>>(PrepareAsyncloadedRaw(context, request, cq));
    }
    virtual ::grpc::Status hash(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::StringResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>> Asynchash(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>>(AsynchashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>> PrepareAsynchash(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>>(PrepareAsynchashRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void create(::grpc::ClientContext* context, const ::maa::IdRequest* request, ::maa::HandleResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void create(::grpc::ClientContext* context, const ::maa::IdRequest* request, ::maa::HandleResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void destroy(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void destroy(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void post_path(::grpc::ClientContext* context, const ::maa::HandleStringRequest* request, ::maa::IdResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void post_path(::grpc::ClientContext* context, const ::maa::HandleStringRequest* request, ::maa::IdResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void status(::grpc::ClientContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void status(::grpc::ClientContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void wait(::grpc::ClientContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void wait(::grpc::ClientContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void loaded(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void loaded(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void hash(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::StringResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void hash(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::StringResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>* AsynccreateRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::HandleResponse>* PrepareAsynccreateRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>* AsyncdestroyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::EmptyResponse>* PrepareAsyncdestroyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>* Asyncpost_pathRaw(::grpc::ClientContext* context, const ::maa::HandleStringRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::IdResponse>* PrepareAsyncpost_pathRaw(::grpc::ClientContext* context, const ::maa::HandleStringRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>* AsyncstatusRaw(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>* PrepareAsyncstatusRaw(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>* AsyncwaitRaw(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::StatusResponse>* PrepareAsyncwaitRaw(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* AsyncloadedRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::BoolResponse>* PrepareAsyncloadedRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>* AsynchashRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::maa::StringResponse>* PrepareAsynchashRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status create(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::maa::HandleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>> Asynccreate(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>>(AsynccreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>> PrepareAsynccreate(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>>(PrepareAsynccreateRaw(context, request, cq));
    }
    ::grpc::Status destroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::EmptyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>> Asyncdestroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>>(AsyncdestroyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>> PrepareAsyncdestroy(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>>(PrepareAsyncdestroyRaw(context, request, cq));
    }
    ::grpc::Status post_path(::grpc::ClientContext* context, const ::maa::HandleStringRequest& request, ::maa::IdResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>> Asyncpost_path(::grpc::ClientContext* context, const ::maa::HandleStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>>(Asyncpost_pathRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>> PrepareAsyncpost_path(::grpc::ClientContext* context, const ::maa::HandleStringRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>>(PrepareAsyncpost_pathRaw(context, request, cq));
    }
    ::grpc::Status status(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::maa::StatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>> Asyncstatus(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>>(AsyncstatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>> PrepareAsyncstatus(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>>(PrepareAsyncstatusRaw(context, request, cq));
    }
    ::grpc::Status wait(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::maa::StatusResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>> Asyncwait(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>>(AsyncwaitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>> PrepareAsyncwait(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>>(PrepareAsyncwaitRaw(context, request, cq));
    }
    ::grpc::Status loaded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::BoolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> Asyncloaded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(AsyncloadedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>> PrepareAsyncloaded(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>>(PrepareAsyncloadedRaw(context, request, cq));
    }
    ::grpc::Status hash(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::maa::StringResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>> Asynchash(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>>(AsynchashRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>> PrepareAsynchash(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>>(PrepareAsynchashRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void create(::grpc::ClientContext* context, const ::maa::IdRequest* request, ::maa::HandleResponse* response, std::function<void(::grpc::Status)>) override;
      void create(::grpc::ClientContext* context, const ::maa::IdRequest* request, ::maa::HandleResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void destroy(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response, std::function<void(::grpc::Status)>) override;
      void destroy(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void post_path(::grpc::ClientContext* context, const ::maa::HandleStringRequest* request, ::maa::IdResponse* response, std::function<void(::grpc::Status)>) override;
      void post_path(::grpc::ClientContext* context, const ::maa::HandleStringRequest* request, ::maa::IdResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void status(::grpc::ClientContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response, std::function<void(::grpc::Status)>) override;
      void status(::grpc::ClientContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void wait(::grpc::ClientContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response, std::function<void(::grpc::Status)>) override;
      void wait(::grpc::ClientContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void loaded(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, std::function<void(::grpc::Status)>) override;
      void loaded(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void hash(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::StringResponse* response, std::function<void(::grpc::Status)>) override;
      void hash(::grpc::ClientContext* context, const ::maa::HandleRequest* request, ::maa::StringResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>* AsynccreateRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::HandleResponse>* PrepareAsynccreateRaw(::grpc::ClientContext* context, const ::maa::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>* AsyncdestroyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::EmptyResponse>* PrepareAsyncdestroyRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>* Asyncpost_pathRaw(::grpc::ClientContext* context, const ::maa::HandleStringRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::IdResponse>* PrepareAsyncpost_pathRaw(::grpc::ClientContext* context, const ::maa::HandleStringRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>* AsyncstatusRaw(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>* PrepareAsyncstatusRaw(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>* AsyncwaitRaw(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::StatusResponse>* PrepareAsyncwaitRaw(::grpc::ClientContext* context, const ::maa::HandleIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* AsyncloadedRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::BoolResponse>* PrepareAsyncloadedRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>* AsynchashRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::maa::StringResponse>* PrepareAsynchashRaw(::grpc::ClientContext* context, const ::maa::HandleRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_create_;
    const ::grpc::internal::RpcMethod rpcmethod_destroy_;
    const ::grpc::internal::RpcMethod rpcmethod_post_path_;
    const ::grpc::internal::RpcMethod rpcmethod_status_;
    const ::grpc::internal::RpcMethod rpcmethod_wait_;
    const ::grpc::internal::RpcMethod rpcmethod_loaded_;
    const ::grpc::internal::RpcMethod rpcmethod_hash_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status create(::grpc::ServerContext* context, const ::maa::IdRequest* request, ::maa::HandleResponse* response);
    virtual ::grpc::Status destroy(::grpc::ServerContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response);
    virtual ::grpc::Status post_path(::grpc::ServerContext* context, const ::maa::HandleStringRequest* request, ::maa::IdResponse* response);
    virtual ::grpc::Status status(::grpc::ServerContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response);
    virtual ::grpc::Status wait(::grpc::ServerContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response);
    virtual ::grpc::Status loaded(::grpc::ServerContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response);
    virtual ::grpc::Status hash(::grpc::ServerContext* context, const ::maa::HandleRequest* request, ::maa::StringResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_create() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate(::grpc::ServerContext* context, ::maa::IdRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::HandleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_destroy() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdestroy(::grpc::ServerContext* context, ::maa::HandleRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::EmptyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_post_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_post_path() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_post_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status post_path(::grpc::ServerContext* /*context*/, const ::maa::HandleStringRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpost_path(::grpc::ServerContext* context, ::maa::HandleStringRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::IdResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_status() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststatus(::grpc::ServerContext* context, ::maa::HandleIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::StatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_wait() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status wait(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwait(::grpc::ServerContext* context, ::maa::HandleIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::StatusResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_loaded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_loaded() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_loaded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loaded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestloaded(::grpc::ServerContext* context, ::maa::HandleRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::BoolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_hash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_hash() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_hash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hash(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthash(::grpc::ServerContext* context, ::maa::HandleRequest* request, ::grpc::ServerAsyncResponseWriter< ::maa::StringResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_create<WithAsyncMethod_destroy<WithAsyncMethod_post_path<WithAsyncMethod_status<WithAsyncMethod_wait<WithAsyncMethod_loaded<WithAsyncMethod_hash<Service > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_create() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::IdRequest, ::maa::HandleResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::IdRequest* request, ::maa::HandleResponse* response) { return this->create(context, request, response); }));}
    void SetMessageAllocatorFor_create(
        ::grpc::MessageAllocator< ::maa::IdRequest, ::maa::HandleResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::IdRequest, ::maa::HandleResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::HandleResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_destroy() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::EmptyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleRequest* request, ::maa::EmptyResponse* response) { return this->destroy(context, request, response); }));}
    void SetMessageAllocatorFor_destroy(
        ::grpc::MessageAllocator< ::maa::HandleRequest, ::maa::EmptyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::EmptyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* destroy(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_post_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_post_path() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleStringRequest, ::maa::IdResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleStringRequest* request, ::maa::IdResponse* response) { return this->post_path(context, request, response); }));}
    void SetMessageAllocatorFor_post_path(
        ::grpc::MessageAllocator< ::maa::HandleStringRequest, ::maa::IdResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleStringRequest, ::maa::IdResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_post_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status post_path(::grpc::ServerContext* /*context*/, const ::maa::HandleStringRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* post_path(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleStringRequest* /*request*/, ::maa::IdResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_status() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleIdRequest, ::maa::StatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response) { return this->status(context, request, response); }));}
    void SetMessageAllocatorFor_status(
        ::grpc::MessageAllocator< ::maa::HandleIdRequest, ::maa::StatusResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleIdRequest, ::maa::StatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* status(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_wait() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleIdRequest, ::maa::StatusResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleIdRequest* request, ::maa::StatusResponse* response) { return this->wait(context, request, response); }));}
    void SetMessageAllocatorFor_wait(
        ::grpc::MessageAllocator< ::maa::HandleIdRequest, ::maa::StatusResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleIdRequest, ::maa::StatusResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status wait(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* wait(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_loaded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_loaded() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::BoolResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleRequest* request, ::maa::BoolResponse* response) { return this->loaded(context, request, response); }));}
    void SetMessageAllocatorFor_loaded(
        ::grpc::MessageAllocator< ::maa::HandleRequest, ::maa::BoolResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::BoolResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_loaded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loaded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* loaded(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_hash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_hash() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::StringResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::maa::HandleRequest* request, ::maa::StringResponse* response) { return this->hash(context, request, response); }));}
    void SetMessageAllocatorFor_hash(
        ::grpc::MessageAllocator< ::maa::HandleRequest, ::maa::StringResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::maa::HandleRequest, ::maa::StringResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_hash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hash(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hash(
      ::grpc::CallbackServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::StringResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_create<WithCallbackMethod_destroy<WithCallbackMethod_post_path<WithCallbackMethod_status<WithCallbackMethod_wait<WithCallbackMethod_loaded<WithCallbackMethod_hash<Service > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_create() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_destroy() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_post_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_post_path() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_post_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status post_path(::grpc::ServerContext* /*context*/, const ::maa::HandleStringRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_status() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_wait() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status wait(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_loaded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_loaded() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_loaded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loaded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_hash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_hash() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_hash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hash(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_create() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcreate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_destroy() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdestroy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_post_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_post_path() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_post_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status post_path(::grpc::ServerContext* /*context*/, const ::maa::HandleStringRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpost_path(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_status() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requeststatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_wait() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status wait(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestwait(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_loaded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_loaded() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_loaded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loaded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestloaded(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_hash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_hash() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_hash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hash(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesthash(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_create() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->create(context, request, response); }));
    }
    ~WithRawCallbackMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* create(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_destroy() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->destroy(context, request, response); }));
    }
    ~WithRawCallbackMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* destroy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_post_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_post_path() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->post_path(context, request, response); }));
    }
    ~WithRawCallbackMethod_post_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status post_path(::grpc::ServerContext* /*context*/, const ::maa::HandleStringRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* post_path(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_status() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->status(context, request, response); }));
    }
    ~WithRawCallbackMethod_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* status(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_wait() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->wait(context, request, response); }));
    }
    ~WithRawCallbackMethod_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status wait(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* wait(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_loaded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_loaded() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->loaded(context, request, response); }));
    }
    ~WithRawCallbackMethod_loaded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status loaded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* loaded(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_hash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_hash() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->hash(context, request, response); }));
    }
    ~WithRawCallbackMethod_hash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status hash(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* hash(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_create() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::IdRequest, ::maa::HandleResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::IdRequest, ::maa::HandleResponse>* streamer) {
                       return this->Streamedcreate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status create(::grpc::ServerContext* /*context*/, const ::maa::IdRequest* /*request*/, ::maa::HandleResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcreate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::IdRequest,::maa::HandleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_destroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_destroy() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleRequest, ::maa::EmptyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleRequest, ::maa::EmptyResponse>* streamer) {
                       return this->Streameddestroy(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_destroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status destroy(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::EmptyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddestroy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleRequest,::maa::EmptyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_post_path : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_post_path() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleStringRequest, ::maa::IdResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleStringRequest, ::maa::IdResponse>* streamer) {
                       return this->Streamedpost_path(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_post_path() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status post_path(::grpc::ServerContext* /*context*/, const ::maa::HandleStringRequest* /*request*/, ::maa::IdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedpost_path(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleStringRequest,::maa::IdResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_status : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_status() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleIdRequest, ::maa::StatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleIdRequest, ::maa::StatusResponse>* streamer) {
                       return this->Streamedstatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_status() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status status(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedstatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleIdRequest,::maa::StatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_wait : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_wait() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleIdRequest, ::maa::StatusResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleIdRequest, ::maa::StatusResponse>* streamer) {
                       return this->Streamedwait(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_wait() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status wait(::grpc::ServerContext* /*context*/, const ::maa::HandleIdRequest* /*request*/, ::maa::StatusResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedwait(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleIdRequest,::maa::StatusResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_loaded : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_loaded() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleRequest, ::maa::BoolResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleRequest, ::maa::BoolResponse>* streamer) {
                       return this->Streamedloaded(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_loaded() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status loaded(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::BoolResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedloaded(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleRequest,::maa::BoolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_hash : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_hash() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::maa::HandleRequest, ::maa::StringResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::maa::HandleRequest, ::maa::StringResponse>* streamer) {
                       return this->Streamedhash(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_hash() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status hash(::grpc::ServerContext* /*context*/, const ::maa::HandleRequest* /*request*/, ::maa::StringResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedhash(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::maa::HandleRequest,::maa::StringResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_create<WithStreamedUnaryMethod_destroy<WithStreamedUnaryMethod_post_path<WithStreamedUnaryMethod_status<WithStreamedUnaryMethod_wait<WithStreamedUnaryMethod_loaded<WithStreamedUnaryMethod_hash<Service > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_create<WithStreamedUnaryMethod_destroy<WithStreamedUnaryMethod_post_path<WithStreamedUnaryMethod_status<WithStreamedUnaryMethod_wait<WithStreamedUnaryMethod_loaded<WithStreamedUnaryMethod_hash<Service > > > > > > > StreamedService;
};

}  // namespace maa


#endif  // GRPC_Framework_2eproto__INCLUDED
