// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: custom.controller.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_custom_2econtroller_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_custom_2econtroller_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_custom_2econtroller_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_custom_2econtroller_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_custom_2econtroller_2eproto;
namespace maarpc {
class CustomControllerInit;
struct CustomControllerInitDefaultTypeInternal;
extern CustomControllerInitDefaultTypeInternal _CustomControllerInit_default_instance_;
class CustomControllerRequest;
struct CustomControllerRequestDefaultTypeInternal;
extern CustomControllerRequestDefaultTypeInternal _CustomControllerRequest_default_instance_;
class CustomControllerResponse;
struct CustomControllerResponseDefaultTypeInternal;
extern CustomControllerResponseDefaultTypeInternal _CustomControllerResponse_default_instance_;
class CustomControllerSetOptionParam;
struct CustomControllerSetOptionParamDefaultTypeInternal;
extern CustomControllerSetOptionParamDefaultTypeInternal _CustomControllerSetOptionParam_default_instance_;
class CustomControllerSubmit;
struct CustomControllerSubmitDefaultTypeInternal;
extern CustomControllerSubmitDefaultTypeInternal _CustomControllerSubmit_default_instance_;
}  // namespace maarpc
PROTOBUF_NAMESPACE_OPEN
template<> ::maarpc::CustomControllerInit* Arena::CreateMaybeMessage<::maarpc::CustomControllerInit>(Arena*);
template<> ::maarpc::CustomControllerRequest* Arena::CreateMaybeMessage<::maarpc::CustomControllerRequest>(Arena*);
template<> ::maarpc::CustomControllerResponse* Arena::CreateMaybeMessage<::maarpc::CustomControllerResponse>(Arena*);
template<> ::maarpc::CustomControllerSetOptionParam* Arena::CreateMaybeMessage<::maarpc::CustomControllerSetOptionParam>(Arena*);
template<> ::maarpc::CustomControllerSubmit* Arena::CreateMaybeMessage<::maarpc::CustomControllerSubmit>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace maarpc {

// ===================================================================

class CustomControllerSetOptionParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.CustomControllerSetOptionParam) */ {
 public:
  inline CustomControllerSetOptionParam() : CustomControllerSetOptionParam(nullptr) {}
  ~CustomControllerSetOptionParam() override;
  explicit PROTOBUF_CONSTEXPR CustomControllerSetOptionParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomControllerSetOptionParam(const CustomControllerSetOptionParam& from);
  CustomControllerSetOptionParam(CustomControllerSetOptionParam&& from) noexcept
    : CustomControllerSetOptionParam() {
    *this = ::std::move(from);
  }

  inline CustomControllerSetOptionParam& operator=(const CustomControllerSetOptionParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomControllerSetOptionParam& operator=(CustomControllerSetOptionParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomControllerSetOptionParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomControllerSetOptionParam* internal_default_instance() {
    return reinterpret_cast<const CustomControllerSetOptionParam*>(
               &_CustomControllerSetOptionParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CustomControllerSetOptionParam& a, CustomControllerSetOptionParam& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomControllerSetOptionParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomControllerSetOptionParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomControllerSetOptionParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomControllerSetOptionParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomControllerSetOptionParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomControllerSetOptionParam& from) {
    CustomControllerSetOptionParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomControllerSetOptionParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.CustomControllerSetOptionParam";
  }
  protected:
  explicit CustomControllerSetOptionParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional int32 key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.CustomControllerSetOptionParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int32_t key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_custom_2econtroller_2eproto;
};
// -------------------------------------------------------------------

class CustomControllerInit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.CustomControllerInit) */ {
 public:
  inline CustomControllerInit() : CustomControllerInit(nullptr) {}
  ~CustomControllerInit() override;
  explicit PROTOBUF_CONSTEXPR CustomControllerInit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomControllerInit(const CustomControllerInit& from);
  CustomControllerInit(CustomControllerInit&& from) noexcept
    : CustomControllerInit() {
    *this = ::std::move(from);
  }

  inline CustomControllerInit& operator=(const CustomControllerInit& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomControllerInit& operator=(CustomControllerInit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomControllerInit& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomControllerInit* internal_default_instance() {
    return reinterpret_cast<const CustomControllerInit*>(
               &_CustomControllerInit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CustomControllerInit& a, CustomControllerInit& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomControllerInit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomControllerInit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomControllerInit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomControllerInit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomControllerInit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomControllerInit& from) {
    CustomControllerInit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomControllerInit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.CustomControllerInit";
  }
  protected:
  explicit CustomControllerInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCtrlIdFieldNumber = 2,
  };
  // optional string id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string ctrl_id = 2;
  bool has_ctrl_id() const;
  private:
  bool _internal_has_ctrl_id() const;
  public:
  void clear_ctrl_id();
  const std::string& ctrl_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ctrl_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ctrl_id();
  PROTOBUF_NODISCARD std::string* release_ctrl_id();
  void set_allocated_ctrl_id(std::string* ctrl_id);
  private:
  const std::string& _internal_ctrl_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ctrl_id(const std::string& value);
  std::string* _internal_mutable_ctrl_id();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.CustomControllerInit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ctrl_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_custom_2econtroller_2eproto;
};
// -------------------------------------------------------------------

class CustomControllerSubmit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.CustomControllerSubmit) */ {
 public:
  inline CustomControllerSubmit() : CustomControllerSubmit(nullptr) {}
  ~CustomControllerSubmit() override;
  explicit PROTOBUF_CONSTEXPR CustomControllerSubmit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomControllerSubmit(const CustomControllerSubmit& from);
  CustomControllerSubmit(CustomControllerSubmit&& from) noexcept
    : CustomControllerSubmit() {
    *this = ::std::move(from);
  }

  inline CustomControllerSubmit& operator=(const CustomControllerSubmit& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomControllerSubmit& operator=(CustomControllerSubmit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomControllerSubmit& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kResolution = 101,
    kUuid = 102,
    RESULT_NOT_SET = 0,
  };

  static inline const CustomControllerSubmit* internal_default_instance() {
    return reinterpret_cast<const CustomControllerSubmit*>(
               &_CustomControllerSubmit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CustomControllerSubmit& a, CustomControllerSubmit& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomControllerSubmit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomControllerSubmit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomControllerSubmit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomControllerSubmit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomControllerSubmit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomControllerSubmit& from) {
    CustomControllerSubmit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomControllerSubmit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.CustomControllerSubmit";
  }
  protected:
  explicit CustomControllerSubmit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kCmdIdFieldNumber = 2,
    kOkFieldNumber = 3,
    kResolutionFieldNumber = 101,
    kUuidFieldNumber = 102,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional string cmd_id = 2;
  bool has_cmd_id() const;
  private:
  bool _internal_has_cmd_id() const;
  public:
  void clear_cmd_id();
  const std::string& cmd_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cmd_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cmd_id();
  PROTOBUF_NODISCARD std::string* release_cmd_id();
  void set_allocated_cmd_id(std::string* cmd_id);
  private:
  const std::string& _internal_cmd_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd_id(const std::string& value);
  std::string* _internal_mutable_cmd_id();
  public:

  // optional bool ok = 3;
  bool has_ok() const;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // .maarpc.Size resolution = 101;
  bool has_resolution() const;
  private:
  bool _internal_has_resolution() const;
  public:
  void clear_resolution();
  const ::maarpc::Size& resolution() const;
  PROTOBUF_NODISCARD ::maarpc::Size* release_resolution();
  ::maarpc::Size* mutable_resolution();
  void set_allocated_resolution(::maarpc::Size* resolution);
  private:
  const ::maarpc::Size& _internal_resolution() const;
  ::maarpc::Size* _internal_mutable_resolution();
  public:
  void unsafe_arena_set_allocated_resolution(
      ::maarpc::Size* resolution);
  ::maarpc::Size* unsafe_arena_release_resolution();

  // string uuid = 102;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:maarpc.CustomControllerSubmit)
 private:
  class _Internal;
  void set_has_resolution();
  void set_has_uuid();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_id_;
    bool ok_;
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::maarpc::Size* resolution_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    } result_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_custom_2econtroller_2eproto;
};
// -------------------------------------------------------------------

class CustomControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.CustomControllerRequest) */ {
 public:
  inline CustomControllerRequest() : CustomControllerRequest(nullptr) {}
  ~CustomControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR CustomControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomControllerRequest(const CustomControllerRequest& from);
  CustomControllerRequest(CustomControllerRequest&& from) noexcept
    : CustomControllerRequest() {
    *this = ::std::move(from);
  }

  inline CustomControllerRequest& operator=(const CustomControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomControllerRequest& operator=(CustomControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kInit = 1,
    kSubmit = 2,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const CustomControllerRequest* internal_default_instance() {
    return reinterpret_cast<const CustomControllerRequest*>(
               &_CustomControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CustomControllerRequest& a, CustomControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomControllerRequest& from) {
    CustomControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.CustomControllerRequest";
  }
  protected:
  explicit CustomControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitFieldNumber = 1,
    kSubmitFieldNumber = 2,
  };
  // .maarpc.CustomControllerInit init = 1;
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const ::maarpc::CustomControllerInit& init() const;
  PROTOBUF_NODISCARD ::maarpc::CustomControllerInit* release_init();
  ::maarpc::CustomControllerInit* mutable_init();
  void set_allocated_init(::maarpc::CustomControllerInit* init);
  private:
  const ::maarpc::CustomControllerInit& _internal_init() const;
  ::maarpc::CustomControllerInit* _internal_mutable_init();
  public:
  void unsafe_arena_set_allocated_init(
      ::maarpc::CustomControllerInit* init);
  ::maarpc::CustomControllerInit* unsafe_arena_release_init();

  // .maarpc.CustomControllerSubmit submit = 2;
  bool has_submit() const;
  private:
  bool _internal_has_submit() const;
  public:
  void clear_submit();
  const ::maarpc::CustomControllerSubmit& submit() const;
  PROTOBUF_NODISCARD ::maarpc::CustomControllerSubmit* release_submit();
  ::maarpc::CustomControllerSubmit* mutable_submit();
  void set_allocated_submit(::maarpc::CustomControllerSubmit* submit);
  private:
  const ::maarpc::CustomControllerSubmit& _internal_submit() const;
  ::maarpc::CustomControllerSubmit* _internal_mutable_submit();
  public:
  void unsafe_arena_set_allocated_submit(
      ::maarpc::CustomControllerSubmit* submit);
  ::maarpc::CustomControllerSubmit* unsafe_arena_release_submit();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:maarpc.CustomControllerRequest)
 private:
  class _Internal;
  void set_has_init();
  void set_has_submit();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::maarpc::CustomControllerInit* init_;
      ::maarpc::CustomControllerSubmit* submit_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_custom_2econtroller_2eproto;
};
// -------------------------------------------------------------------

class CustomControllerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.CustomControllerResponse) */ {
 public:
  inline CustomControllerResponse() : CustomControllerResponse(nullptr) {}
  ~CustomControllerResponse() override;
  explicit PROTOBUF_CONSTEXPR CustomControllerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomControllerResponse(const CustomControllerResponse& from);
  CustomControllerResponse(CustomControllerResponse&& from) noexcept
    : CustomControllerResponse() {
    *this = ::std::move(from);
  }

  inline CustomControllerResponse& operator=(const CustomControllerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomControllerResponse& operator=(CustomControllerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomControllerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kConnect = 101,
    kClick = 102,
    kSwipe = 103,
    kKey = 104,
    kTouchDown = 105,
    kTouchMove = 106,
    kTouchUp = 107,
    kStart = 108,
    kStop = 109,
    kResolution = 110,
    kImage = 111,
    kUuid = 112,
    kSetOption = 200,
    COMMAND_NOT_SET = 0,
  };

  static inline const CustomControllerResponse* internal_default_instance() {
    return reinterpret_cast<const CustomControllerResponse*>(
               &_CustomControllerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CustomControllerResponse& a, CustomControllerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomControllerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomControllerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomControllerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomControllerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomControllerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomControllerResponse& from) {
    CustomControllerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomControllerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.CustomControllerResponse";
  }
  protected:
  explicit CustomControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlIdFieldNumber = 1,
    kCmdIdFieldNumber = 2,
    kConnectFieldNumber = 101,
    kClickFieldNumber = 102,
    kSwipeFieldNumber = 103,
    kKeyFieldNumber = 104,
    kTouchDownFieldNumber = 105,
    kTouchMoveFieldNumber = 106,
    kTouchUpFieldNumber = 107,
    kStartFieldNumber = 108,
    kStopFieldNumber = 109,
    kResolutionFieldNumber = 110,
    kImageFieldNumber = 111,
    kUuidFieldNumber = 112,
    kSetOptionFieldNumber = 200,
  };
  // optional string ctrl_id = 1;
  bool has_ctrl_id() const;
  private:
  bool _internal_has_ctrl_id() const;
  public:
  void clear_ctrl_id();
  const std::string& ctrl_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ctrl_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ctrl_id();
  PROTOBUF_NODISCARD std::string* release_ctrl_id();
  void set_allocated_ctrl_id(std::string* ctrl_id);
  private:
  const std::string& _internal_ctrl_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ctrl_id(const std::string& value);
  std::string* _internal_mutable_ctrl_id();
  public:

  // optional string cmd_id = 2;
  bool has_cmd_id() const;
  private:
  bool _internal_has_cmd_id() const;
  public:
  void clear_cmd_id();
  const std::string& cmd_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cmd_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cmd_id();
  PROTOBUF_NODISCARD std::string* release_cmd_id();
  void set_allocated_cmd_id(std::string* cmd_id);
  private:
  const std::string& _internal_cmd_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd_id(const std::string& value);
  std::string* _internal_mutable_cmd_id();
  public:

  // bool connect = 101;
  bool has_connect() const;
  private:
  bool _internal_has_connect() const;
  public:
  void clear_connect();
  bool connect() const;
  void set_connect(bool value);
  private:
  bool _internal_connect() const;
  void _internal_set_connect(bool value);
  public:

  // .maarpc.ClickParam click = 102;
  bool has_click() const;
  private:
  bool _internal_has_click() const;
  public:
  void clear_click();
  const ::maarpc::ClickParam& click() const;
  PROTOBUF_NODISCARD ::maarpc::ClickParam* release_click();
  ::maarpc::ClickParam* mutable_click();
  void set_allocated_click(::maarpc::ClickParam* click);
  private:
  const ::maarpc::ClickParam& _internal_click() const;
  ::maarpc::ClickParam* _internal_mutable_click();
  public:
  void unsafe_arena_set_allocated_click(
      ::maarpc::ClickParam* click);
  ::maarpc::ClickParam* unsafe_arena_release_click();

  // .maarpc.SwipeParam swipe = 103;
  bool has_swipe() const;
  private:
  bool _internal_has_swipe() const;
  public:
  void clear_swipe();
  const ::maarpc::SwipeParam& swipe() const;
  PROTOBUF_NODISCARD ::maarpc::SwipeParam* release_swipe();
  ::maarpc::SwipeParam* mutable_swipe();
  void set_allocated_swipe(::maarpc::SwipeParam* swipe);
  private:
  const ::maarpc::SwipeParam& _internal_swipe() const;
  ::maarpc::SwipeParam* _internal_mutable_swipe();
  public:
  void unsafe_arena_set_allocated_swipe(
      ::maarpc::SwipeParam* swipe);
  ::maarpc::SwipeParam* unsafe_arena_release_swipe();

  // .maarpc.KeyParam key = 104;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::maarpc::KeyParam& key() const;
  PROTOBUF_NODISCARD ::maarpc::KeyParam* release_key();
  ::maarpc::KeyParam* mutable_key();
  void set_allocated_key(::maarpc::KeyParam* key);
  private:
  const ::maarpc::KeyParam& _internal_key() const;
  ::maarpc::KeyParam* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::maarpc::KeyParam* key);
  ::maarpc::KeyParam* unsafe_arena_release_key();

  // .maarpc.TouchParam touch_down = 105;
  bool has_touch_down() const;
  private:
  bool _internal_has_touch_down() const;
  public:
  void clear_touch_down();
  const ::maarpc::TouchParam& touch_down() const;
  PROTOBUF_NODISCARD ::maarpc::TouchParam* release_touch_down();
  ::maarpc::TouchParam* mutable_touch_down();
  void set_allocated_touch_down(::maarpc::TouchParam* touch_down);
  private:
  const ::maarpc::TouchParam& _internal_touch_down() const;
  ::maarpc::TouchParam* _internal_mutable_touch_down();
  public:
  void unsafe_arena_set_allocated_touch_down(
      ::maarpc::TouchParam* touch_down);
  ::maarpc::TouchParam* unsafe_arena_release_touch_down();

  // .maarpc.TouchParam touch_move = 106;
  bool has_touch_move() const;
  private:
  bool _internal_has_touch_move() const;
  public:
  void clear_touch_move();
  const ::maarpc::TouchParam& touch_move() const;
  PROTOBUF_NODISCARD ::maarpc::TouchParam* release_touch_move();
  ::maarpc::TouchParam* mutable_touch_move();
  void set_allocated_touch_move(::maarpc::TouchParam* touch_move);
  private:
  const ::maarpc::TouchParam& _internal_touch_move() const;
  ::maarpc::TouchParam* _internal_mutable_touch_move();
  public:
  void unsafe_arena_set_allocated_touch_move(
      ::maarpc::TouchParam* touch_move);
  ::maarpc::TouchParam* unsafe_arena_release_touch_move();

  // .maarpc.TouchParam touch_up = 107;
  bool has_touch_up() const;
  private:
  bool _internal_has_touch_up() const;
  public:
  void clear_touch_up();
  const ::maarpc::TouchParam& touch_up() const;
  PROTOBUF_NODISCARD ::maarpc::TouchParam* release_touch_up();
  ::maarpc::TouchParam* mutable_touch_up();
  void set_allocated_touch_up(::maarpc::TouchParam* touch_up);
  private:
  const ::maarpc::TouchParam& _internal_touch_up() const;
  ::maarpc::TouchParam* _internal_mutable_touch_up();
  public:
  void unsafe_arena_set_allocated_touch_up(
      ::maarpc::TouchParam* touch_up);
  ::maarpc::TouchParam* unsafe_arena_release_touch_up();

  // string start = 108;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const std::string& start() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start();
  PROTOBUF_NODISCARD std::string* release_start();
  void set_allocated_start(std::string* start);
  private:
  const std::string& _internal_start() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start(const std::string& value);
  std::string* _internal_mutable_start();
  public:

  // string stop = 109;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;
  public:
  void clear_stop();
  const std::string& stop() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop();
  PROTOBUF_NODISCARD std::string* release_stop();
  void set_allocated_stop(std::string* stop);
  private:
  const std::string& _internal_stop() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop(const std::string& value);
  std::string* _internal_mutable_stop();
  public:

  // bool resolution = 110;
  bool has_resolution() const;
  private:
  bool _internal_has_resolution() const;
  public:
  void clear_resolution();
  bool resolution() const;
  void set_resolution(bool value);
  private:
  bool _internal_resolution() const;
  void _internal_set_resolution(bool value);
  public:

  // string image = 111;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // bool uuid = 112;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  bool uuid() const;
  void set_uuid(bool value);
  private:
  bool _internal_uuid() const;
  void _internal_set_uuid(bool value);
  public:

  // .maarpc.CustomControllerSetOptionParam set_option = 200;
  bool has_set_option() const;
  private:
  bool _internal_has_set_option() const;
  public:
  void clear_set_option();
  const ::maarpc::CustomControllerSetOptionParam& set_option() const;
  PROTOBUF_NODISCARD ::maarpc::CustomControllerSetOptionParam* release_set_option();
  ::maarpc::CustomControllerSetOptionParam* mutable_set_option();
  void set_allocated_set_option(::maarpc::CustomControllerSetOptionParam* set_option);
  private:
  const ::maarpc::CustomControllerSetOptionParam& _internal_set_option() const;
  ::maarpc::CustomControllerSetOptionParam* _internal_mutable_set_option();
  public:
  void unsafe_arena_set_allocated_set_option(
      ::maarpc::CustomControllerSetOptionParam* set_option);
  ::maarpc::CustomControllerSetOptionParam* unsafe_arena_release_set_option();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:maarpc.CustomControllerResponse)
 private:
  class _Internal;
  void set_has_connect();
  void set_has_click();
  void set_has_swipe();
  void set_has_key();
  void set_has_touch_down();
  void set_has_touch_move();
  void set_has_touch_up();
  void set_has_start();
  void set_has_stop();
  void set_has_resolution();
  void set_has_image();
  void set_has_uuid();
  void set_has_set_option();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ctrl_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cmd_id_;
    union CommandUnion {
      constexpr CommandUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool connect_;
      ::maarpc::ClickParam* click_;
      ::maarpc::SwipeParam* swipe_;
      ::maarpc::KeyParam* key_;
      ::maarpc::TouchParam* touch_down_;
      ::maarpc::TouchParam* touch_move_;
      ::maarpc::TouchParam* touch_up_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_;
      bool resolution_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
      bool uuid_;
      ::maarpc::CustomControllerSetOptionParam* set_option_;
    } command_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_custom_2econtroller_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CustomControllerSetOptionParam

// optional int32 key = 1;
inline bool CustomControllerSetOptionParam::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CustomControllerSetOptionParam::has_key() const {
  return _internal_has_key();
}
inline void CustomControllerSetOptionParam::clear_key() {
  _impl_.key_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CustomControllerSetOptionParam::_internal_key() const {
  return _impl_.key_;
}
inline int32_t CustomControllerSetOptionParam::key() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerSetOptionParam.key)
  return _internal_key();
}
inline void CustomControllerSetOptionParam::_internal_set_key(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.key_ = value;
}
inline void CustomControllerSetOptionParam::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerSetOptionParam.key)
}

// optional string value = 2;
inline bool CustomControllerSetOptionParam::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CustomControllerSetOptionParam::has_value() const {
  return _internal_has_value();
}
inline void CustomControllerSetOptionParam::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomControllerSetOptionParam::value() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerSetOptionParam.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomControllerSetOptionParam::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerSetOptionParam.value)
}
inline std::string* CustomControllerSetOptionParam::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerSetOptionParam.value)
  return _s;
}
inline const std::string& CustomControllerSetOptionParam::_internal_value() const {
  return _impl_.value_.Get();
}
inline void CustomControllerSetOptionParam::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerSetOptionParam::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomControllerSetOptionParam::release_value() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerSetOptionParam.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomControllerSetOptionParam::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerSetOptionParam.value)
}

// -------------------------------------------------------------------

// CustomControllerInit

// optional string id = 1;
inline bool CustomControllerInit::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CustomControllerInit::has_id() const {
  return _internal_has_id();
}
inline void CustomControllerInit::clear_id() {
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomControllerInit::id() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerInit.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomControllerInit::set_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerInit.id)
}
inline std::string* CustomControllerInit::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerInit.id)
  return _s;
}
inline const std::string& CustomControllerInit::_internal_id() const {
  return _impl_.id_.Get();
}
inline void CustomControllerInit::_internal_set_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerInit::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomControllerInit::release_id() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerInit.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomControllerInit::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerInit.id)
}

// optional string ctrl_id = 2;
inline bool CustomControllerInit::_internal_has_ctrl_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CustomControllerInit::has_ctrl_id() const {
  return _internal_has_ctrl_id();
}
inline void CustomControllerInit::clear_ctrl_id() {
  _impl_.ctrl_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CustomControllerInit::ctrl_id() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerInit.ctrl_id)
  return _internal_ctrl_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomControllerInit::set_ctrl_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.ctrl_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerInit.ctrl_id)
}
inline std::string* CustomControllerInit::mutable_ctrl_id() {
  std::string* _s = _internal_mutable_ctrl_id();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerInit.ctrl_id)
  return _s;
}
inline const std::string& CustomControllerInit::_internal_ctrl_id() const {
  return _impl_.ctrl_id_.Get();
}
inline void CustomControllerInit::_internal_set_ctrl_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ctrl_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerInit::_internal_mutable_ctrl_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.ctrl_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomControllerInit::release_ctrl_id() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerInit.ctrl_id)
  if (!_internal_has_ctrl_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.ctrl_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ctrl_id_.IsDefault()) {
    _impl_.ctrl_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomControllerInit::set_allocated_ctrl_id(std::string* ctrl_id) {
  if (ctrl_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.ctrl_id_.SetAllocated(ctrl_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ctrl_id_.IsDefault()) {
    _impl_.ctrl_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerInit.ctrl_id)
}

// -------------------------------------------------------------------

// CustomControllerSubmit

// optional string handle = 1;
inline bool CustomControllerSubmit::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CustomControllerSubmit::has_handle() const {
  return _internal_has_handle();
}
inline void CustomControllerSubmit::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomControllerSubmit::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerSubmit.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomControllerSubmit::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerSubmit.handle)
}
inline std::string* CustomControllerSubmit::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerSubmit.handle)
  return _s;
}
inline const std::string& CustomControllerSubmit::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void CustomControllerSubmit::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerSubmit::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomControllerSubmit::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerSubmit.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomControllerSubmit::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerSubmit.handle)
}

// optional string cmd_id = 2;
inline bool CustomControllerSubmit::_internal_has_cmd_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CustomControllerSubmit::has_cmd_id() const {
  return _internal_has_cmd_id();
}
inline void CustomControllerSubmit::clear_cmd_id() {
  _impl_.cmd_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CustomControllerSubmit::cmd_id() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerSubmit.cmd_id)
  return _internal_cmd_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomControllerSubmit::set_cmd_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.cmd_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerSubmit.cmd_id)
}
inline std::string* CustomControllerSubmit::mutable_cmd_id() {
  std::string* _s = _internal_mutable_cmd_id();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerSubmit.cmd_id)
  return _s;
}
inline const std::string& CustomControllerSubmit::_internal_cmd_id() const {
  return _impl_.cmd_id_.Get();
}
inline void CustomControllerSubmit::_internal_set_cmd_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cmd_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerSubmit::_internal_mutable_cmd_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cmd_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomControllerSubmit::release_cmd_id() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerSubmit.cmd_id)
  if (!_internal_has_cmd_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.cmd_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cmd_id_.IsDefault()) {
    _impl_.cmd_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomControllerSubmit::set_allocated_cmd_id(std::string* cmd_id) {
  if (cmd_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cmd_id_.SetAllocated(cmd_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cmd_id_.IsDefault()) {
    _impl_.cmd_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerSubmit.cmd_id)
}

// optional bool ok = 3;
inline bool CustomControllerSubmit::_internal_has_ok() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CustomControllerSubmit::has_ok() const {
  return _internal_has_ok();
}
inline void CustomControllerSubmit::clear_ok() {
  _impl_.ok_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CustomControllerSubmit::_internal_ok() const {
  return _impl_.ok_;
}
inline bool CustomControllerSubmit::ok() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerSubmit.ok)
  return _internal_ok();
}
inline void CustomControllerSubmit::_internal_set_ok(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ok_ = value;
}
inline void CustomControllerSubmit::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerSubmit.ok)
}

// .maarpc.Size resolution = 101;
inline bool CustomControllerSubmit::_internal_has_resolution() const {
  return result_case() == kResolution;
}
inline bool CustomControllerSubmit::has_resolution() const {
  return _internal_has_resolution();
}
inline void CustomControllerSubmit::set_has_resolution() {
  _impl_._oneof_case_[0] = kResolution;
}
inline ::maarpc::Size* CustomControllerSubmit::release_resolution() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerSubmit.resolution)
  if (_internal_has_resolution()) {
    clear_has_result();
    ::maarpc::Size* temp = _impl_.result_.resolution_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.resolution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::Size& CustomControllerSubmit::_internal_resolution() const {
  return _internal_has_resolution()
      ? *_impl_.result_.resolution_
      : reinterpret_cast< ::maarpc::Size&>(::maarpc::_Size_default_instance_);
}
inline const ::maarpc::Size& CustomControllerSubmit::resolution() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerSubmit.resolution)
  return _internal_resolution();
}
inline ::maarpc::Size* CustomControllerSubmit::unsafe_arena_release_resolution() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerSubmit.resolution)
  if (_internal_has_resolution()) {
    clear_has_result();
    ::maarpc::Size* temp = _impl_.result_.resolution_;
    _impl_.result_.resolution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerSubmit::unsafe_arena_set_allocated_resolution(::maarpc::Size* resolution) {
  clear_result();
  if (resolution) {
    set_has_resolution();
    _impl_.result_.resolution_ = resolution;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerSubmit.resolution)
}
inline ::maarpc::Size* CustomControllerSubmit::_internal_mutable_resolution() {
  if (!_internal_has_resolution()) {
    clear_result();
    set_has_resolution();
    _impl_.result_.resolution_ = CreateMaybeMessage< ::maarpc::Size >(GetArenaForAllocation());
  }
  return _impl_.result_.resolution_;
}
inline ::maarpc::Size* CustomControllerSubmit::mutable_resolution() {
  ::maarpc::Size* _msg = _internal_mutable_resolution();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerSubmit.resolution)
  return _msg;
}

// string uuid = 102;
inline bool CustomControllerSubmit::_internal_has_uuid() const {
  return result_case() == kUuid;
}
inline bool CustomControllerSubmit::has_uuid() const {
  return _internal_has_uuid();
}
inline void CustomControllerSubmit::set_has_uuid() {
  _impl_._oneof_case_[0] = kUuid;
}
inline void CustomControllerSubmit::clear_uuid() {
  if (_internal_has_uuid()) {
    _impl_.result_.uuid_.Destroy();
    clear_has_result();
  }
}
inline const std::string& CustomControllerSubmit::uuid() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerSubmit.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline void CustomControllerSubmit::set_uuid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_uuid()) {
    clear_result();
    set_has_uuid();
    _impl_.result_.uuid_.InitDefault();
  }
  _impl_.result_.uuid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerSubmit.uuid)
}
inline std::string* CustomControllerSubmit::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerSubmit.uuid)
  return _s;
}
inline const std::string& CustomControllerSubmit::_internal_uuid() const {
  if (_internal_has_uuid()) {
    return _impl_.result_.uuid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomControllerSubmit::_internal_set_uuid(const std::string& value) {
  if (!_internal_has_uuid()) {
    clear_result();
    set_has_uuid();
    _impl_.result_.uuid_.InitDefault();
  }
  _impl_.result_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerSubmit::_internal_mutable_uuid() {
  if (!_internal_has_uuid()) {
    clear_result();
    set_has_uuid();
    _impl_.result_.uuid_.InitDefault();
  }
  return _impl_.result_.uuid_.Mutable(      GetArenaForAllocation());
}
inline std::string* CustomControllerSubmit::release_uuid() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerSubmit.uuid)
  if (_internal_has_uuid()) {
    clear_has_result();
    return _impl_.result_.uuid_.Release();
  } else {
    return nullptr;
  }
}
inline void CustomControllerSubmit::set_allocated_uuid(std::string* uuid) {
  if (has_result()) {
    clear_result();
  }
  if (uuid != nullptr) {
    set_has_uuid();
    _impl_.result_.uuid_.InitAllocated(uuid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerSubmit.uuid)
}

inline bool CustomControllerSubmit::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void CustomControllerSubmit::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline CustomControllerSubmit::ResultCase CustomControllerSubmit::result_case() const {
  return CustomControllerSubmit::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CustomControllerRequest

// .maarpc.CustomControllerInit init = 1;
inline bool CustomControllerRequest::_internal_has_init() const {
  return payload_case() == kInit;
}
inline bool CustomControllerRequest::has_init() const {
  return _internal_has_init();
}
inline void CustomControllerRequest::set_has_init() {
  _impl_._oneof_case_[0] = kInit;
}
inline void CustomControllerRequest::clear_init() {
  if (_internal_has_init()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.init_;
    }
    clear_has_payload();
  }
}
inline ::maarpc::CustomControllerInit* CustomControllerRequest::release_init() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerRequest.init)
  if (_internal_has_init()) {
    clear_has_payload();
    ::maarpc::CustomControllerInit* temp = _impl_.payload_.init_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::CustomControllerInit& CustomControllerRequest::_internal_init() const {
  return _internal_has_init()
      ? *_impl_.payload_.init_
      : reinterpret_cast< ::maarpc::CustomControllerInit&>(::maarpc::_CustomControllerInit_default_instance_);
}
inline const ::maarpc::CustomControllerInit& CustomControllerRequest::init() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerRequest.init)
  return _internal_init();
}
inline ::maarpc::CustomControllerInit* CustomControllerRequest::unsafe_arena_release_init() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerRequest.init)
  if (_internal_has_init()) {
    clear_has_payload();
    ::maarpc::CustomControllerInit* temp = _impl_.payload_.init_;
    _impl_.payload_.init_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerRequest::unsafe_arena_set_allocated_init(::maarpc::CustomControllerInit* init) {
  clear_payload();
  if (init) {
    set_has_init();
    _impl_.payload_.init_ = init;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerRequest.init)
}
inline ::maarpc::CustomControllerInit* CustomControllerRequest::_internal_mutable_init() {
  if (!_internal_has_init()) {
    clear_payload();
    set_has_init();
    _impl_.payload_.init_ = CreateMaybeMessage< ::maarpc::CustomControllerInit >(GetArenaForAllocation());
  }
  return _impl_.payload_.init_;
}
inline ::maarpc::CustomControllerInit* CustomControllerRequest::mutable_init() {
  ::maarpc::CustomControllerInit* _msg = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerRequest.init)
  return _msg;
}

// .maarpc.CustomControllerSubmit submit = 2;
inline bool CustomControllerRequest::_internal_has_submit() const {
  return payload_case() == kSubmit;
}
inline bool CustomControllerRequest::has_submit() const {
  return _internal_has_submit();
}
inline void CustomControllerRequest::set_has_submit() {
  _impl_._oneof_case_[0] = kSubmit;
}
inline void CustomControllerRequest::clear_submit() {
  if (_internal_has_submit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.submit_;
    }
    clear_has_payload();
  }
}
inline ::maarpc::CustomControllerSubmit* CustomControllerRequest::release_submit() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerRequest.submit)
  if (_internal_has_submit()) {
    clear_has_payload();
    ::maarpc::CustomControllerSubmit* temp = _impl_.payload_.submit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.submit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::CustomControllerSubmit& CustomControllerRequest::_internal_submit() const {
  return _internal_has_submit()
      ? *_impl_.payload_.submit_
      : reinterpret_cast< ::maarpc::CustomControllerSubmit&>(::maarpc::_CustomControllerSubmit_default_instance_);
}
inline const ::maarpc::CustomControllerSubmit& CustomControllerRequest::submit() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerRequest.submit)
  return _internal_submit();
}
inline ::maarpc::CustomControllerSubmit* CustomControllerRequest::unsafe_arena_release_submit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerRequest.submit)
  if (_internal_has_submit()) {
    clear_has_payload();
    ::maarpc::CustomControllerSubmit* temp = _impl_.payload_.submit_;
    _impl_.payload_.submit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerRequest::unsafe_arena_set_allocated_submit(::maarpc::CustomControllerSubmit* submit) {
  clear_payload();
  if (submit) {
    set_has_submit();
    _impl_.payload_.submit_ = submit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerRequest.submit)
}
inline ::maarpc::CustomControllerSubmit* CustomControllerRequest::_internal_mutable_submit() {
  if (!_internal_has_submit()) {
    clear_payload();
    set_has_submit();
    _impl_.payload_.submit_ = CreateMaybeMessage< ::maarpc::CustomControllerSubmit >(GetArenaForAllocation());
  }
  return _impl_.payload_.submit_;
}
inline ::maarpc::CustomControllerSubmit* CustomControllerRequest::mutable_submit() {
  ::maarpc::CustomControllerSubmit* _msg = _internal_mutable_submit();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerRequest.submit)
  return _msg;
}

inline bool CustomControllerRequest::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void CustomControllerRequest::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline CustomControllerRequest::PayloadCase CustomControllerRequest::payload_case() const {
  return CustomControllerRequest::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CustomControllerResponse

// optional string ctrl_id = 1;
inline bool CustomControllerResponse::_internal_has_ctrl_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CustomControllerResponse::has_ctrl_id() const {
  return _internal_has_ctrl_id();
}
inline void CustomControllerResponse::clear_ctrl_id() {
  _impl_.ctrl_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomControllerResponse::ctrl_id() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.ctrl_id)
  return _internal_ctrl_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomControllerResponse::set_ctrl_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.ctrl_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.ctrl_id)
}
inline std::string* CustomControllerResponse::mutable_ctrl_id() {
  std::string* _s = _internal_mutable_ctrl_id();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.ctrl_id)
  return _s;
}
inline const std::string& CustomControllerResponse::_internal_ctrl_id() const {
  return _impl_.ctrl_id_.Get();
}
inline void CustomControllerResponse::_internal_set_ctrl_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ctrl_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::_internal_mutable_ctrl_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ctrl_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::release_ctrl_id() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.ctrl_id)
  if (!_internal_has_ctrl_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.ctrl_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ctrl_id_.IsDefault()) {
    _impl_.ctrl_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomControllerResponse::set_allocated_ctrl_id(std::string* ctrl_id) {
  if (ctrl_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ctrl_id_.SetAllocated(ctrl_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ctrl_id_.IsDefault()) {
    _impl_.ctrl_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerResponse.ctrl_id)
}

// optional string cmd_id = 2;
inline bool CustomControllerResponse::_internal_has_cmd_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CustomControllerResponse::has_cmd_id() const {
  return _internal_has_cmd_id();
}
inline void CustomControllerResponse::clear_cmd_id() {
  _impl_.cmd_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CustomControllerResponse::cmd_id() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.cmd_id)
  return _internal_cmd_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomControllerResponse::set_cmd_id(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.cmd_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.cmd_id)
}
inline std::string* CustomControllerResponse::mutable_cmd_id() {
  std::string* _s = _internal_mutable_cmd_id();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.cmd_id)
  return _s;
}
inline const std::string& CustomControllerResponse::_internal_cmd_id() const {
  return _impl_.cmd_id_.Get();
}
inline void CustomControllerResponse::_internal_set_cmd_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cmd_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::_internal_mutable_cmd_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cmd_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::release_cmd_id() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.cmd_id)
  if (!_internal_has_cmd_id()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.cmd_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cmd_id_.IsDefault()) {
    _impl_.cmd_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomControllerResponse::set_allocated_cmd_id(std::string* cmd_id) {
  if (cmd_id != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cmd_id_.SetAllocated(cmd_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cmd_id_.IsDefault()) {
    _impl_.cmd_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerResponse.cmd_id)
}

// bool connect = 101;
inline bool CustomControllerResponse::_internal_has_connect() const {
  return command_case() == kConnect;
}
inline bool CustomControllerResponse::has_connect() const {
  return _internal_has_connect();
}
inline void CustomControllerResponse::set_has_connect() {
  _impl_._oneof_case_[0] = kConnect;
}
inline void CustomControllerResponse::clear_connect() {
  if (_internal_has_connect()) {
    _impl_.command_.connect_ = false;
    clear_has_command();
  }
}
inline bool CustomControllerResponse::_internal_connect() const {
  if (_internal_has_connect()) {
    return _impl_.command_.connect_;
  }
  return false;
}
inline void CustomControllerResponse::_internal_set_connect(bool value) {
  if (!_internal_has_connect()) {
    clear_command();
    set_has_connect();
  }
  _impl_.command_.connect_ = value;
}
inline bool CustomControllerResponse::connect() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.connect)
  return _internal_connect();
}
inline void CustomControllerResponse::set_connect(bool value) {
  _internal_set_connect(value);
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.connect)
}

// .maarpc.ClickParam click = 102;
inline bool CustomControllerResponse::_internal_has_click() const {
  return command_case() == kClick;
}
inline bool CustomControllerResponse::has_click() const {
  return _internal_has_click();
}
inline void CustomControllerResponse::set_has_click() {
  _impl_._oneof_case_[0] = kClick;
}
inline ::maarpc::ClickParam* CustomControllerResponse::release_click() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.click)
  if (_internal_has_click()) {
    clear_has_command();
    ::maarpc::ClickParam* temp = _impl_.command_.click_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.click_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::ClickParam& CustomControllerResponse::_internal_click() const {
  return _internal_has_click()
      ? *_impl_.command_.click_
      : reinterpret_cast< ::maarpc::ClickParam&>(::maarpc::_ClickParam_default_instance_);
}
inline const ::maarpc::ClickParam& CustomControllerResponse::click() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.click)
  return _internal_click();
}
inline ::maarpc::ClickParam* CustomControllerResponse::unsafe_arena_release_click() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.click)
  if (_internal_has_click()) {
    clear_has_command();
    ::maarpc::ClickParam* temp = _impl_.command_.click_;
    _impl_.command_.click_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_click(::maarpc::ClickParam* click) {
  clear_command();
  if (click) {
    set_has_click();
    _impl_.command_.click_ = click;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.click)
}
inline ::maarpc::ClickParam* CustomControllerResponse::_internal_mutable_click() {
  if (!_internal_has_click()) {
    clear_command();
    set_has_click();
    _impl_.command_.click_ = CreateMaybeMessage< ::maarpc::ClickParam >(GetArenaForAllocation());
  }
  return _impl_.command_.click_;
}
inline ::maarpc::ClickParam* CustomControllerResponse::mutable_click() {
  ::maarpc::ClickParam* _msg = _internal_mutable_click();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.click)
  return _msg;
}

// .maarpc.SwipeParam swipe = 103;
inline bool CustomControllerResponse::_internal_has_swipe() const {
  return command_case() == kSwipe;
}
inline bool CustomControllerResponse::has_swipe() const {
  return _internal_has_swipe();
}
inline void CustomControllerResponse::set_has_swipe() {
  _impl_._oneof_case_[0] = kSwipe;
}
inline ::maarpc::SwipeParam* CustomControllerResponse::release_swipe() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.swipe)
  if (_internal_has_swipe()) {
    clear_has_command();
    ::maarpc::SwipeParam* temp = _impl_.command_.swipe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.swipe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::SwipeParam& CustomControllerResponse::_internal_swipe() const {
  return _internal_has_swipe()
      ? *_impl_.command_.swipe_
      : reinterpret_cast< ::maarpc::SwipeParam&>(::maarpc::_SwipeParam_default_instance_);
}
inline const ::maarpc::SwipeParam& CustomControllerResponse::swipe() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.swipe)
  return _internal_swipe();
}
inline ::maarpc::SwipeParam* CustomControllerResponse::unsafe_arena_release_swipe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.swipe)
  if (_internal_has_swipe()) {
    clear_has_command();
    ::maarpc::SwipeParam* temp = _impl_.command_.swipe_;
    _impl_.command_.swipe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_swipe(::maarpc::SwipeParam* swipe) {
  clear_command();
  if (swipe) {
    set_has_swipe();
    _impl_.command_.swipe_ = swipe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.swipe)
}
inline ::maarpc::SwipeParam* CustomControllerResponse::_internal_mutable_swipe() {
  if (!_internal_has_swipe()) {
    clear_command();
    set_has_swipe();
    _impl_.command_.swipe_ = CreateMaybeMessage< ::maarpc::SwipeParam >(GetArenaForAllocation());
  }
  return _impl_.command_.swipe_;
}
inline ::maarpc::SwipeParam* CustomControllerResponse::mutable_swipe() {
  ::maarpc::SwipeParam* _msg = _internal_mutable_swipe();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.swipe)
  return _msg;
}

// .maarpc.KeyParam key = 104;
inline bool CustomControllerResponse::_internal_has_key() const {
  return command_case() == kKey;
}
inline bool CustomControllerResponse::has_key() const {
  return _internal_has_key();
}
inline void CustomControllerResponse::set_has_key() {
  _impl_._oneof_case_[0] = kKey;
}
inline ::maarpc::KeyParam* CustomControllerResponse::release_key() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.key)
  if (_internal_has_key()) {
    clear_has_command();
    ::maarpc::KeyParam* temp = _impl_.command_.key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::KeyParam& CustomControllerResponse::_internal_key() const {
  return _internal_has_key()
      ? *_impl_.command_.key_
      : reinterpret_cast< ::maarpc::KeyParam&>(::maarpc::_KeyParam_default_instance_);
}
inline const ::maarpc::KeyParam& CustomControllerResponse::key() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.key)
  return _internal_key();
}
inline ::maarpc::KeyParam* CustomControllerResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.key)
  if (_internal_has_key()) {
    clear_has_command();
    ::maarpc::KeyParam* temp = _impl_.command_.key_;
    _impl_.command_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_key(::maarpc::KeyParam* key) {
  clear_command();
  if (key) {
    set_has_key();
    _impl_.command_.key_ = key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.key)
}
inline ::maarpc::KeyParam* CustomControllerResponse::_internal_mutable_key() {
  if (!_internal_has_key()) {
    clear_command();
    set_has_key();
    _impl_.command_.key_ = CreateMaybeMessage< ::maarpc::KeyParam >(GetArenaForAllocation());
  }
  return _impl_.command_.key_;
}
inline ::maarpc::KeyParam* CustomControllerResponse::mutable_key() {
  ::maarpc::KeyParam* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.key)
  return _msg;
}

// .maarpc.TouchParam touch_down = 105;
inline bool CustomControllerResponse::_internal_has_touch_down() const {
  return command_case() == kTouchDown;
}
inline bool CustomControllerResponse::has_touch_down() const {
  return _internal_has_touch_down();
}
inline void CustomControllerResponse::set_has_touch_down() {
  _impl_._oneof_case_[0] = kTouchDown;
}
inline ::maarpc::TouchParam* CustomControllerResponse::release_touch_down() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.touch_down)
  if (_internal_has_touch_down()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_down_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.touch_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::TouchParam& CustomControllerResponse::_internal_touch_down() const {
  return _internal_has_touch_down()
      ? *_impl_.command_.touch_down_
      : reinterpret_cast< ::maarpc::TouchParam&>(::maarpc::_TouchParam_default_instance_);
}
inline const ::maarpc::TouchParam& CustomControllerResponse::touch_down() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.touch_down)
  return _internal_touch_down();
}
inline ::maarpc::TouchParam* CustomControllerResponse::unsafe_arena_release_touch_down() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.touch_down)
  if (_internal_has_touch_down()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_down_;
    _impl_.command_.touch_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_touch_down(::maarpc::TouchParam* touch_down) {
  clear_command();
  if (touch_down) {
    set_has_touch_down();
    _impl_.command_.touch_down_ = touch_down;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.touch_down)
}
inline ::maarpc::TouchParam* CustomControllerResponse::_internal_mutable_touch_down() {
  if (!_internal_has_touch_down()) {
    clear_command();
    set_has_touch_down();
    _impl_.command_.touch_down_ = CreateMaybeMessage< ::maarpc::TouchParam >(GetArenaForAllocation());
  }
  return _impl_.command_.touch_down_;
}
inline ::maarpc::TouchParam* CustomControllerResponse::mutable_touch_down() {
  ::maarpc::TouchParam* _msg = _internal_mutable_touch_down();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.touch_down)
  return _msg;
}

// .maarpc.TouchParam touch_move = 106;
inline bool CustomControllerResponse::_internal_has_touch_move() const {
  return command_case() == kTouchMove;
}
inline bool CustomControllerResponse::has_touch_move() const {
  return _internal_has_touch_move();
}
inline void CustomControllerResponse::set_has_touch_move() {
  _impl_._oneof_case_[0] = kTouchMove;
}
inline ::maarpc::TouchParam* CustomControllerResponse::release_touch_move() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.touch_move)
  if (_internal_has_touch_move()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_move_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.touch_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::TouchParam& CustomControllerResponse::_internal_touch_move() const {
  return _internal_has_touch_move()
      ? *_impl_.command_.touch_move_
      : reinterpret_cast< ::maarpc::TouchParam&>(::maarpc::_TouchParam_default_instance_);
}
inline const ::maarpc::TouchParam& CustomControllerResponse::touch_move() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.touch_move)
  return _internal_touch_move();
}
inline ::maarpc::TouchParam* CustomControllerResponse::unsafe_arena_release_touch_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.touch_move)
  if (_internal_has_touch_move()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_move_;
    _impl_.command_.touch_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_touch_move(::maarpc::TouchParam* touch_move) {
  clear_command();
  if (touch_move) {
    set_has_touch_move();
    _impl_.command_.touch_move_ = touch_move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.touch_move)
}
inline ::maarpc::TouchParam* CustomControllerResponse::_internal_mutable_touch_move() {
  if (!_internal_has_touch_move()) {
    clear_command();
    set_has_touch_move();
    _impl_.command_.touch_move_ = CreateMaybeMessage< ::maarpc::TouchParam >(GetArenaForAllocation());
  }
  return _impl_.command_.touch_move_;
}
inline ::maarpc::TouchParam* CustomControllerResponse::mutable_touch_move() {
  ::maarpc::TouchParam* _msg = _internal_mutable_touch_move();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.touch_move)
  return _msg;
}

// .maarpc.TouchParam touch_up = 107;
inline bool CustomControllerResponse::_internal_has_touch_up() const {
  return command_case() == kTouchUp;
}
inline bool CustomControllerResponse::has_touch_up() const {
  return _internal_has_touch_up();
}
inline void CustomControllerResponse::set_has_touch_up() {
  _impl_._oneof_case_[0] = kTouchUp;
}
inline ::maarpc::TouchParam* CustomControllerResponse::release_touch_up() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.touch_up)
  if (_internal_has_touch_up()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_up_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.touch_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::TouchParam& CustomControllerResponse::_internal_touch_up() const {
  return _internal_has_touch_up()
      ? *_impl_.command_.touch_up_
      : reinterpret_cast< ::maarpc::TouchParam&>(::maarpc::_TouchParam_default_instance_);
}
inline const ::maarpc::TouchParam& CustomControllerResponse::touch_up() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.touch_up)
  return _internal_touch_up();
}
inline ::maarpc::TouchParam* CustomControllerResponse::unsafe_arena_release_touch_up() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.touch_up)
  if (_internal_has_touch_up()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_up_;
    _impl_.command_.touch_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_touch_up(::maarpc::TouchParam* touch_up) {
  clear_command();
  if (touch_up) {
    set_has_touch_up();
    _impl_.command_.touch_up_ = touch_up;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.touch_up)
}
inline ::maarpc::TouchParam* CustomControllerResponse::_internal_mutable_touch_up() {
  if (!_internal_has_touch_up()) {
    clear_command();
    set_has_touch_up();
    _impl_.command_.touch_up_ = CreateMaybeMessage< ::maarpc::TouchParam >(GetArenaForAllocation());
  }
  return _impl_.command_.touch_up_;
}
inline ::maarpc::TouchParam* CustomControllerResponse::mutable_touch_up() {
  ::maarpc::TouchParam* _msg = _internal_mutable_touch_up();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.touch_up)
  return _msg;
}

// string start = 108;
inline bool CustomControllerResponse::_internal_has_start() const {
  return command_case() == kStart;
}
inline bool CustomControllerResponse::has_start() const {
  return _internal_has_start();
}
inline void CustomControllerResponse::set_has_start() {
  _impl_._oneof_case_[0] = kStart;
}
inline void CustomControllerResponse::clear_start() {
  if (_internal_has_start()) {
    _impl_.command_.start_.Destroy();
    clear_has_command();
  }
}
inline const std::string& CustomControllerResponse::start() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.start)
  return _internal_start();
}
template <typename ArgT0, typename... ArgT>
inline void CustomControllerResponse::set_start(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_start()) {
    clear_command();
    set_has_start();
    _impl_.command_.start_.InitDefault();
  }
  _impl_.command_.start_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.start)
}
inline std::string* CustomControllerResponse::mutable_start() {
  std::string* _s = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.start)
  return _s;
}
inline const std::string& CustomControllerResponse::_internal_start() const {
  if (_internal_has_start()) {
    return _impl_.command_.start_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomControllerResponse::_internal_set_start(const std::string& value) {
  if (!_internal_has_start()) {
    clear_command();
    set_has_start();
    _impl_.command_.start_.InitDefault();
  }
  _impl_.command_.start_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::_internal_mutable_start() {
  if (!_internal_has_start()) {
    clear_command();
    set_has_start();
    _impl_.command_.start_.InitDefault();
  }
  return _impl_.command_.start_.Mutable(      GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::release_start() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.start)
  if (_internal_has_start()) {
    clear_has_command();
    return _impl_.command_.start_.Release();
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::set_allocated_start(std::string* start) {
  if (has_command()) {
    clear_command();
  }
  if (start != nullptr) {
    set_has_start();
    _impl_.command_.start_.InitAllocated(start, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerResponse.start)
}

// string stop = 109;
inline bool CustomControllerResponse::_internal_has_stop() const {
  return command_case() == kStop;
}
inline bool CustomControllerResponse::has_stop() const {
  return _internal_has_stop();
}
inline void CustomControllerResponse::set_has_stop() {
  _impl_._oneof_case_[0] = kStop;
}
inline void CustomControllerResponse::clear_stop() {
  if (_internal_has_stop()) {
    _impl_.command_.stop_.Destroy();
    clear_has_command();
  }
}
inline const std::string& CustomControllerResponse::stop() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.stop)
  return _internal_stop();
}
template <typename ArgT0, typename... ArgT>
inline void CustomControllerResponse::set_stop(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_stop()) {
    clear_command();
    set_has_stop();
    _impl_.command_.stop_.InitDefault();
  }
  _impl_.command_.stop_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.stop)
}
inline std::string* CustomControllerResponse::mutable_stop() {
  std::string* _s = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.stop)
  return _s;
}
inline const std::string& CustomControllerResponse::_internal_stop() const {
  if (_internal_has_stop()) {
    return _impl_.command_.stop_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomControllerResponse::_internal_set_stop(const std::string& value) {
  if (!_internal_has_stop()) {
    clear_command();
    set_has_stop();
    _impl_.command_.stop_.InitDefault();
  }
  _impl_.command_.stop_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::_internal_mutable_stop() {
  if (!_internal_has_stop()) {
    clear_command();
    set_has_stop();
    _impl_.command_.stop_.InitDefault();
  }
  return _impl_.command_.stop_.Mutable(      GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::release_stop() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.stop)
  if (_internal_has_stop()) {
    clear_has_command();
    return _impl_.command_.stop_.Release();
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::set_allocated_stop(std::string* stop) {
  if (has_command()) {
    clear_command();
  }
  if (stop != nullptr) {
    set_has_stop();
    _impl_.command_.stop_.InitAllocated(stop, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerResponse.stop)
}

// bool resolution = 110;
inline bool CustomControllerResponse::_internal_has_resolution() const {
  return command_case() == kResolution;
}
inline bool CustomControllerResponse::has_resolution() const {
  return _internal_has_resolution();
}
inline void CustomControllerResponse::set_has_resolution() {
  _impl_._oneof_case_[0] = kResolution;
}
inline void CustomControllerResponse::clear_resolution() {
  if (_internal_has_resolution()) {
    _impl_.command_.resolution_ = false;
    clear_has_command();
  }
}
inline bool CustomControllerResponse::_internal_resolution() const {
  if (_internal_has_resolution()) {
    return _impl_.command_.resolution_;
  }
  return false;
}
inline void CustomControllerResponse::_internal_set_resolution(bool value) {
  if (!_internal_has_resolution()) {
    clear_command();
    set_has_resolution();
  }
  _impl_.command_.resolution_ = value;
}
inline bool CustomControllerResponse::resolution() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.resolution)
  return _internal_resolution();
}
inline void CustomControllerResponse::set_resolution(bool value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.resolution)
}

// string image = 111;
inline bool CustomControllerResponse::_internal_has_image() const {
  return command_case() == kImage;
}
inline bool CustomControllerResponse::has_image() const {
  return _internal_has_image();
}
inline void CustomControllerResponse::set_has_image() {
  _impl_._oneof_case_[0] = kImage;
}
inline void CustomControllerResponse::clear_image() {
  if (_internal_has_image()) {
    _impl_.command_.image_.Destroy();
    clear_has_command();
  }
}
inline const std::string& CustomControllerResponse::image() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline void CustomControllerResponse::set_image(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_image()) {
    clear_command();
    set_has_image();
    _impl_.command_.image_.InitDefault();
  }
  _impl_.command_.image_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.image)
}
inline std::string* CustomControllerResponse::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.image)
  return _s;
}
inline const std::string& CustomControllerResponse::_internal_image() const {
  if (_internal_has_image()) {
    return _impl_.command_.image_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomControllerResponse::_internal_set_image(const std::string& value) {
  if (!_internal_has_image()) {
    clear_command();
    set_has_image();
    _impl_.command_.image_.InitDefault();
  }
  _impl_.command_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::_internal_mutable_image() {
  if (!_internal_has_image()) {
    clear_command();
    set_has_image();
    _impl_.command_.image_.InitDefault();
  }
  return _impl_.command_.image_.Mutable(      GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::release_image() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.image)
  if (_internal_has_image()) {
    clear_has_command();
    return _impl_.command_.image_.Release();
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::set_allocated_image(std::string* image) {
  if (has_command()) {
    clear_command();
  }
  if (image != nullptr) {
    set_has_image();
    _impl_.command_.image_.InitAllocated(image, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerResponse.image)
}

// bool uuid = 112;
inline bool CustomControllerResponse::_internal_has_uuid() const {
  return command_case() == kUuid;
}
inline bool CustomControllerResponse::has_uuid() const {
  return _internal_has_uuid();
}
inline void CustomControllerResponse::set_has_uuid() {
  _impl_._oneof_case_[0] = kUuid;
}
inline void CustomControllerResponse::clear_uuid() {
  if (_internal_has_uuid()) {
    _impl_.command_.uuid_ = false;
    clear_has_command();
  }
}
inline bool CustomControllerResponse::_internal_uuid() const {
  if (_internal_has_uuid()) {
    return _impl_.command_.uuid_;
  }
  return false;
}
inline void CustomControllerResponse::_internal_set_uuid(bool value) {
  if (!_internal_has_uuid()) {
    clear_command();
    set_has_uuid();
  }
  _impl_.command_.uuid_ = value;
}
inline bool CustomControllerResponse::uuid() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.uuid)
  return _internal_uuid();
}
inline void CustomControllerResponse::set_uuid(bool value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.uuid)
}

// .maarpc.CustomControllerSetOptionParam set_option = 200;
inline bool CustomControllerResponse::_internal_has_set_option() const {
  return command_case() == kSetOption;
}
inline bool CustomControllerResponse::has_set_option() const {
  return _internal_has_set_option();
}
inline void CustomControllerResponse::set_has_set_option() {
  _impl_._oneof_case_[0] = kSetOption;
}
inline void CustomControllerResponse::clear_set_option() {
  if (_internal_has_set_option()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.set_option_;
    }
    clear_has_command();
  }
}
inline ::maarpc::CustomControllerSetOptionParam* CustomControllerResponse::release_set_option() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.set_option)
  if (_internal_has_set_option()) {
    clear_has_command();
    ::maarpc::CustomControllerSetOptionParam* temp = _impl_.command_.set_option_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.set_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::CustomControllerSetOptionParam& CustomControllerResponse::_internal_set_option() const {
  return _internal_has_set_option()
      ? *_impl_.command_.set_option_
      : reinterpret_cast< ::maarpc::CustomControllerSetOptionParam&>(::maarpc::_CustomControllerSetOptionParam_default_instance_);
}
inline const ::maarpc::CustomControllerSetOptionParam& CustomControllerResponse::set_option() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.set_option)
  return _internal_set_option();
}
inline ::maarpc::CustomControllerSetOptionParam* CustomControllerResponse::unsafe_arena_release_set_option() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.set_option)
  if (_internal_has_set_option()) {
    clear_has_command();
    ::maarpc::CustomControllerSetOptionParam* temp = _impl_.command_.set_option_;
    _impl_.command_.set_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_set_option(::maarpc::CustomControllerSetOptionParam* set_option) {
  clear_command();
  if (set_option) {
    set_has_set_option();
    _impl_.command_.set_option_ = set_option;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.set_option)
}
inline ::maarpc::CustomControllerSetOptionParam* CustomControllerResponse::_internal_mutable_set_option() {
  if (!_internal_has_set_option()) {
    clear_command();
    set_has_set_option();
    _impl_.command_.set_option_ = CreateMaybeMessage< ::maarpc::CustomControllerSetOptionParam >(GetArenaForAllocation());
  }
  return _impl_.command_.set_option_;
}
inline ::maarpc::CustomControllerSetOptionParam* CustomControllerResponse::mutable_set_option() {
  ::maarpc::CustomControllerSetOptionParam* _msg = _internal_mutable_set_option();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.set_option)
  return _msg;
}

inline bool CustomControllerResponse::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void CustomControllerResponse::clear_has_command() {
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}
inline CustomControllerResponse::CommandCase CustomControllerResponse::command_case() const {
  return CustomControllerResponse::CommandCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace maarpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_custom_2econtroller_2eproto
