// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: custom.controller.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_custom_2econtroller_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_custom_2econtroller_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_custom_2econtroller_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_custom_2econtroller_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_custom_2econtroller_2eproto;
namespace maarpc {
class CustomControllerRequest;
struct CustomControllerRequestDefaultTypeInternal;
extern CustomControllerRequestDefaultTypeInternal _CustomControllerRequest_default_instance_;
class CustomControllerResponse;
struct CustomControllerResponseDefaultTypeInternal;
extern CustomControllerResponseDefaultTypeInternal _CustomControllerResponse_default_instance_;
class CustomControllerSetOptionParam;
struct CustomControllerSetOptionParamDefaultTypeInternal;
extern CustomControllerSetOptionParamDefaultTypeInternal _CustomControllerSetOptionParam_default_instance_;
}  // namespace maarpc
PROTOBUF_NAMESPACE_OPEN
template<> ::maarpc::CustomControllerRequest* Arena::CreateMaybeMessage<::maarpc::CustomControllerRequest>(Arena*);
template<> ::maarpc::CustomControllerResponse* Arena::CreateMaybeMessage<::maarpc::CustomControllerResponse>(Arena*);
template<> ::maarpc::CustomControllerSetOptionParam* Arena::CreateMaybeMessage<::maarpc::CustomControllerSetOptionParam>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace maarpc {

// ===================================================================

class CustomControllerSetOptionParam final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.CustomControllerSetOptionParam) */ {
 public:
  inline CustomControllerSetOptionParam() : CustomControllerSetOptionParam(nullptr) {}
  ~CustomControllerSetOptionParam() override;
  explicit PROTOBUF_CONSTEXPR CustomControllerSetOptionParam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomControllerSetOptionParam(const CustomControllerSetOptionParam& from);
  CustomControllerSetOptionParam(CustomControllerSetOptionParam&& from) noexcept
    : CustomControllerSetOptionParam() {
    *this = ::std::move(from);
  }

  inline CustomControllerSetOptionParam& operator=(const CustomControllerSetOptionParam& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomControllerSetOptionParam& operator=(CustomControllerSetOptionParam&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomControllerSetOptionParam& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomControllerSetOptionParam* internal_default_instance() {
    return reinterpret_cast<const CustomControllerSetOptionParam*>(
               &_CustomControllerSetOptionParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CustomControllerSetOptionParam& a, CustomControllerSetOptionParam& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomControllerSetOptionParam* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomControllerSetOptionParam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomControllerSetOptionParam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomControllerSetOptionParam>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomControllerSetOptionParam& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomControllerSetOptionParam& from) {
    CustomControllerSetOptionParam::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomControllerSetOptionParam* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.CustomControllerSetOptionParam";
  }
  protected:
  explicit CustomControllerSetOptionParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional int32 key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.CustomControllerSetOptionParam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int32_t key_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_custom_2econtroller_2eproto;
};
// -------------------------------------------------------------------

class CustomControllerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.CustomControllerRequest) */ {
 public:
  inline CustomControllerRequest() : CustomControllerRequest(nullptr) {}
  ~CustomControllerRequest() override;
  explicit PROTOBUF_CONSTEXPR CustomControllerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomControllerRequest(const CustomControllerRequest& from);
  CustomControllerRequest(CustomControllerRequest&& from) noexcept
    : CustomControllerRequest() {
    *this = ::std::move(from);
  }

  inline CustomControllerRequest& operator=(const CustomControllerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomControllerRequest& operator=(CustomControllerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomControllerRequest& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kInit = 101,
    kResolution = 201,
    kUuid = 202,
    RESULT_NOT_SET = 0,
  };

  static inline const CustomControllerRequest* internal_default_instance() {
    return reinterpret_cast<const CustomControllerRequest*>(
               &_CustomControllerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CustomControllerRequest& a, CustomControllerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomControllerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomControllerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomControllerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomControllerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomControllerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomControllerRequest& from) {
    CustomControllerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomControllerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.CustomControllerRequest";
  }
  protected:
  explicit CustomControllerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kInitFieldNumber = 101,
    kResolutionFieldNumber = 201,
    kUuidFieldNumber = 202,
  };
  // optional bool ok = 1;
  bool has_ok() const;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // string init = 101;
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const std::string& init() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_init(ArgT0&& arg0, ArgT... args);
  std::string* mutable_init();
  PROTOBUF_NODISCARD std::string* release_init();
  void set_allocated_init(std::string* init);
  private:
  const std::string& _internal_init() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_init(const std::string& value);
  std::string* _internal_mutable_init();
  public:

  // .maarpc.Size resolution = 201;
  bool has_resolution() const;
  private:
  bool _internal_has_resolution() const;
  public:
  void clear_resolution();
  const ::maarpc::Size& resolution() const;
  PROTOBUF_NODISCARD ::maarpc::Size* release_resolution();
  ::maarpc::Size* mutable_resolution();
  void set_allocated_resolution(::maarpc::Size* resolution);
  private:
  const ::maarpc::Size& _internal_resolution() const;
  ::maarpc::Size* _internal_mutable_resolution();
  public:
  void unsafe_arena_set_allocated_resolution(
      ::maarpc::Size* resolution);
  ::maarpc::Size* unsafe_arena_release_resolution();

  // string uuid = 202;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:maarpc.CustomControllerRequest)
 private:
  class _Internal;
  void set_has_init();
  void set_has_resolution();
  void set_has_uuid();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    bool ok_;
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr init_;
      ::maarpc::Size* resolution_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    } result_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_custom_2econtroller_2eproto;
};
// -------------------------------------------------------------------

class CustomControllerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.CustomControllerResponse) */ {
 public:
  inline CustomControllerResponse() : CustomControllerResponse(nullptr) {}
  ~CustomControllerResponse() override;
  explicit PROTOBUF_CONSTEXPR CustomControllerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomControllerResponse(const CustomControllerResponse& from);
  CustomControllerResponse(CustomControllerResponse&& from) noexcept
    : CustomControllerResponse() {
    *this = ::std::move(from);
  }

  inline CustomControllerResponse& operator=(const CustomControllerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomControllerResponse& operator=(CustomControllerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomControllerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum CommandCase {
    kInit = 101,
    kConnect = 201,
    kClick = 202,
    kSwipe = 203,
    kKey = 204,
    kTouchDown = 205,
    kTouchMove = 206,
    kTouchUp = 207,
    kStart = 208,
    kStop = 209,
    kResolution = 210,
    kImage = 211,
    kUuid = 212,
    kSetOption = 213,
    COMMAND_NOT_SET = 0,
  };

  static inline const CustomControllerResponse* internal_default_instance() {
    return reinterpret_cast<const CustomControllerResponse*>(
               &_CustomControllerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CustomControllerResponse& a, CustomControllerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomControllerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomControllerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomControllerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomControllerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomControllerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomControllerResponse& from) {
    CustomControllerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomControllerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.CustomControllerResponse";
  }
  protected:
  explicit CustomControllerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitFieldNumber = 101,
    kConnectFieldNumber = 201,
    kClickFieldNumber = 202,
    kSwipeFieldNumber = 203,
    kKeyFieldNumber = 204,
    kTouchDownFieldNumber = 205,
    kTouchMoveFieldNumber = 206,
    kTouchUpFieldNumber = 207,
    kStartFieldNumber = 208,
    kStopFieldNumber = 209,
    kResolutionFieldNumber = 210,
    kImageFieldNumber = 211,
    kUuidFieldNumber = 212,
    kSetOptionFieldNumber = 213,
  };
  // string init = 101;
  bool has_init() const;
  private:
  bool _internal_has_init() const;
  public:
  void clear_init();
  const std::string& init() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_init(ArgT0&& arg0, ArgT... args);
  std::string* mutable_init();
  PROTOBUF_NODISCARD std::string* release_init();
  void set_allocated_init(std::string* init);
  private:
  const std::string& _internal_init() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_init(const std::string& value);
  std::string* _internal_mutable_init();
  public:

  // bool connect = 201;
  bool has_connect() const;
  private:
  bool _internal_has_connect() const;
  public:
  void clear_connect();
  bool connect() const;
  void set_connect(bool value);
  private:
  bool _internal_connect() const;
  void _internal_set_connect(bool value);
  public:

  // .maarpc.ClickParam click = 202;
  bool has_click() const;
  private:
  bool _internal_has_click() const;
  public:
  void clear_click();
  const ::maarpc::ClickParam& click() const;
  PROTOBUF_NODISCARD ::maarpc::ClickParam* release_click();
  ::maarpc::ClickParam* mutable_click();
  void set_allocated_click(::maarpc::ClickParam* click);
  private:
  const ::maarpc::ClickParam& _internal_click() const;
  ::maarpc::ClickParam* _internal_mutable_click();
  public:
  void unsafe_arena_set_allocated_click(
      ::maarpc::ClickParam* click);
  ::maarpc::ClickParam* unsafe_arena_release_click();

  // .maarpc.SwipeParam swipe = 203;
  bool has_swipe() const;
  private:
  bool _internal_has_swipe() const;
  public:
  void clear_swipe();
  const ::maarpc::SwipeParam& swipe() const;
  PROTOBUF_NODISCARD ::maarpc::SwipeParam* release_swipe();
  ::maarpc::SwipeParam* mutable_swipe();
  void set_allocated_swipe(::maarpc::SwipeParam* swipe);
  private:
  const ::maarpc::SwipeParam& _internal_swipe() const;
  ::maarpc::SwipeParam* _internal_mutable_swipe();
  public:
  void unsafe_arena_set_allocated_swipe(
      ::maarpc::SwipeParam* swipe);
  ::maarpc::SwipeParam* unsafe_arena_release_swipe();

  // .maarpc.KeyParam key = 204;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const ::maarpc::KeyParam& key() const;
  PROTOBUF_NODISCARD ::maarpc::KeyParam* release_key();
  ::maarpc::KeyParam* mutable_key();
  void set_allocated_key(::maarpc::KeyParam* key);
  private:
  const ::maarpc::KeyParam& _internal_key() const;
  ::maarpc::KeyParam* _internal_mutable_key();
  public:
  void unsafe_arena_set_allocated_key(
      ::maarpc::KeyParam* key);
  ::maarpc::KeyParam* unsafe_arena_release_key();

  // .maarpc.TouchParam touch_down = 205;
  bool has_touch_down() const;
  private:
  bool _internal_has_touch_down() const;
  public:
  void clear_touch_down();
  const ::maarpc::TouchParam& touch_down() const;
  PROTOBUF_NODISCARD ::maarpc::TouchParam* release_touch_down();
  ::maarpc::TouchParam* mutable_touch_down();
  void set_allocated_touch_down(::maarpc::TouchParam* touch_down);
  private:
  const ::maarpc::TouchParam& _internal_touch_down() const;
  ::maarpc::TouchParam* _internal_mutable_touch_down();
  public:
  void unsafe_arena_set_allocated_touch_down(
      ::maarpc::TouchParam* touch_down);
  ::maarpc::TouchParam* unsafe_arena_release_touch_down();

  // .maarpc.TouchParam touch_move = 206;
  bool has_touch_move() const;
  private:
  bool _internal_has_touch_move() const;
  public:
  void clear_touch_move();
  const ::maarpc::TouchParam& touch_move() const;
  PROTOBUF_NODISCARD ::maarpc::TouchParam* release_touch_move();
  ::maarpc::TouchParam* mutable_touch_move();
  void set_allocated_touch_move(::maarpc::TouchParam* touch_move);
  private:
  const ::maarpc::TouchParam& _internal_touch_move() const;
  ::maarpc::TouchParam* _internal_mutable_touch_move();
  public:
  void unsafe_arena_set_allocated_touch_move(
      ::maarpc::TouchParam* touch_move);
  ::maarpc::TouchParam* unsafe_arena_release_touch_move();

  // .maarpc.TouchParam touch_up = 207;
  bool has_touch_up() const;
  private:
  bool _internal_has_touch_up() const;
  public:
  void clear_touch_up();
  const ::maarpc::TouchParam& touch_up() const;
  PROTOBUF_NODISCARD ::maarpc::TouchParam* release_touch_up();
  ::maarpc::TouchParam* mutable_touch_up();
  void set_allocated_touch_up(::maarpc::TouchParam* touch_up);
  private:
  const ::maarpc::TouchParam& _internal_touch_up() const;
  ::maarpc::TouchParam* _internal_mutable_touch_up();
  public:
  void unsafe_arena_set_allocated_touch_up(
      ::maarpc::TouchParam* touch_up);
  ::maarpc::TouchParam* unsafe_arena_release_touch_up();

  // string start = 208;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const std::string& start() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start();
  PROTOBUF_NODISCARD std::string* release_start();
  void set_allocated_start(std::string* start);
  private:
  const std::string& _internal_start() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start(const std::string& value);
  std::string* _internal_mutable_start();
  public:

  // string stop = 209;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;
  public:
  void clear_stop();
  const std::string& stop() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stop(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stop();
  PROTOBUF_NODISCARD std::string* release_stop();
  void set_allocated_stop(std::string* stop);
  private:
  const std::string& _internal_stop() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop(const std::string& value);
  std::string* _internal_mutable_stop();
  public:

  // bool resolution = 210;
  bool has_resolution() const;
  private:
  bool _internal_has_resolution() const;
  public:
  void clear_resolution();
  bool resolution() const;
  void set_resolution(bool value);
  private:
  bool _internal_resolution() const;
  void _internal_set_resolution(bool value);
  public:

  // string image = 211;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // bool uuid = 212;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  bool uuid() const;
  void set_uuid(bool value);
  private:
  bool _internal_uuid() const;
  void _internal_set_uuid(bool value);
  public:

  // .maarpc.CustomControllerSetOptionParam set_option = 213;
  bool has_set_option() const;
  private:
  bool _internal_has_set_option() const;
  public:
  void clear_set_option();
  const ::maarpc::CustomControllerSetOptionParam& set_option() const;
  PROTOBUF_NODISCARD ::maarpc::CustomControllerSetOptionParam* release_set_option();
  ::maarpc::CustomControllerSetOptionParam* mutable_set_option();
  void set_allocated_set_option(::maarpc::CustomControllerSetOptionParam* set_option);
  private:
  const ::maarpc::CustomControllerSetOptionParam& _internal_set_option() const;
  ::maarpc::CustomControllerSetOptionParam* _internal_mutable_set_option();
  public:
  void unsafe_arena_set_allocated_set_option(
      ::maarpc::CustomControllerSetOptionParam* set_option);
  ::maarpc::CustomControllerSetOptionParam* unsafe_arena_release_set_option();

  void clear_command();
  CommandCase command_case() const;
  // @@protoc_insertion_point(class_scope:maarpc.CustomControllerResponse)
 private:
  class _Internal;
  void set_has_init();
  void set_has_connect();
  void set_has_click();
  void set_has_swipe();
  void set_has_key();
  void set_has_touch_down();
  void set_has_touch_move();
  void set_has_touch_up();
  void set_has_start();
  void set_has_stop();
  void set_has_resolution();
  void set_has_image();
  void set_has_uuid();
  void set_has_set_option();

  inline bool has_command() const;
  inline void clear_has_command();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union CommandUnion {
      constexpr CommandUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr init_;
      bool connect_;
      ::maarpc::ClickParam* click_;
      ::maarpc::SwipeParam* swipe_;
      ::maarpc::KeyParam* key_;
      ::maarpc::TouchParam* touch_down_;
      ::maarpc::TouchParam* touch_move_;
      ::maarpc::TouchParam* touch_up_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_;
      bool resolution_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
      bool uuid_;
      ::maarpc::CustomControllerSetOptionParam* set_option_;
    } command_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_custom_2econtroller_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CustomControllerSetOptionParam

// optional int32 key = 1;
inline bool CustomControllerSetOptionParam::_internal_has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CustomControllerSetOptionParam::has_key() const {
  return _internal_has_key();
}
inline void CustomControllerSetOptionParam::clear_key() {
  _impl_.key_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CustomControllerSetOptionParam::_internal_key() const {
  return _impl_.key_;
}
inline int32_t CustomControllerSetOptionParam::key() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerSetOptionParam.key)
  return _internal_key();
}
inline void CustomControllerSetOptionParam::_internal_set_key(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.key_ = value;
}
inline void CustomControllerSetOptionParam::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerSetOptionParam.key)
}

// optional string value = 2;
inline bool CustomControllerSetOptionParam::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CustomControllerSetOptionParam::has_value() const {
  return _internal_has_value();
}
inline void CustomControllerSetOptionParam::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomControllerSetOptionParam::value() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerSetOptionParam.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomControllerSetOptionParam::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerSetOptionParam.value)
}
inline std::string* CustomControllerSetOptionParam::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerSetOptionParam.value)
  return _s;
}
inline const std::string& CustomControllerSetOptionParam::_internal_value() const {
  return _impl_.value_.Get();
}
inline void CustomControllerSetOptionParam::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerSetOptionParam::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomControllerSetOptionParam::release_value() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerSetOptionParam.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CustomControllerSetOptionParam::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerSetOptionParam.value)
}

// -------------------------------------------------------------------

// CustomControllerRequest

// optional bool ok = 1;
inline bool CustomControllerRequest::_internal_has_ok() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CustomControllerRequest::has_ok() const {
  return _internal_has_ok();
}
inline void CustomControllerRequest::clear_ok() {
  _impl_.ok_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool CustomControllerRequest::_internal_ok() const {
  return _impl_.ok_;
}
inline bool CustomControllerRequest::ok() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerRequest.ok)
  return _internal_ok();
}
inline void CustomControllerRequest::_internal_set_ok(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ok_ = value;
}
inline void CustomControllerRequest::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerRequest.ok)
}

// string init = 101;
inline bool CustomControllerRequest::_internal_has_init() const {
  return result_case() == kInit;
}
inline bool CustomControllerRequest::has_init() const {
  return _internal_has_init();
}
inline void CustomControllerRequest::set_has_init() {
  _impl_._oneof_case_[0] = kInit;
}
inline void CustomControllerRequest::clear_init() {
  if (_internal_has_init()) {
    _impl_.result_.init_.Destroy();
    clear_has_result();
  }
}
inline const std::string& CustomControllerRequest::init() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerRequest.init)
  return _internal_init();
}
template <typename ArgT0, typename... ArgT>
inline void CustomControllerRequest::set_init(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_init()) {
    clear_result();
    set_has_init();
    _impl_.result_.init_.InitDefault();
  }
  _impl_.result_.init_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerRequest.init)
}
inline std::string* CustomControllerRequest::mutable_init() {
  std::string* _s = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerRequest.init)
  return _s;
}
inline const std::string& CustomControllerRequest::_internal_init() const {
  if (_internal_has_init()) {
    return _impl_.result_.init_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomControllerRequest::_internal_set_init(const std::string& value) {
  if (!_internal_has_init()) {
    clear_result();
    set_has_init();
    _impl_.result_.init_.InitDefault();
  }
  _impl_.result_.init_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerRequest::_internal_mutable_init() {
  if (!_internal_has_init()) {
    clear_result();
    set_has_init();
    _impl_.result_.init_.InitDefault();
  }
  return _impl_.result_.init_.Mutable(      GetArenaForAllocation());
}
inline std::string* CustomControllerRequest::release_init() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerRequest.init)
  if (_internal_has_init()) {
    clear_has_result();
    return _impl_.result_.init_.Release();
  } else {
    return nullptr;
  }
}
inline void CustomControllerRequest::set_allocated_init(std::string* init) {
  if (has_result()) {
    clear_result();
  }
  if (init != nullptr) {
    set_has_init();
    _impl_.result_.init_.InitAllocated(init, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerRequest.init)
}

// .maarpc.Size resolution = 201;
inline bool CustomControllerRequest::_internal_has_resolution() const {
  return result_case() == kResolution;
}
inline bool CustomControllerRequest::has_resolution() const {
  return _internal_has_resolution();
}
inline void CustomControllerRequest::set_has_resolution() {
  _impl_._oneof_case_[0] = kResolution;
}
inline ::maarpc::Size* CustomControllerRequest::release_resolution() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerRequest.resolution)
  if (_internal_has_resolution()) {
    clear_has_result();
    ::maarpc::Size* temp = _impl_.result_.resolution_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.resolution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::Size& CustomControllerRequest::_internal_resolution() const {
  return _internal_has_resolution()
      ? *_impl_.result_.resolution_
      : reinterpret_cast< ::maarpc::Size&>(::maarpc::_Size_default_instance_);
}
inline const ::maarpc::Size& CustomControllerRequest::resolution() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerRequest.resolution)
  return _internal_resolution();
}
inline ::maarpc::Size* CustomControllerRequest::unsafe_arena_release_resolution() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerRequest.resolution)
  if (_internal_has_resolution()) {
    clear_has_result();
    ::maarpc::Size* temp = _impl_.result_.resolution_;
    _impl_.result_.resolution_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerRequest::unsafe_arena_set_allocated_resolution(::maarpc::Size* resolution) {
  clear_result();
  if (resolution) {
    set_has_resolution();
    _impl_.result_.resolution_ = resolution;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerRequest.resolution)
}
inline ::maarpc::Size* CustomControllerRequest::_internal_mutable_resolution() {
  if (!_internal_has_resolution()) {
    clear_result();
    set_has_resolution();
    _impl_.result_.resolution_ = CreateMaybeMessage< ::maarpc::Size >(GetArenaForAllocation());
  }
  return _impl_.result_.resolution_;
}
inline ::maarpc::Size* CustomControllerRequest::mutable_resolution() {
  ::maarpc::Size* _msg = _internal_mutable_resolution();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerRequest.resolution)
  return _msg;
}

// string uuid = 202;
inline bool CustomControllerRequest::_internal_has_uuid() const {
  return result_case() == kUuid;
}
inline bool CustomControllerRequest::has_uuid() const {
  return _internal_has_uuid();
}
inline void CustomControllerRequest::set_has_uuid() {
  _impl_._oneof_case_[0] = kUuid;
}
inline void CustomControllerRequest::clear_uuid() {
  if (_internal_has_uuid()) {
    _impl_.result_.uuid_.Destroy();
    clear_has_result();
  }
}
inline const std::string& CustomControllerRequest::uuid() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerRequest.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline void CustomControllerRequest::set_uuid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_uuid()) {
    clear_result();
    set_has_uuid();
    _impl_.result_.uuid_.InitDefault();
  }
  _impl_.result_.uuid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerRequest.uuid)
}
inline std::string* CustomControllerRequest::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerRequest.uuid)
  return _s;
}
inline const std::string& CustomControllerRequest::_internal_uuid() const {
  if (_internal_has_uuid()) {
    return _impl_.result_.uuid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomControllerRequest::_internal_set_uuid(const std::string& value) {
  if (!_internal_has_uuid()) {
    clear_result();
    set_has_uuid();
    _impl_.result_.uuid_.InitDefault();
  }
  _impl_.result_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerRequest::_internal_mutable_uuid() {
  if (!_internal_has_uuid()) {
    clear_result();
    set_has_uuid();
    _impl_.result_.uuid_.InitDefault();
  }
  return _impl_.result_.uuid_.Mutable(      GetArenaForAllocation());
}
inline std::string* CustomControllerRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerRequest.uuid)
  if (_internal_has_uuid()) {
    clear_has_result();
    return _impl_.result_.uuid_.Release();
  } else {
    return nullptr;
  }
}
inline void CustomControllerRequest::set_allocated_uuid(std::string* uuid) {
  if (has_result()) {
    clear_result();
  }
  if (uuid != nullptr) {
    set_has_uuid();
    _impl_.result_.uuid_.InitAllocated(uuid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerRequest.uuid)
}

inline bool CustomControllerRequest::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void CustomControllerRequest::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline CustomControllerRequest::ResultCase CustomControllerRequest::result_case() const {
  return CustomControllerRequest::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CustomControllerResponse

// string init = 101;
inline bool CustomControllerResponse::_internal_has_init() const {
  return command_case() == kInit;
}
inline bool CustomControllerResponse::has_init() const {
  return _internal_has_init();
}
inline void CustomControllerResponse::set_has_init() {
  _impl_._oneof_case_[0] = kInit;
}
inline void CustomControllerResponse::clear_init() {
  if (_internal_has_init()) {
    _impl_.command_.init_.Destroy();
    clear_has_command();
  }
}
inline const std::string& CustomControllerResponse::init() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.init)
  return _internal_init();
}
template <typename ArgT0, typename... ArgT>
inline void CustomControllerResponse::set_init(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_init()) {
    clear_command();
    set_has_init();
    _impl_.command_.init_.InitDefault();
  }
  _impl_.command_.init_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.init)
}
inline std::string* CustomControllerResponse::mutable_init() {
  std::string* _s = _internal_mutable_init();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.init)
  return _s;
}
inline const std::string& CustomControllerResponse::_internal_init() const {
  if (_internal_has_init()) {
    return _impl_.command_.init_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomControllerResponse::_internal_set_init(const std::string& value) {
  if (!_internal_has_init()) {
    clear_command();
    set_has_init();
    _impl_.command_.init_.InitDefault();
  }
  _impl_.command_.init_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::_internal_mutable_init() {
  if (!_internal_has_init()) {
    clear_command();
    set_has_init();
    _impl_.command_.init_.InitDefault();
  }
  return _impl_.command_.init_.Mutable(      GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::release_init() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.init)
  if (_internal_has_init()) {
    clear_has_command();
    return _impl_.command_.init_.Release();
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::set_allocated_init(std::string* init) {
  if (has_command()) {
    clear_command();
  }
  if (init != nullptr) {
    set_has_init();
    _impl_.command_.init_.InitAllocated(init, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerResponse.init)
}

// bool connect = 201;
inline bool CustomControllerResponse::_internal_has_connect() const {
  return command_case() == kConnect;
}
inline bool CustomControllerResponse::has_connect() const {
  return _internal_has_connect();
}
inline void CustomControllerResponse::set_has_connect() {
  _impl_._oneof_case_[0] = kConnect;
}
inline void CustomControllerResponse::clear_connect() {
  if (_internal_has_connect()) {
    _impl_.command_.connect_ = false;
    clear_has_command();
  }
}
inline bool CustomControllerResponse::_internal_connect() const {
  if (_internal_has_connect()) {
    return _impl_.command_.connect_;
  }
  return false;
}
inline void CustomControllerResponse::_internal_set_connect(bool value) {
  if (!_internal_has_connect()) {
    clear_command();
    set_has_connect();
  }
  _impl_.command_.connect_ = value;
}
inline bool CustomControllerResponse::connect() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.connect)
  return _internal_connect();
}
inline void CustomControllerResponse::set_connect(bool value) {
  _internal_set_connect(value);
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.connect)
}

// .maarpc.ClickParam click = 202;
inline bool CustomControllerResponse::_internal_has_click() const {
  return command_case() == kClick;
}
inline bool CustomControllerResponse::has_click() const {
  return _internal_has_click();
}
inline void CustomControllerResponse::set_has_click() {
  _impl_._oneof_case_[0] = kClick;
}
inline ::maarpc::ClickParam* CustomControllerResponse::release_click() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.click)
  if (_internal_has_click()) {
    clear_has_command();
    ::maarpc::ClickParam* temp = _impl_.command_.click_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.click_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::ClickParam& CustomControllerResponse::_internal_click() const {
  return _internal_has_click()
      ? *_impl_.command_.click_
      : reinterpret_cast< ::maarpc::ClickParam&>(::maarpc::_ClickParam_default_instance_);
}
inline const ::maarpc::ClickParam& CustomControllerResponse::click() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.click)
  return _internal_click();
}
inline ::maarpc::ClickParam* CustomControllerResponse::unsafe_arena_release_click() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.click)
  if (_internal_has_click()) {
    clear_has_command();
    ::maarpc::ClickParam* temp = _impl_.command_.click_;
    _impl_.command_.click_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_click(::maarpc::ClickParam* click) {
  clear_command();
  if (click) {
    set_has_click();
    _impl_.command_.click_ = click;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.click)
}
inline ::maarpc::ClickParam* CustomControllerResponse::_internal_mutable_click() {
  if (!_internal_has_click()) {
    clear_command();
    set_has_click();
    _impl_.command_.click_ = CreateMaybeMessage< ::maarpc::ClickParam >(GetArenaForAllocation());
  }
  return _impl_.command_.click_;
}
inline ::maarpc::ClickParam* CustomControllerResponse::mutable_click() {
  ::maarpc::ClickParam* _msg = _internal_mutable_click();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.click)
  return _msg;
}

// .maarpc.SwipeParam swipe = 203;
inline bool CustomControllerResponse::_internal_has_swipe() const {
  return command_case() == kSwipe;
}
inline bool CustomControllerResponse::has_swipe() const {
  return _internal_has_swipe();
}
inline void CustomControllerResponse::set_has_swipe() {
  _impl_._oneof_case_[0] = kSwipe;
}
inline ::maarpc::SwipeParam* CustomControllerResponse::release_swipe() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.swipe)
  if (_internal_has_swipe()) {
    clear_has_command();
    ::maarpc::SwipeParam* temp = _impl_.command_.swipe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.swipe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::SwipeParam& CustomControllerResponse::_internal_swipe() const {
  return _internal_has_swipe()
      ? *_impl_.command_.swipe_
      : reinterpret_cast< ::maarpc::SwipeParam&>(::maarpc::_SwipeParam_default_instance_);
}
inline const ::maarpc::SwipeParam& CustomControllerResponse::swipe() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.swipe)
  return _internal_swipe();
}
inline ::maarpc::SwipeParam* CustomControllerResponse::unsafe_arena_release_swipe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.swipe)
  if (_internal_has_swipe()) {
    clear_has_command();
    ::maarpc::SwipeParam* temp = _impl_.command_.swipe_;
    _impl_.command_.swipe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_swipe(::maarpc::SwipeParam* swipe) {
  clear_command();
  if (swipe) {
    set_has_swipe();
    _impl_.command_.swipe_ = swipe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.swipe)
}
inline ::maarpc::SwipeParam* CustomControllerResponse::_internal_mutable_swipe() {
  if (!_internal_has_swipe()) {
    clear_command();
    set_has_swipe();
    _impl_.command_.swipe_ = CreateMaybeMessage< ::maarpc::SwipeParam >(GetArenaForAllocation());
  }
  return _impl_.command_.swipe_;
}
inline ::maarpc::SwipeParam* CustomControllerResponse::mutable_swipe() {
  ::maarpc::SwipeParam* _msg = _internal_mutable_swipe();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.swipe)
  return _msg;
}

// .maarpc.KeyParam key = 204;
inline bool CustomControllerResponse::_internal_has_key() const {
  return command_case() == kKey;
}
inline bool CustomControllerResponse::has_key() const {
  return _internal_has_key();
}
inline void CustomControllerResponse::set_has_key() {
  _impl_._oneof_case_[0] = kKey;
}
inline ::maarpc::KeyParam* CustomControllerResponse::release_key() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.key)
  if (_internal_has_key()) {
    clear_has_command();
    ::maarpc::KeyParam* temp = _impl_.command_.key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::KeyParam& CustomControllerResponse::_internal_key() const {
  return _internal_has_key()
      ? *_impl_.command_.key_
      : reinterpret_cast< ::maarpc::KeyParam&>(::maarpc::_KeyParam_default_instance_);
}
inline const ::maarpc::KeyParam& CustomControllerResponse::key() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.key)
  return _internal_key();
}
inline ::maarpc::KeyParam* CustomControllerResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.key)
  if (_internal_has_key()) {
    clear_has_command();
    ::maarpc::KeyParam* temp = _impl_.command_.key_;
    _impl_.command_.key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_key(::maarpc::KeyParam* key) {
  clear_command();
  if (key) {
    set_has_key();
    _impl_.command_.key_ = key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.key)
}
inline ::maarpc::KeyParam* CustomControllerResponse::_internal_mutable_key() {
  if (!_internal_has_key()) {
    clear_command();
    set_has_key();
    _impl_.command_.key_ = CreateMaybeMessage< ::maarpc::KeyParam >(GetArenaForAllocation());
  }
  return _impl_.command_.key_;
}
inline ::maarpc::KeyParam* CustomControllerResponse::mutable_key() {
  ::maarpc::KeyParam* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.key)
  return _msg;
}

// .maarpc.TouchParam touch_down = 205;
inline bool CustomControllerResponse::_internal_has_touch_down() const {
  return command_case() == kTouchDown;
}
inline bool CustomControllerResponse::has_touch_down() const {
  return _internal_has_touch_down();
}
inline void CustomControllerResponse::set_has_touch_down() {
  _impl_._oneof_case_[0] = kTouchDown;
}
inline ::maarpc::TouchParam* CustomControllerResponse::release_touch_down() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.touch_down)
  if (_internal_has_touch_down()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_down_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.touch_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::TouchParam& CustomControllerResponse::_internal_touch_down() const {
  return _internal_has_touch_down()
      ? *_impl_.command_.touch_down_
      : reinterpret_cast< ::maarpc::TouchParam&>(::maarpc::_TouchParam_default_instance_);
}
inline const ::maarpc::TouchParam& CustomControllerResponse::touch_down() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.touch_down)
  return _internal_touch_down();
}
inline ::maarpc::TouchParam* CustomControllerResponse::unsafe_arena_release_touch_down() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.touch_down)
  if (_internal_has_touch_down()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_down_;
    _impl_.command_.touch_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_touch_down(::maarpc::TouchParam* touch_down) {
  clear_command();
  if (touch_down) {
    set_has_touch_down();
    _impl_.command_.touch_down_ = touch_down;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.touch_down)
}
inline ::maarpc::TouchParam* CustomControllerResponse::_internal_mutable_touch_down() {
  if (!_internal_has_touch_down()) {
    clear_command();
    set_has_touch_down();
    _impl_.command_.touch_down_ = CreateMaybeMessage< ::maarpc::TouchParam >(GetArenaForAllocation());
  }
  return _impl_.command_.touch_down_;
}
inline ::maarpc::TouchParam* CustomControllerResponse::mutable_touch_down() {
  ::maarpc::TouchParam* _msg = _internal_mutable_touch_down();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.touch_down)
  return _msg;
}

// .maarpc.TouchParam touch_move = 206;
inline bool CustomControllerResponse::_internal_has_touch_move() const {
  return command_case() == kTouchMove;
}
inline bool CustomControllerResponse::has_touch_move() const {
  return _internal_has_touch_move();
}
inline void CustomControllerResponse::set_has_touch_move() {
  _impl_._oneof_case_[0] = kTouchMove;
}
inline ::maarpc::TouchParam* CustomControllerResponse::release_touch_move() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.touch_move)
  if (_internal_has_touch_move()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_move_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.touch_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::TouchParam& CustomControllerResponse::_internal_touch_move() const {
  return _internal_has_touch_move()
      ? *_impl_.command_.touch_move_
      : reinterpret_cast< ::maarpc::TouchParam&>(::maarpc::_TouchParam_default_instance_);
}
inline const ::maarpc::TouchParam& CustomControllerResponse::touch_move() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.touch_move)
  return _internal_touch_move();
}
inline ::maarpc::TouchParam* CustomControllerResponse::unsafe_arena_release_touch_move() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.touch_move)
  if (_internal_has_touch_move()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_move_;
    _impl_.command_.touch_move_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_touch_move(::maarpc::TouchParam* touch_move) {
  clear_command();
  if (touch_move) {
    set_has_touch_move();
    _impl_.command_.touch_move_ = touch_move;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.touch_move)
}
inline ::maarpc::TouchParam* CustomControllerResponse::_internal_mutable_touch_move() {
  if (!_internal_has_touch_move()) {
    clear_command();
    set_has_touch_move();
    _impl_.command_.touch_move_ = CreateMaybeMessage< ::maarpc::TouchParam >(GetArenaForAllocation());
  }
  return _impl_.command_.touch_move_;
}
inline ::maarpc::TouchParam* CustomControllerResponse::mutable_touch_move() {
  ::maarpc::TouchParam* _msg = _internal_mutable_touch_move();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.touch_move)
  return _msg;
}

// .maarpc.TouchParam touch_up = 207;
inline bool CustomControllerResponse::_internal_has_touch_up() const {
  return command_case() == kTouchUp;
}
inline bool CustomControllerResponse::has_touch_up() const {
  return _internal_has_touch_up();
}
inline void CustomControllerResponse::set_has_touch_up() {
  _impl_._oneof_case_[0] = kTouchUp;
}
inline ::maarpc::TouchParam* CustomControllerResponse::release_touch_up() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.touch_up)
  if (_internal_has_touch_up()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_up_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.touch_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::TouchParam& CustomControllerResponse::_internal_touch_up() const {
  return _internal_has_touch_up()
      ? *_impl_.command_.touch_up_
      : reinterpret_cast< ::maarpc::TouchParam&>(::maarpc::_TouchParam_default_instance_);
}
inline const ::maarpc::TouchParam& CustomControllerResponse::touch_up() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.touch_up)
  return _internal_touch_up();
}
inline ::maarpc::TouchParam* CustomControllerResponse::unsafe_arena_release_touch_up() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.touch_up)
  if (_internal_has_touch_up()) {
    clear_has_command();
    ::maarpc::TouchParam* temp = _impl_.command_.touch_up_;
    _impl_.command_.touch_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_touch_up(::maarpc::TouchParam* touch_up) {
  clear_command();
  if (touch_up) {
    set_has_touch_up();
    _impl_.command_.touch_up_ = touch_up;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.touch_up)
}
inline ::maarpc::TouchParam* CustomControllerResponse::_internal_mutable_touch_up() {
  if (!_internal_has_touch_up()) {
    clear_command();
    set_has_touch_up();
    _impl_.command_.touch_up_ = CreateMaybeMessage< ::maarpc::TouchParam >(GetArenaForAllocation());
  }
  return _impl_.command_.touch_up_;
}
inline ::maarpc::TouchParam* CustomControllerResponse::mutable_touch_up() {
  ::maarpc::TouchParam* _msg = _internal_mutable_touch_up();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.touch_up)
  return _msg;
}

// string start = 208;
inline bool CustomControllerResponse::_internal_has_start() const {
  return command_case() == kStart;
}
inline bool CustomControllerResponse::has_start() const {
  return _internal_has_start();
}
inline void CustomControllerResponse::set_has_start() {
  _impl_._oneof_case_[0] = kStart;
}
inline void CustomControllerResponse::clear_start() {
  if (_internal_has_start()) {
    _impl_.command_.start_.Destroy();
    clear_has_command();
  }
}
inline const std::string& CustomControllerResponse::start() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.start)
  return _internal_start();
}
template <typename ArgT0, typename... ArgT>
inline void CustomControllerResponse::set_start(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_start()) {
    clear_command();
    set_has_start();
    _impl_.command_.start_.InitDefault();
  }
  _impl_.command_.start_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.start)
}
inline std::string* CustomControllerResponse::mutable_start() {
  std::string* _s = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.start)
  return _s;
}
inline const std::string& CustomControllerResponse::_internal_start() const {
  if (_internal_has_start()) {
    return _impl_.command_.start_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomControllerResponse::_internal_set_start(const std::string& value) {
  if (!_internal_has_start()) {
    clear_command();
    set_has_start();
    _impl_.command_.start_.InitDefault();
  }
  _impl_.command_.start_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::_internal_mutable_start() {
  if (!_internal_has_start()) {
    clear_command();
    set_has_start();
    _impl_.command_.start_.InitDefault();
  }
  return _impl_.command_.start_.Mutable(      GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::release_start() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.start)
  if (_internal_has_start()) {
    clear_has_command();
    return _impl_.command_.start_.Release();
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::set_allocated_start(std::string* start) {
  if (has_command()) {
    clear_command();
  }
  if (start != nullptr) {
    set_has_start();
    _impl_.command_.start_.InitAllocated(start, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerResponse.start)
}

// string stop = 209;
inline bool CustomControllerResponse::_internal_has_stop() const {
  return command_case() == kStop;
}
inline bool CustomControllerResponse::has_stop() const {
  return _internal_has_stop();
}
inline void CustomControllerResponse::set_has_stop() {
  _impl_._oneof_case_[0] = kStop;
}
inline void CustomControllerResponse::clear_stop() {
  if (_internal_has_stop()) {
    _impl_.command_.stop_.Destroy();
    clear_has_command();
  }
}
inline const std::string& CustomControllerResponse::stop() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.stop)
  return _internal_stop();
}
template <typename ArgT0, typename... ArgT>
inline void CustomControllerResponse::set_stop(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_stop()) {
    clear_command();
    set_has_stop();
    _impl_.command_.stop_.InitDefault();
  }
  _impl_.command_.stop_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.stop)
}
inline std::string* CustomControllerResponse::mutable_stop() {
  std::string* _s = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.stop)
  return _s;
}
inline const std::string& CustomControllerResponse::_internal_stop() const {
  if (_internal_has_stop()) {
    return _impl_.command_.stop_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomControllerResponse::_internal_set_stop(const std::string& value) {
  if (!_internal_has_stop()) {
    clear_command();
    set_has_stop();
    _impl_.command_.stop_.InitDefault();
  }
  _impl_.command_.stop_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::_internal_mutable_stop() {
  if (!_internal_has_stop()) {
    clear_command();
    set_has_stop();
    _impl_.command_.stop_.InitDefault();
  }
  return _impl_.command_.stop_.Mutable(      GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::release_stop() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.stop)
  if (_internal_has_stop()) {
    clear_has_command();
    return _impl_.command_.stop_.Release();
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::set_allocated_stop(std::string* stop) {
  if (has_command()) {
    clear_command();
  }
  if (stop != nullptr) {
    set_has_stop();
    _impl_.command_.stop_.InitAllocated(stop, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerResponse.stop)
}

// bool resolution = 210;
inline bool CustomControllerResponse::_internal_has_resolution() const {
  return command_case() == kResolution;
}
inline bool CustomControllerResponse::has_resolution() const {
  return _internal_has_resolution();
}
inline void CustomControllerResponse::set_has_resolution() {
  _impl_._oneof_case_[0] = kResolution;
}
inline void CustomControllerResponse::clear_resolution() {
  if (_internal_has_resolution()) {
    _impl_.command_.resolution_ = false;
    clear_has_command();
  }
}
inline bool CustomControllerResponse::_internal_resolution() const {
  if (_internal_has_resolution()) {
    return _impl_.command_.resolution_;
  }
  return false;
}
inline void CustomControllerResponse::_internal_set_resolution(bool value) {
  if (!_internal_has_resolution()) {
    clear_command();
    set_has_resolution();
  }
  _impl_.command_.resolution_ = value;
}
inline bool CustomControllerResponse::resolution() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.resolution)
  return _internal_resolution();
}
inline void CustomControllerResponse::set_resolution(bool value) {
  _internal_set_resolution(value);
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.resolution)
}

// string image = 211;
inline bool CustomControllerResponse::_internal_has_image() const {
  return command_case() == kImage;
}
inline bool CustomControllerResponse::has_image() const {
  return _internal_has_image();
}
inline void CustomControllerResponse::set_has_image() {
  _impl_._oneof_case_[0] = kImage;
}
inline void CustomControllerResponse::clear_image() {
  if (_internal_has_image()) {
    _impl_.command_.image_.Destroy();
    clear_has_command();
  }
}
inline const std::string& CustomControllerResponse::image() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline void CustomControllerResponse::set_image(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_image()) {
    clear_command();
    set_has_image();
    _impl_.command_.image_.InitDefault();
  }
  _impl_.command_.image_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.image)
}
inline std::string* CustomControllerResponse::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.image)
  return _s;
}
inline const std::string& CustomControllerResponse::_internal_image() const {
  if (_internal_has_image()) {
    return _impl_.command_.image_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CustomControllerResponse::_internal_set_image(const std::string& value) {
  if (!_internal_has_image()) {
    clear_command();
    set_has_image();
    _impl_.command_.image_.InitDefault();
  }
  _impl_.command_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::_internal_mutable_image() {
  if (!_internal_has_image()) {
    clear_command();
    set_has_image();
    _impl_.command_.image_.InitDefault();
  }
  return _impl_.command_.image_.Mutable(      GetArenaForAllocation());
}
inline std::string* CustomControllerResponse::release_image() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.image)
  if (_internal_has_image()) {
    clear_has_command();
    return _impl_.command_.image_.Release();
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::set_allocated_image(std::string* image) {
  if (has_command()) {
    clear_command();
  }
  if (image != nullptr) {
    set_has_image();
    _impl_.command_.image_.InitAllocated(image, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:maarpc.CustomControllerResponse.image)
}

// bool uuid = 212;
inline bool CustomControllerResponse::_internal_has_uuid() const {
  return command_case() == kUuid;
}
inline bool CustomControllerResponse::has_uuid() const {
  return _internal_has_uuid();
}
inline void CustomControllerResponse::set_has_uuid() {
  _impl_._oneof_case_[0] = kUuid;
}
inline void CustomControllerResponse::clear_uuid() {
  if (_internal_has_uuid()) {
    _impl_.command_.uuid_ = false;
    clear_has_command();
  }
}
inline bool CustomControllerResponse::_internal_uuid() const {
  if (_internal_has_uuid()) {
    return _impl_.command_.uuid_;
  }
  return false;
}
inline void CustomControllerResponse::_internal_set_uuid(bool value) {
  if (!_internal_has_uuid()) {
    clear_command();
    set_has_uuid();
  }
  _impl_.command_.uuid_ = value;
}
inline bool CustomControllerResponse::uuid() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.uuid)
  return _internal_uuid();
}
inline void CustomControllerResponse::set_uuid(bool value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:maarpc.CustomControllerResponse.uuid)
}

// .maarpc.CustomControllerSetOptionParam set_option = 213;
inline bool CustomControllerResponse::_internal_has_set_option() const {
  return command_case() == kSetOption;
}
inline bool CustomControllerResponse::has_set_option() const {
  return _internal_has_set_option();
}
inline void CustomControllerResponse::set_has_set_option() {
  _impl_._oneof_case_[0] = kSetOption;
}
inline void CustomControllerResponse::clear_set_option() {
  if (_internal_has_set_option()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.command_.set_option_;
    }
    clear_has_command();
  }
}
inline ::maarpc::CustomControllerSetOptionParam* CustomControllerResponse::release_set_option() {
  // @@protoc_insertion_point(field_release:maarpc.CustomControllerResponse.set_option)
  if (_internal_has_set_option()) {
    clear_has_command();
    ::maarpc::CustomControllerSetOptionParam* temp = _impl_.command_.set_option_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.command_.set_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::maarpc::CustomControllerSetOptionParam& CustomControllerResponse::_internal_set_option() const {
  return _internal_has_set_option()
      ? *_impl_.command_.set_option_
      : reinterpret_cast< ::maarpc::CustomControllerSetOptionParam&>(::maarpc::_CustomControllerSetOptionParam_default_instance_);
}
inline const ::maarpc::CustomControllerSetOptionParam& CustomControllerResponse::set_option() const {
  // @@protoc_insertion_point(field_get:maarpc.CustomControllerResponse.set_option)
  return _internal_set_option();
}
inline ::maarpc::CustomControllerSetOptionParam* CustomControllerResponse::unsafe_arena_release_set_option() {
  // @@protoc_insertion_point(field_unsafe_arena_release:maarpc.CustomControllerResponse.set_option)
  if (_internal_has_set_option()) {
    clear_has_command();
    ::maarpc::CustomControllerSetOptionParam* temp = _impl_.command_.set_option_;
    _impl_.command_.set_option_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CustomControllerResponse::unsafe_arena_set_allocated_set_option(::maarpc::CustomControllerSetOptionParam* set_option) {
  clear_command();
  if (set_option) {
    set_has_set_option();
    _impl_.command_.set_option_ = set_option;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.CustomControllerResponse.set_option)
}
inline ::maarpc::CustomControllerSetOptionParam* CustomControllerResponse::_internal_mutable_set_option() {
  if (!_internal_has_set_option()) {
    clear_command();
    set_has_set_option();
    _impl_.command_.set_option_ = CreateMaybeMessage< ::maarpc::CustomControllerSetOptionParam >(GetArenaForAllocation());
  }
  return _impl_.command_.set_option_;
}
inline ::maarpc::CustomControllerSetOptionParam* CustomControllerResponse::mutable_set_option() {
  ::maarpc::CustomControllerSetOptionParam* _msg = _internal_mutable_set_option();
  // @@protoc_insertion_point(field_mutable:maarpc.CustomControllerResponse.set_option)
  return _msg;
}

inline bool CustomControllerResponse::has_command() const {
  return command_case() != COMMAND_NOT_SET;
}
inline void CustomControllerResponse::clear_has_command() {
  _impl_._oneof_case_[0] = COMMAND_NOT_SET;
}
inline CustomControllerResponse::CommandCase CustomControllerResponse::command_case() const {
  return CustomControllerResponse::CommandCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace maarpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_custom_2econtroller_2eproto
