// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sync.context.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sync_2econtext_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sync_2econtext_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sync_2econtext_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sync_2econtext_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sync_2econtext_2eproto;
namespace maarpc {
class SyncContextClickRequest;
struct SyncContextClickRequestDefaultTypeInternal;
extern SyncContextClickRequestDefaultTypeInternal _SyncContextClickRequest_default_instance_;
class SyncContextKeyRequest;
struct SyncContextKeyRequestDefaultTypeInternal;
extern SyncContextKeyRequestDefaultTypeInternal _SyncContextKeyRequest_default_instance_;
class SyncContextRunActionRequest;
struct SyncContextRunActionRequestDefaultTypeInternal;
extern SyncContextRunActionRequestDefaultTypeInternal _SyncContextRunActionRequest_default_instance_;
class SyncContextRunRecognizerRequest;
struct SyncContextRunRecognizerRequestDefaultTypeInternal;
extern SyncContextRunRecognizerRequestDefaultTypeInternal _SyncContextRunRecognizerRequest_default_instance_;
class SyncContextRunRecognizerResponse;
struct SyncContextRunRecognizerResponseDefaultTypeInternal;
extern SyncContextRunRecognizerResponseDefaultTypeInternal _SyncContextRunRecognizerResponse_default_instance_;
class SyncContextRunTaskRequest;
struct SyncContextRunTaskRequestDefaultTypeInternal;
extern SyncContextRunTaskRequestDefaultTypeInternal _SyncContextRunTaskRequest_default_instance_;
class SyncContextScreencapRequest;
struct SyncContextScreencapRequestDefaultTypeInternal;
extern SyncContextScreencapRequestDefaultTypeInternal _SyncContextScreencapRequest_default_instance_;
class SyncContextSwipeRequest;
struct SyncContextSwipeRequestDefaultTypeInternal;
extern SyncContextSwipeRequestDefaultTypeInternal _SyncContextSwipeRequest_default_instance_;
class SyncContextTouchRequest;
struct SyncContextTouchRequestDefaultTypeInternal;
extern SyncContextTouchRequestDefaultTypeInternal _SyncContextTouchRequest_default_instance_;
}  // namespace maarpc
PROTOBUF_NAMESPACE_OPEN
template<> ::maarpc::SyncContextClickRequest* Arena::CreateMaybeMessage<::maarpc::SyncContextClickRequest>(Arena*);
template<> ::maarpc::SyncContextKeyRequest* Arena::CreateMaybeMessage<::maarpc::SyncContextKeyRequest>(Arena*);
template<> ::maarpc::SyncContextRunActionRequest* Arena::CreateMaybeMessage<::maarpc::SyncContextRunActionRequest>(Arena*);
template<> ::maarpc::SyncContextRunRecognizerRequest* Arena::CreateMaybeMessage<::maarpc::SyncContextRunRecognizerRequest>(Arena*);
template<> ::maarpc::SyncContextRunRecognizerResponse* Arena::CreateMaybeMessage<::maarpc::SyncContextRunRecognizerResponse>(Arena*);
template<> ::maarpc::SyncContextRunTaskRequest* Arena::CreateMaybeMessage<::maarpc::SyncContextRunTaskRequest>(Arena*);
template<> ::maarpc::SyncContextScreencapRequest* Arena::CreateMaybeMessage<::maarpc::SyncContextScreencapRequest>(Arena*);
template<> ::maarpc::SyncContextSwipeRequest* Arena::CreateMaybeMessage<::maarpc::SyncContextSwipeRequest>(Arena*);
template<> ::maarpc::SyncContextTouchRequest* Arena::CreateMaybeMessage<::maarpc::SyncContextTouchRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace maarpc {

// ===================================================================

class SyncContextRunTaskRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SyncContextRunTaskRequest) */ {
 public:
  inline SyncContextRunTaskRequest() : SyncContextRunTaskRequest(nullptr) {}
  ~SyncContextRunTaskRequest() override;
  explicit PROTOBUF_CONSTEXPR SyncContextRunTaskRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncContextRunTaskRequest(const SyncContextRunTaskRequest& from);
  SyncContextRunTaskRequest(SyncContextRunTaskRequest&& from) noexcept
    : SyncContextRunTaskRequest() {
    *this = ::std::move(from);
  }

  inline SyncContextRunTaskRequest& operator=(const SyncContextRunTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncContextRunTaskRequest& operator=(SyncContextRunTaskRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncContextRunTaskRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncContextRunTaskRequest* internal_default_instance() {
    return reinterpret_cast<const SyncContextRunTaskRequest*>(
               &_SyncContextRunTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SyncContextRunTaskRequest& a, SyncContextRunTaskRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncContextRunTaskRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncContextRunTaskRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncContextRunTaskRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncContextRunTaskRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncContextRunTaskRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncContextRunTaskRequest& from) {
    SyncContextRunTaskRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncContextRunTaskRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SyncContextRunTaskRequest";
  }
  protected:
  explicit SyncContextRunTaskRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kTaskFieldNumber = 2,
    kParamFieldNumber = 3,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional string task = 2;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const std::string& task() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task();
  PROTOBUF_NODISCARD std::string* release_task();
  void set_allocated_task(std::string* task);
  private:
  const std::string& _internal_task() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task(const std::string& value);
  std::string* _internal_mutable_task();
  public:

  // optional string param = 3;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const std::string& param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_param();
  PROTOBUF_NODISCARD std::string* release_param();
  void set_allocated_param(std::string* param);
  private:
  const std::string& _internal_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param(const std::string& value);
  std::string* _internal_mutable_param();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.SyncContextRunTaskRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr param_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sync_2econtext_2eproto;
};
// -------------------------------------------------------------------

class SyncContextRunRecognizerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SyncContextRunRecognizerRequest) */ {
 public:
  inline SyncContextRunRecognizerRequest() : SyncContextRunRecognizerRequest(nullptr) {}
  ~SyncContextRunRecognizerRequest() override;
  explicit PROTOBUF_CONSTEXPR SyncContextRunRecognizerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncContextRunRecognizerRequest(const SyncContextRunRecognizerRequest& from);
  SyncContextRunRecognizerRequest(SyncContextRunRecognizerRequest&& from) noexcept
    : SyncContextRunRecognizerRequest() {
    *this = ::std::move(from);
  }

  inline SyncContextRunRecognizerRequest& operator=(const SyncContextRunRecognizerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncContextRunRecognizerRequest& operator=(SyncContextRunRecognizerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncContextRunRecognizerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncContextRunRecognizerRequest* internal_default_instance() {
    return reinterpret_cast<const SyncContextRunRecognizerRequest*>(
               &_SyncContextRunRecognizerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SyncContextRunRecognizerRequest& a, SyncContextRunRecognizerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncContextRunRecognizerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncContextRunRecognizerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncContextRunRecognizerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncContextRunRecognizerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncContextRunRecognizerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncContextRunRecognizerRequest& from) {
    SyncContextRunRecognizerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncContextRunRecognizerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SyncContextRunRecognizerRequest";
  }
  protected:
  explicit SyncContextRunRecognizerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kTaskFieldNumber = 2,
    kParamFieldNumber = 3,
    kImageHandleFieldNumber = 4,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional string task = 2;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const std::string& task() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task();
  PROTOBUF_NODISCARD std::string* release_task();
  void set_allocated_task(std::string* task);
  private:
  const std::string& _internal_task() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task(const std::string& value);
  std::string* _internal_mutable_task();
  public:

  // optional string param = 3;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const std::string& param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_param();
  PROTOBUF_NODISCARD std::string* release_param();
  void set_allocated_param(std::string* param);
  private:
  const std::string& _internal_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param(const std::string& value);
  std::string* _internal_mutable_param();
  public:

  // optional string image_handle = 4;
  bool has_image_handle() const;
  private:
  bool _internal_has_image_handle() const;
  public:
  void clear_image_handle();
  const std::string& image_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_handle();
  PROTOBUF_NODISCARD std::string* release_image_handle();
  void set_allocated_image_handle(std::string* image_handle);
  private:
  const std::string& _internal_image_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_handle(const std::string& value);
  std::string* _internal_mutable_image_handle();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.SyncContextRunRecognizerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr param_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sync_2econtext_2eproto;
};
// -------------------------------------------------------------------

class SyncContextRunRecognizerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SyncContextRunRecognizerResponse) */ {
 public:
  inline SyncContextRunRecognizerResponse() : SyncContextRunRecognizerResponse(nullptr) {}
  ~SyncContextRunRecognizerResponse() override;
  explicit PROTOBUF_CONSTEXPR SyncContextRunRecognizerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncContextRunRecognizerResponse(const SyncContextRunRecognizerResponse& from);
  SyncContextRunRecognizerResponse(SyncContextRunRecognizerResponse&& from) noexcept
    : SyncContextRunRecognizerResponse() {
    *this = ::std::move(from);
  }

  inline SyncContextRunRecognizerResponse& operator=(const SyncContextRunRecognizerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncContextRunRecognizerResponse& operator=(SyncContextRunRecognizerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncContextRunRecognizerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncContextRunRecognizerResponse* internal_default_instance() {
    return reinterpret_cast<const SyncContextRunRecognizerResponse*>(
               &_SyncContextRunRecognizerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SyncContextRunRecognizerResponse& a, SyncContextRunRecognizerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncContextRunRecognizerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncContextRunRecognizerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncContextRunRecognizerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncContextRunRecognizerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncContextRunRecognizerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncContextRunRecognizerResponse& from) {
    SyncContextRunRecognizerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncContextRunRecognizerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SyncContextRunRecognizerResponse";
  }
  protected:
  explicit SyncContextRunRecognizerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetailFieldNumber = 3,
    kBoxFieldNumber = 2,
    kMatchFieldNumber = 1,
  };
  // optional string detail = 3;
  bool has_detail() const;
  private:
  bool _internal_has_detail() const;
  public:
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // optional .maarpc.Rect box = 2;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::maarpc::Rect& box() const;
  PROTOBUF_NODISCARD ::maarpc::Rect* release_box();
  ::maarpc::Rect* mutable_box();
  void set_allocated_box(::maarpc::Rect* box);
  private:
  const ::maarpc::Rect& _internal_box() const;
  ::maarpc::Rect* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::maarpc::Rect* box);
  ::maarpc::Rect* unsafe_arena_release_box();

  // optional bool match = 1;
  bool has_match() const;
  private:
  bool _internal_has_match() const;
  public:
  void clear_match();
  bool match() const;
  void set_match(bool value);
  private:
  bool _internal_match() const;
  void _internal_set_match(bool value);
  public:

  // @@protoc_insertion_point(class_scope:maarpc.SyncContextRunRecognizerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    ::maarpc::Rect* box_;
    bool match_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sync_2econtext_2eproto;
};
// -------------------------------------------------------------------

class SyncContextRunActionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SyncContextRunActionRequest) */ {
 public:
  inline SyncContextRunActionRequest() : SyncContextRunActionRequest(nullptr) {}
  ~SyncContextRunActionRequest() override;
  explicit PROTOBUF_CONSTEXPR SyncContextRunActionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncContextRunActionRequest(const SyncContextRunActionRequest& from);
  SyncContextRunActionRequest(SyncContextRunActionRequest&& from) noexcept
    : SyncContextRunActionRequest() {
    *this = ::std::move(from);
  }

  inline SyncContextRunActionRequest& operator=(const SyncContextRunActionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncContextRunActionRequest& operator=(SyncContextRunActionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncContextRunActionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncContextRunActionRequest* internal_default_instance() {
    return reinterpret_cast<const SyncContextRunActionRequest*>(
               &_SyncContextRunActionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SyncContextRunActionRequest& a, SyncContextRunActionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncContextRunActionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncContextRunActionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncContextRunActionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncContextRunActionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncContextRunActionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncContextRunActionRequest& from) {
    SyncContextRunActionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncContextRunActionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SyncContextRunActionRequest";
  }
  protected:
  explicit SyncContextRunActionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kTaskFieldNumber = 2,
    kParamFieldNumber = 3,
    kDetailFieldNumber = 5,
    kBoxFieldNumber = 4,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional string task = 2;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const std::string& task() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task();
  PROTOBUF_NODISCARD std::string* release_task();
  void set_allocated_task(std::string* task);
  private:
  const std::string& _internal_task() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task(const std::string& value);
  std::string* _internal_mutable_task();
  public:

  // optional string param = 3;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const std::string& param() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_param(ArgT0&& arg0, ArgT... args);
  std::string* mutable_param();
  PROTOBUF_NODISCARD std::string* release_param();
  void set_allocated_param(std::string* param);
  private:
  const std::string& _internal_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param(const std::string& value);
  std::string* _internal_mutable_param();
  public:

  // optional string detail = 5;
  bool has_detail() const;
  private:
  bool _internal_has_detail() const;
  public:
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // optional .maarpc.Rect box = 4;
  bool has_box() const;
  private:
  bool _internal_has_box() const;
  public:
  void clear_box();
  const ::maarpc::Rect& box() const;
  PROTOBUF_NODISCARD ::maarpc::Rect* release_box();
  ::maarpc::Rect* mutable_box();
  void set_allocated_box(::maarpc::Rect* box);
  private:
  const ::maarpc::Rect& _internal_box() const;
  ::maarpc::Rect* _internal_mutable_box();
  public:
  void unsafe_arena_set_allocated_box(
      ::maarpc::Rect* box);
  ::maarpc::Rect* unsafe_arena_release_box();

  // @@protoc_insertion_point(class_scope:maarpc.SyncContextRunActionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr param_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
    ::maarpc::Rect* box_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sync_2econtext_2eproto;
};
// -------------------------------------------------------------------

class SyncContextClickRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SyncContextClickRequest) */ {
 public:
  inline SyncContextClickRequest() : SyncContextClickRequest(nullptr) {}
  ~SyncContextClickRequest() override;
  explicit PROTOBUF_CONSTEXPR SyncContextClickRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncContextClickRequest(const SyncContextClickRequest& from);
  SyncContextClickRequest(SyncContextClickRequest&& from) noexcept
    : SyncContextClickRequest() {
    *this = ::std::move(from);
  }

  inline SyncContextClickRequest& operator=(const SyncContextClickRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncContextClickRequest& operator=(SyncContextClickRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncContextClickRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncContextClickRequest* internal_default_instance() {
    return reinterpret_cast<const SyncContextClickRequest*>(
               &_SyncContextClickRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SyncContextClickRequest& a, SyncContextClickRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncContextClickRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncContextClickRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncContextClickRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncContextClickRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncContextClickRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncContextClickRequest& from) {
    SyncContextClickRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncContextClickRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SyncContextClickRequest";
  }
  protected:
  explicit SyncContextClickRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kParamFieldNumber = 2,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional .maarpc.ClickParam param = 2;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const ::maarpc::ClickParam& param() const;
  PROTOBUF_NODISCARD ::maarpc::ClickParam* release_param();
  ::maarpc::ClickParam* mutable_param();
  void set_allocated_param(::maarpc::ClickParam* param);
  private:
  const ::maarpc::ClickParam& _internal_param() const;
  ::maarpc::ClickParam* _internal_mutable_param();
  public:
  void unsafe_arena_set_allocated_param(
      ::maarpc::ClickParam* param);
  ::maarpc::ClickParam* unsafe_arena_release_param();

  // @@protoc_insertion_point(class_scope:maarpc.SyncContextClickRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::maarpc::ClickParam* param_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sync_2econtext_2eproto;
};
// -------------------------------------------------------------------

class SyncContextSwipeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SyncContextSwipeRequest) */ {
 public:
  inline SyncContextSwipeRequest() : SyncContextSwipeRequest(nullptr) {}
  ~SyncContextSwipeRequest() override;
  explicit PROTOBUF_CONSTEXPR SyncContextSwipeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncContextSwipeRequest(const SyncContextSwipeRequest& from);
  SyncContextSwipeRequest(SyncContextSwipeRequest&& from) noexcept
    : SyncContextSwipeRequest() {
    *this = ::std::move(from);
  }

  inline SyncContextSwipeRequest& operator=(const SyncContextSwipeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncContextSwipeRequest& operator=(SyncContextSwipeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncContextSwipeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncContextSwipeRequest* internal_default_instance() {
    return reinterpret_cast<const SyncContextSwipeRequest*>(
               &_SyncContextSwipeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SyncContextSwipeRequest& a, SyncContextSwipeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncContextSwipeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncContextSwipeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncContextSwipeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncContextSwipeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncContextSwipeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncContextSwipeRequest& from) {
    SyncContextSwipeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncContextSwipeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SyncContextSwipeRequest";
  }
  protected:
  explicit SyncContextSwipeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kParamFieldNumber = 2,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional .maarpc.SwipeParam param = 2;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const ::maarpc::SwipeParam& param() const;
  PROTOBUF_NODISCARD ::maarpc::SwipeParam* release_param();
  ::maarpc::SwipeParam* mutable_param();
  void set_allocated_param(::maarpc::SwipeParam* param);
  private:
  const ::maarpc::SwipeParam& _internal_param() const;
  ::maarpc::SwipeParam* _internal_mutable_param();
  public:
  void unsafe_arena_set_allocated_param(
      ::maarpc::SwipeParam* param);
  ::maarpc::SwipeParam* unsafe_arena_release_param();

  // @@protoc_insertion_point(class_scope:maarpc.SyncContextSwipeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::maarpc::SwipeParam* param_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sync_2econtext_2eproto;
};
// -------------------------------------------------------------------

class SyncContextKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SyncContextKeyRequest) */ {
 public:
  inline SyncContextKeyRequest() : SyncContextKeyRequest(nullptr) {}
  ~SyncContextKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR SyncContextKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncContextKeyRequest(const SyncContextKeyRequest& from);
  SyncContextKeyRequest(SyncContextKeyRequest&& from) noexcept
    : SyncContextKeyRequest() {
    *this = ::std::move(from);
  }

  inline SyncContextKeyRequest& operator=(const SyncContextKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncContextKeyRequest& operator=(SyncContextKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncContextKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncContextKeyRequest* internal_default_instance() {
    return reinterpret_cast<const SyncContextKeyRequest*>(
               &_SyncContextKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SyncContextKeyRequest& a, SyncContextKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncContextKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncContextKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncContextKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncContextKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncContextKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncContextKeyRequest& from) {
    SyncContextKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncContextKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SyncContextKeyRequest";
  }
  protected:
  explicit SyncContextKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kParamFieldNumber = 2,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional .maarpc.KeyParam param = 2;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const ::maarpc::KeyParam& param() const;
  PROTOBUF_NODISCARD ::maarpc::KeyParam* release_param();
  ::maarpc::KeyParam* mutable_param();
  void set_allocated_param(::maarpc::KeyParam* param);
  private:
  const ::maarpc::KeyParam& _internal_param() const;
  ::maarpc::KeyParam* _internal_mutable_param();
  public:
  void unsafe_arena_set_allocated_param(
      ::maarpc::KeyParam* param);
  ::maarpc::KeyParam* unsafe_arena_release_param();

  // @@protoc_insertion_point(class_scope:maarpc.SyncContextKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::maarpc::KeyParam* param_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sync_2econtext_2eproto;
};
// -------------------------------------------------------------------

class SyncContextTouchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SyncContextTouchRequest) */ {
 public:
  inline SyncContextTouchRequest() : SyncContextTouchRequest(nullptr) {}
  ~SyncContextTouchRequest() override;
  explicit PROTOBUF_CONSTEXPR SyncContextTouchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncContextTouchRequest(const SyncContextTouchRequest& from);
  SyncContextTouchRequest(SyncContextTouchRequest&& from) noexcept
    : SyncContextTouchRequest() {
    *this = ::std::move(from);
  }

  inline SyncContextTouchRequest& operator=(const SyncContextTouchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncContextTouchRequest& operator=(SyncContextTouchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncContextTouchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncContextTouchRequest* internal_default_instance() {
    return reinterpret_cast<const SyncContextTouchRequest*>(
               &_SyncContextTouchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SyncContextTouchRequest& a, SyncContextTouchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncContextTouchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncContextTouchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncContextTouchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncContextTouchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncContextTouchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncContextTouchRequest& from) {
    SyncContextTouchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncContextTouchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SyncContextTouchRequest";
  }
  protected:
  explicit SyncContextTouchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kParamFieldNumber = 2,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional .maarpc.TouchParam param = 2;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const ::maarpc::TouchParam& param() const;
  PROTOBUF_NODISCARD ::maarpc::TouchParam* release_param();
  ::maarpc::TouchParam* mutable_param();
  void set_allocated_param(::maarpc::TouchParam* param);
  private:
  const ::maarpc::TouchParam& _internal_param() const;
  ::maarpc::TouchParam* _internal_mutable_param();
  public:
  void unsafe_arena_set_allocated_param(
      ::maarpc::TouchParam* param);
  ::maarpc::TouchParam* unsafe_arena_release_param();

  // @@protoc_insertion_point(class_scope:maarpc.SyncContextTouchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::maarpc::TouchParam* param_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sync_2econtext_2eproto;
};
// -------------------------------------------------------------------

class SyncContextScreencapRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:maarpc.SyncContextScreencapRequest) */ {
 public:
  inline SyncContextScreencapRequest() : SyncContextScreencapRequest(nullptr) {}
  ~SyncContextScreencapRequest() override;
  explicit PROTOBUF_CONSTEXPR SyncContextScreencapRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncContextScreencapRequest(const SyncContextScreencapRequest& from);
  SyncContextScreencapRequest(SyncContextScreencapRequest&& from) noexcept
    : SyncContextScreencapRequest() {
    *this = ::std::move(from);
  }

  inline SyncContextScreencapRequest& operator=(const SyncContextScreencapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncContextScreencapRequest& operator=(SyncContextScreencapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncContextScreencapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncContextScreencapRequest* internal_default_instance() {
    return reinterpret_cast<const SyncContextScreencapRequest*>(
               &_SyncContextScreencapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SyncContextScreencapRequest& a, SyncContextScreencapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SyncContextScreencapRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncContextScreencapRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncContextScreencapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncContextScreencapRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SyncContextScreencapRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SyncContextScreencapRequest& from) {
    SyncContextScreencapRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncContextScreencapRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "maarpc.SyncContextScreencapRequest";
  }
  protected:
  explicit SyncContextScreencapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kImageHandleFieldNumber = 2,
  };
  // optional string handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  const std::string& handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_handle();
  PROTOBUF_NODISCARD std::string* release_handle();
  void set_allocated_handle(std::string* handle);
  private:
  const std::string& _internal_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_handle(const std::string& value);
  std::string* _internal_mutable_handle();
  public:

  // optional string image_handle = 2;
  bool has_image_handle() const;
  private:
  bool _internal_has_image_handle() const;
  public:
  void clear_image_handle();
  const std::string& image_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_handle();
  PROTOBUF_NODISCARD std::string* release_image_handle();
  void set_allocated_image_handle(std::string* image_handle);
  private:
  const std::string& _internal_image_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_handle(const std::string& value);
  std::string* _internal_mutable_image_handle();
  public:

  // @@protoc_insertion_point(class_scope:maarpc.SyncContextScreencapRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr handle_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sync_2econtext_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SyncContextRunTaskRequest

// optional string handle = 1;
inline bool SyncContextRunTaskRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SyncContextRunTaskRequest::has_handle() const {
  return _internal_has_handle();
}
inline void SyncContextRunTaskRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncContextRunTaskRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunTaskRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunTaskRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunTaskRequest.handle)
}
inline std::string* SyncContextRunTaskRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunTaskRequest.handle)
  return _s;
}
inline const std::string& SyncContextRunTaskRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void SyncContextRunTaskRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunTaskRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunTaskRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunTaskRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunTaskRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunTaskRequest.handle)
}

// optional string task = 2;
inline bool SyncContextRunTaskRequest::_internal_has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SyncContextRunTaskRequest::has_task() const {
  return _internal_has_task();
}
inline void SyncContextRunTaskRequest::clear_task() {
  _impl_.task_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SyncContextRunTaskRequest::task() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunTaskRequest.task)
  return _internal_task();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunTaskRequest::set_task(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.task_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunTaskRequest.task)
}
inline std::string* SyncContextRunTaskRequest::mutable_task() {
  std::string* _s = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunTaskRequest.task)
  return _s;
}
inline const std::string& SyncContextRunTaskRequest::_internal_task() const {
  return _impl_.task_.Get();
}
inline void SyncContextRunTaskRequest::_internal_set_task(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.task_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunTaskRequest::_internal_mutable_task() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.task_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunTaskRequest::release_task() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunTaskRequest.task)
  if (!_internal_has_task()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.task_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_.IsDefault()) {
    _impl_.task_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunTaskRequest::set_allocated_task(std::string* task) {
  if (task != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.task_.SetAllocated(task, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_.IsDefault()) {
    _impl_.task_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunTaskRequest.task)
}

// optional string param = 3;
inline bool SyncContextRunTaskRequest::_internal_has_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SyncContextRunTaskRequest::has_param() const {
  return _internal_has_param();
}
inline void SyncContextRunTaskRequest::clear_param() {
  _impl_.param_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SyncContextRunTaskRequest::param() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunTaskRequest.param)
  return _internal_param();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunTaskRequest::set_param(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.param_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunTaskRequest.param)
}
inline std::string* SyncContextRunTaskRequest::mutable_param() {
  std::string* _s = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunTaskRequest.param)
  return _s;
}
inline const std::string& SyncContextRunTaskRequest::_internal_param() const {
  return _impl_.param_.Get();
}
inline void SyncContextRunTaskRequest::_internal_set_param(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.param_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunTaskRequest::_internal_mutable_param() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.param_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunTaskRequest::release_param() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunTaskRequest.param)
  if (!_internal_has_param()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.param_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunTaskRequest::set_allocated_param(std::string* param) {
  if (param != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.param_.SetAllocated(param, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunTaskRequest.param)
}

// -------------------------------------------------------------------

// SyncContextRunRecognizerRequest

// optional string handle = 1;
inline bool SyncContextRunRecognizerRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SyncContextRunRecognizerRequest::has_handle() const {
  return _internal_has_handle();
}
inline void SyncContextRunRecognizerRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncContextRunRecognizerRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunRecognizerRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunRecognizerRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunRecognizerRequest.handle)
}
inline std::string* SyncContextRunRecognizerRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunRecognizerRequest.handle)
  return _s;
}
inline const std::string& SyncContextRunRecognizerRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void SyncContextRunRecognizerRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunRecognizerRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunRecognizerRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunRecognizerRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunRecognizerRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunRecognizerRequest.handle)
}

// optional string task = 2;
inline bool SyncContextRunRecognizerRequest::_internal_has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SyncContextRunRecognizerRequest::has_task() const {
  return _internal_has_task();
}
inline void SyncContextRunRecognizerRequest::clear_task() {
  _impl_.task_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SyncContextRunRecognizerRequest::task() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunRecognizerRequest.task)
  return _internal_task();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunRecognizerRequest::set_task(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.task_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunRecognizerRequest.task)
}
inline std::string* SyncContextRunRecognizerRequest::mutable_task() {
  std::string* _s = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunRecognizerRequest.task)
  return _s;
}
inline const std::string& SyncContextRunRecognizerRequest::_internal_task() const {
  return _impl_.task_.Get();
}
inline void SyncContextRunRecognizerRequest::_internal_set_task(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.task_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunRecognizerRequest::_internal_mutable_task() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.task_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunRecognizerRequest::release_task() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunRecognizerRequest.task)
  if (!_internal_has_task()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.task_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_.IsDefault()) {
    _impl_.task_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunRecognizerRequest::set_allocated_task(std::string* task) {
  if (task != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.task_.SetAllocated(task, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_.IsDefault()) {
    _impl_.task_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunRecognizerRequest.task)
}

// optional string param = 3;
inline bool SyncContextRunRecognizerRequest::_internal_has_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SyncContextRunRecognizerRequest::has_param() const {
  return _internal_has_param();
}
inline void SyncContextRunRecognizerRequest::clear_param() {
  _impl_.param_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SyncContextRunRecognizerRequest::param() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunRecognizerRequest.param)
  return _internal_param();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunRecognizerRequest::set_param(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.param_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunRecognizerRequest.param)
}
inline std::string* SyncContextRunRecognizerRequest::mutable_param() {
  std::string* _s = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunRecognizerRequest.param)
  return _s;
}
inline const std::string& SyncContextRunRecognizerRequest::_internal_param() const {
  return _impl_.param_.Get();
}
inline void SyncContextRunRecognizerRequest::_internal_set_param(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.param_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunRecognizerRequest::_internal_mutable_param() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.param_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunRecognizerRequest::release_param() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunRecognizerRequest.param)
  if (!_internal_has_param()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.param_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunRecognizerRequest::set_allocated_param(std::string* param) {
  if (param != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.param_.SetAllocated(param, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunRecognizerRequest.param)
}

// optional string image_handle = 4;
inline bool SyncContextRunRecognizerRequest::_internal_has_image_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SyncContextRunRecognizerRequest::has_image_handle() const {
  return _internal_has_image_handle();
}
inline void SyncContextRunRecognizerRequest::clear_image_handle() {
  _impl_.image_handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SyncContextRunRecognizerRequest::image_handle() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunRecognizerRequest.image_handle)
  return _internal_image_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunRecognizerRequest::set_image_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.image_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunRecognizerRequest.image_handle)
}
inline std::string* SyncContextRunRecognizerRequest::mutable_image_handle() {
  std::string* _s = _internal_mutable_image_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunRecognizerRequest.image_handle)
  return _s;
}
inline const std::string& SyncContextRunRecognizerRequest::_internal_image_handle() const {
  return _impl_.image_handle_.Get();
}
inline void SyncContextRunRecognizerRequest::_internal_set_image_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.image_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunRecognizerRequest::_internal_mutable_image_handle() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.image_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunRecognizerRequest::release_image_handle() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunRecognizerRequest.image_handle)
  if (!_internal_has_image_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.image_handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_handle_.IsDefault()) {
    _impl_.image_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunRecognizerRequest::set_allocated_image_handle(std::string* image_handle) {
  if (image_handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.image_handle_.SetAllocated(image_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_handle_.IsDefault()) {
    _impl_.image_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunRecognizerRequest.image_handle)
}

// -------------------------------------------------------------------

// SyncContextRunRecognizerResponse

// optional bool match = 1;
inline bool SyncContextRunRecognizerResponse::_internal_has_match() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SyncContextRunRecognizerResponse::has_match() const {
  return _internal_has_match();
}
inline void SyncContextRunRecognizerResponse::clear_match() {
  _impl_.match_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool SyncContextRunRecognizerResponse::_internal_match() const {
  return _impl_.match_;
}
inline bool SyncContextRunRecognizerResponse::match() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunRecognizerResponse.match)
  return _internal_match();
}
inline void SyncContextRunRecognizerResponse::_internal_set_match(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.match_ = value;
}
inline void SyncContextRunRecognizerResponse::set_match(bool value) {
  _internal_set_match(value);
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunRecognizerResponse.match)
}

// optional .maarpc.Rect box = 2;
inline bool SyncContextRunRecognizerResponse::_internal_has_box() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.box_ != nullptr);
  return value;
}
inline bool SyncContextRunRecognizerResponse::has_box() const {
  return _internal_has_box();
}
inline const ::maarpc::Rect& SyncContextRunRecognizerResponse::_internal_box() const {
  const ::maarpc::Rect* p = _impl_.box_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::Rect&>(
      ::maarpc::_Rect_default_instance_);
}
inline const ::maarpc::Rect& SyncContextRunRecognizerResponse::box() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunRecognizerResponse.box)
  return _internal_box();
}
inline void SyncContextRunRecognizerResponse::unsafe_arena_set_allocated_box(
    ::maarpc::Rect* box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.box_);
  }
  _impl_.box_ = box;
  if (box) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.SyncContextRunRecognizerResponse.box)
}
inline ::maarpc::Rect* SyncContextRunRecognizerResponse::release_box() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::Rect* temp = _impl_.box_;
  _impl_.box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::Rect* SyncContextRunRecognizerResponse::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunRecognizerResponse.box)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::Rect* temp = _impl_.box_;
  _impl_.box_ = nullptr;
  return temp;
}
inline ::maarpc::Rect* SyncContextRunRecognizerResponse::_internal_mutable_box() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.box_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::Rect>(GetArenaForAllocation());
    _impl_.box_ = p;
  }
  return _impl_.box_;
}
inline ::maarpc::Rect* SyncContextRunRecognizerResponse::mutable_box() {
  ::maarpc::Rect* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunRecognizerResponse.box)
  return _msg;
}
inline void SyncContextRunRecognizerResponse::set_allocated_box(::maarpc::Rect* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.box_);
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box));
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.box_ = box;
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunRecognizerResponse.box)
}

// optional string detail = 3;
inline bool SyncContextRunRecognizerResponse::_internal_has_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SyncContextRunRecognizerResponse::has_detail() const {
  return _internal_has_detail();
}
inline void SyncContextRunRecognizerResponse::clear_detail() {
  _impl_.detail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncContextRunRecognizerResponse::detail() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunRecognizerResponse.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunRecognizerResponse::set_detail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunRecognizerResponse.detail)
}
inline std::string* SyncContextRunRecognizerResponse::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunRecognizerResponse.detail)
  return _s;
}
inline const std::string& SyncContextRunRecognizerResponse::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void SyncContextRunRecognizerResponse::_internal_set_detail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunRecognizerResponse::_internal_mutable_detail() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunRecognizerResponse::release_detail() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunRecognizerResponse.detail)
  if (!_internal_has_detail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.detail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunRecognizerResponse::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunRecognizerResponse.detail)
}

// -------------------------------------------------------------------

// SyncContextRunActionRequest

// optional string handle = 1;
inline bool SyncContextRunActionRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SyncContextRunActionRequest::has_handle() const {
  return _internal_has_handle();
}
inline void SyncContextRunActionRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncContextRunActionRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunActionRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunActionRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunActionRequest.handle)
}
inline std::string* SyncContextRunActionRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunActionRequest.handle)
  return _s;
}
inline const std::string& SyncContextRunActionRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void SyncContextRunActionRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunActionRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunActionRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunActionRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunActionRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunActionRequest.handle)
}

// optional string task = 2;
inline bool SyncContextRunActionRequest::_internal_has_task() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SyncContextRunActionRequest::has_task() const {
  return _internal_has_task();
}
inline void SyncContextRunActionRequest::clear_task() {
  _impl_.task_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SyncContextRunActionRequest::task() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunActionRequest.task)
  return _internal_task();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunActionRequest::set_task(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.task_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunActionRequest.task)
}
inline std::string* SyncContextRunActionRequest::mutable_task() {
  std::string* _s = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunActionRequest.task)
  return _s;
}
inline const std::string& SyncContextRunActionRequest::_internal_task() const {
  return _impl_.task_.Get();
}
inline void SyncContextRunActionRequest::_internal_set_task(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.task_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunActionRequest::_internal_mutable_task() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.task_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunActionRequest::release_task() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunActionRequest.task)
  if (!_internal_has_task()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.task_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_.IsDefault()) {
    _impl_.task_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunActionRequest::set_allocated_task(std::string* task) {
  if (task != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.task_.SetAllocated(task, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_.IsDefault()) {
    _impl_.task_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunActionRequest.task)
}

// optional string param = 3;
inline bool SyncContextRunActionRequest::_internal_has_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SyncContextRunActionRequest::has_param() const {
  return _internal_has_param();
}
inline void SyncContextRunActionRequest::clear_param() {
  _impl_.param_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SyncContextRunActionRequest::param() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunActionRequest.param)
  return _internal_param();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunActionRequest::set_param(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.param_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunActionRequest.param)
}
inline std::string* SyncContextRunActionRequest::mutable_param() {
  std::string* _s = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunActionRequest.param)
  return _s;
}
inline const std::string& SyncContextRunActionRequest::_internal_param() const {
  return _impl_.param_.Get();
}
inline void SyncContextRunActionRequest::_internal_set_param(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.param_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunActionRequest::_internal_mutable_param() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.param_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunActionRequest::release_param() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunActionRequest.param)
  if (!_internal_has_param()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.param_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunActionRequest::set_allocated_param(std::string* param) {
  if (param != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.param_.SetAllocated(param, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.param_.IsDefault()) {
    _impl_.param_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunActionRequest.param)
}

// optional .maarpc.Rect box = 4;
inline bool SyncContextRunActionRequest::_internal_has_box() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.box_ != nullptr);
  return value;
}
inline bool SyncContextRunActionRequest::has_box() const {
  return _internal_has_box();
}
inline const ::maarpc::Rect& SyncContextRunActionRequest::_internal_box() const {
  const ::maarpc::Rect* p = _impl_.box_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::Rect&>(
      ::maarpc::_Rect_default_instance_);
}
inline const ::maarpc::Rect& SyncContextRunActionRequest::box() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunActionRequest.box)
  return _internal_box();
}
inline void SyncContextRunActionRequest::unsafe_arena_set_allocated_box(
    ::maarpc::Rect* box) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.box_);
  }
  _impl_.box_ = box;
  if (box) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.SyncContextRunActionRequest.box)
}
inline ::maarpc::Rect* SyncContextRunActionRequest::release_box() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::maarpc::Rect* temp = _impl_.box_;
  _impl_.box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::Rect* SyncContextRunActionRequest::unsafe_arena_release_box() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunActionRequest.box)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::maarpc::Rect* temp = _impl_.box_;
  _impl_.box_ = nullptr;
  return temp;
}
inline ::maarpc::Rect* SyncContextRunActionRequest::_internal_mutable_box() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.box_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::Rect>(GetArenaForAllocation());
    _impl_.box_ = p;
  }
  return _impl_.box_;
}
inline ::maarpc::Rect* SyncContextRunActionRequest::mutable_box() {
  ::maarpc::Rect* _msg = _internal_mutable_box();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunActionRequest.box)
  return _msg;
}
inline void SyncContextRunActionRequest::set_allocated_box(::maarpc::Rect* box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.box_);
  }
  if (box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(box));
    if (message_arena != submessage_arena) {
      box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, box, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.box_ = box;
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunActionRequest.box)
}

// optional string detail = 5;
inline bool SyncContextRunActionRequest::_internal_has_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SyncContextRunActionRequest::has_detail() const {
  return _internal_has_detail();
}
inline void SyncContextRunActionRequest::clear_detail() {
  _impl_.detail_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SyncContextRunActionRequest::detail() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextRunActionRequest.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextRunActionRequest::set_detail(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextRunActionRequest.detail)
}
inline std::string* SyncContextRunActionRequest::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextRunActionRequest.detail)
  return _s;
}
inline const std::string& SyncContextRunActionRequest::_internal_detail() const {
  return _impl_.detail_.Get();
}
inline void SyncContextRunActionRequest::_internal_set_detail(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.detail_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextRunActionRequest::_internal_mutable_detail() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.detail_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextRunActionRequest::release_detail() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextRunActionRequest.detail)
  if (!_internal_has_detail()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.detail_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextRunActionRequest::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.detail_.IsDefault()) {
    _impl_.detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextRunActionRequest.detail)
}

// -------------------------------------------------------------------

// SyncContextClickRequest

// optional string handle = 1;
inline bool SyncContextClickRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SyncContextClickRequest::has_handle() const {
  return _internal_has_handle();
}
inline void SyncContextClickRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncContextClickRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextClickRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextClickRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextClickRequest.handle)
}
inline std::string* SyncContextClickRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextClickRequest.handle)
  return _s;
}
inline const std::string& SyncContextClickRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void SyncContextClickRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextClickRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextClickRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextClickRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextClickRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextClickRequest.handle)
}

// optional .maarpc.ClickParam param = 2;
inline bool SyncContextClickRequest::_internal_has_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.param_ != nullptr);
  return value;
}
inline bool SyncContextClickRequest::has_param() const {
  return _internal_has_param();
}
inline const ::maarpc::ClickParam& SyncContextClickRequest::_internal_param() const {
  const ::maarpc::ClickParam* p = _impl_.param_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::ClickParam&>(
      ::maarpc::_ClickParam_default_instance_);
}
inline const ::maarpc::ClickParam& SyncContextClickRequest::param() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextClickRequest.param)
  return _internal_param();
}
inline void SyncContextClickRequest::unsafe_arena_set_allocated_param(
    ::maarpc::ClickParam* param) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.param_);
  }
  _impl_.param_ = param;
  if (param) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.SyncContextClickRequest.param)
}
inline ::maarpc::ClickParam* SyncContextClickRequest::release_param() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::ClickParam* temp = _impl_.param_;
  _impl_.param_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::ClickParam* SyncContextClickRequest::unsafe_arena_release_param() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextClickRequest.param)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::ClickParam* temp = _impl_.param_;
  _impl_.param_ = nullptr;
  return temp;
}
inline ::maarpc::ClickParam* SyncContextClickRequest::_internal_mutable_param() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.param_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::ClickParam>(GetArenaForAllocation());
    _impl_.param_ = p;
  }
  return _impl_.param_;
}
inline ::maarpc::ClickParam* SyncContextClickRequest::mutable_param() {
  ::maarpc::ClickParam* _msg = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextClickRequest.param)
  return _msg;
}
inline void SyncContextClickRequest::set_allocated_param(::maarpc::ClickParam* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.param_);
  }
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(param));
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.param_ = param;
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextClickRequest.param)
}

// -------------------------------------------------------------------

// SyncContextSwipeRequest

// optional string handle = 1;
inline bool SyncContextSwipeRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SyncContextSwipeRequest::has_handle() const {
  return _internal_has_handle();
}
inline void SyncContextSwipeRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncContextSwipeRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextSwipeRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextSwipeRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextSwipeRequest.handle)
}
inline std::string* SyncContextSwipeRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextSwipeRequest.handle)
  return _s;
}
inline const std::string& SyncContextSwipeRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void SyncContextSwipeRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextSwipeRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextSwipeRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextSwipeRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextSwipeRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextSwipeRequest.handle)
}

// optional .maarpc.SwipeParam param = 2;
inline bool SyncContextSwipeRequest::_internal_has_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.param_ != nullptr);
  return value;
}
inline bool SyncContextSwipeRequest::has_param() const {
  return _internal_has_param();
}
inline const ::maarpc::SwipeParam& SyncContextSwipeRequest::_internal_param() const {
  const ::maarpc::SwipeParam* p = _impl_.param_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::SwipeParam&>(
      ::maarpc::_SwipeParam_default_instance_);
}
inline const ::maarpc::SwipeParam& SyncContextSwipeRequest::param() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextSwipeRequest.param)
  return _internal_param();
}
inline void SyncContextSwipeRequest::unsafe_arena_set_allocated_param(
    ::maarpc::SwipeParam* param) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.param_);
  }
  _impl_.param_ = param;
  if (param) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.SyncContextSwipeRequest.param)
}
inline ::maarpc::SwipeParam* SyncContextSwipeRequest::release_param() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::SwipeParam* temp = _impl_.param_;
  _impl_.param_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::SwipeParam* SyncContextSwipeRequest::unsafe_arena_release_param() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextSwipeRequest.param)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::SwipeParam* temp = _impl_.param_;
  _impl_.param_ = nullptr;
  return temp;
}
inline ::maarpc::SwipeParam* SyncContextSwipeRequest::_internal_mutable_param() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.param_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::SwipeParam>(GetArenaForAllocation());
    _impl_.param_ = p;
  }
  return _impl_.param_;
}
inline ::maarpc::SwipeParam* SyncContextSwipeRequest::mutable_param() {
  ::maarpc::SwipeParam* _msg = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextSwipeRequest.param)
  return _msg;
}
inline void SyncContextSwipeRequest::set_allocated_param(::maarpc::SwipeParam* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.param_);
  }
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(param));
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.param_ = param;
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextSwipeRequest.param)
}

// -------------------------------------------------------------------

// SyncContextKeyRequest

// optional string handle = 1;
inline bool SyncContextKeyRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SyncContextKeyRequest::has_handle() const {
  return _internal_has_handle();
}
inline void SyncContextKeyRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncContextKeyRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextKeyRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextKeyRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextKeyRequest.handle)
}
inline std::string* SyncContextKeyRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextKeyRequest.handle)
  return _s;
}
inline const std::string& SyncContextKeyRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void SyncContextKeyRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextKeyRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextKeyRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextKeyRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextKeyRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextKeyRequest.handle)
}

// optional .maarpc.KeyParam param = 2;
inline bool SyncContextKeyRequest::_internal_has_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.param_ != nullptr);
  return value;
}
inline bool SyncContextKeyRequest::has_param() const {
  return _internal_has_param();
}
inline const ::maarpc::KeyParam& SyncContextKeyRequest::_internal_param() const {
  const ::maarpc::KeyParam* p = _impl_.param_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::KeyParam&>(
      ::maarpc::_KeyParam_default_instance_);
}
inline const ::maarpc::KeyParam& SyncContextKeyRequest::param() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextKeyRequest.param)
  return _internal_param();
}
inline void SyncContextKeyRequest::unsafe_arena_set_allocated_param(
    ::maarpc::KeyParam* param) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.param_);
  }
  _impl_.param_ = param;
  if (param) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.SyncContextKeyRequest.param)
}
inline ::maarpc::KeyParam* SyncContextKeyRequest::release_param() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::KeyParam* temp = _impl_.param_;
  _impl_.param_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::KeyParam* SyncContextKeyRequest::unsafe_arena_release_param() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextKeyRequest.param)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::KeyParam* temp = _impl_.param_;
  _impl_.param_ = nullptr;
  return temp;
}
inline ::maarpc::KeyParam* SyncContextKeyRequest::_internal_mutable_param() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.param_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::KeyParam>(GetArenaForAllocation());
    _impl_.param_ = p;
  }
  return _impl_.param_;
}
inline ::maarpc::KeyParam* SyncContextKeyRequest::mutable_param() {
  ::maarpc::KeyParam* _msg = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextKeyRequest.param)
  return _msg;
}
inline void SyncContextKeyRequest::set_allocated_param(::maarpc::KeyParam* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.param_);
  }
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(param));
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.param_ = param;
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextKeyRequest.param)
}

// -------------------------------------------------------------------

// SyncContextTouchRequest

// optional string handle = 1;
inline bool SyncContextTouchRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SyncContextTouchRequest::has_handle() const {
  return _internal_has_handle();
}
inline void SyncContextTouchRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncContextTouchRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextTouchRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextTouchRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextTouchRequest.handle)
}
inline std::string* SyncContextTouchRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextTouchRequest.handle)
  return _s;
}
inline const std::string& SyncContextTouchRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void SyncContextTouchRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextTouchRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextTouchRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextTouchRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextTouchRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextTouchRequest.handle)
}

// optional .maarpc.TouchParam param = 2;
inline bool SyncContextTouchRequest::_internal_has_param() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.param_ != nullptr);
  return value;
}
inline bool SyncContextTouchRequest::has_param() const {
  return _internal_has_param();
}
inline const ::maarpc::TouchParam& SyncContextTouchRequest::_internal_param() const {
  const ::maarpc::TouchParam* p = _impl_.param_;
  return p != nullptr ? *p : reinterpret_cast<const ::maarpc::TouchParam&>(
      ::maarpc::_TouchParam_default_instance_);
}
inline const ::maarpc::TouchParam& SyncContextTouchRequest::param() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextTouchRequest.param)
  return _internal_param();
}
inline void SyncContextTouchRequest::unsafe_arena_set_allocated_param(
    ::maarpc::TouchParam* param) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.param_);
  }
  _impl_.param_ = param;
  if (param) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:maarpc.SyncContextTouchRequest.param)
}
inline ::maarpc::TouchParam* SyncContextTouchRequest::release_param() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::TouchParam* temp = _impl_.param_;
  _impl_.param_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::maarpc::TouchParam* SyncContextTouchRequest::unsafe_arena_release_param() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextTouchRequest.param)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::maarpc::TouchParam* temp = _impl_.param_;
  _impl_.param_ = nullptr;
  return temp;
}
inline ::maarpc::TouchParam* SyncContextTouchRequest::_internal_mutable_param() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.param_ == nullptr) {
    auto* p = CreateMaybeMessage<::maarpc::TouchParam>(GetArenaForAllocation());
    _impl_.param_ = p;
  }
  return _impl_.param_;
}
inline ::maarpc::TouchParam* SyncContextTouchRequest::mutable_param() {
  ::maarpc::TouchParam* _msg = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextTouchRequest.param)
  return _msg;
}
inline void SyncContextTouchRequest::set_allocated_param(::maarpc::TouchParam* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.param_);
  }
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(param));
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.param_ = param;
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextTouchRequest.param)
}

// -------------------------------------------------------------------

// SyncContextScreencapRequest

// optional string handle = 1;
inline bool SyncContextScreencapRequest::_internal_has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SyncContextScreencapRequest::has_handle() const {
  return _internal_has_handle();
}
inline void SyncContextScreencapRequest::clear_handle() {
  _impl_.handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncContextScreencapRequest::handle() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextScreencapRequest.handle)
  return _internal_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextScreencapRequest::set_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextScreencapRequest.handle)
}
inline std::string* SyncContextScreencapRequest::mutable_handle() {
  std::string* _s = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextScreencapRequest.handle)
  return _s;
}
inline const std::string& SyncContextScreencapRequest::_internal_handle() const {
  return _impl_.handle_.Get();
}
inline void SyncContextScreencapRequest::_internal_set_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextScreencapRequest::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextScreencapRequest::release_handle() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextScreencapRequest.handle)
  if (!_internal_has_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextScreencapRequest::set_allocated_handle(std::string* handle) {
  if (handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.handle_.SetAllocated(handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.handle_.IsDefault()) {
    _impl_.handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextScreencapRequest.handle)
}

// optional string image_handle = 2;
inline bool SyncContextScreencapRequest::_internal_has_image_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SyncContextScreencapRequest::has_image_handle() const {
  return _internal_has_image_handle();
}
inline void SyncContextScreencapRequest::clear_image_handle() {
  _impl_.image_handle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SyncContextScreencapRequest::image_handle() const {
  // @@protoc_insertion_point(field_get:maarpc.SyncContextScreencapRequest.image_handle)
  return _internal_image_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncContextScreencapRequest::set_image_handle(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.image_handle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:maarpc.SyncContextScreencapRequest.image_handle)
}
inline std::string* SyncContextScreencapRequest::mutable_image_handle() {
  std::string* _s = _internal_mutable_image_handle();
  // @@protoc_insertion_point(field_mutable:maarpc.SyncContextScreencapRequest.image_handle)
  return _s;
}
inline const std::string& SyncContextScreencapRequest::_internal_image_handle() const {
  return _impl_.image_handle_.Get();
}
inline void SyncContextScreencapRequest::_internal_set_image_handle(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.image_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncContextScreencapRequest::_internal_mutable_image_handle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.image_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncContextScreencapRequest::release_image_handle() {
  // @@protoc_insertion_point(field_release:maarpc.SyncContextScreencapRequest.image_handle)
  if (!_internal_has_image_handle()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.image_handle_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_handle_.IsDefault()) {
    _impl_.image_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncContextScreencapRequest::set_allocated_image_handle(std::string* image_handle) {
  if (image_handle != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.image_handle_.SetAllocated(image_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_handle_.IsDefault()) {
    _impl_.image_handle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:maarpc.SyncContextScreencapRequest.image_handle)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace maarpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sync_2econtext_2eproto
